arch 65816
hirom
bank noassume


function BankOf(label) = label>>16

!CrcItemAddrCount = 0
macro MTryGiveItemAndFlag(LocationDefName,Flag)
  db $a9   ; = lda #
#CrcItemAddr!{CrcItemAddrCount}:
#Config_<LocationDefName>:
  dw !{<LocationDefName>}
  jsl LR_GiveAnyItemA16OrSec
  bcs $03
    cop #$CC
    db <Flag>
!CrcItemAddrCount #= 1+!CrcItemAddrCount
endmacro

macro MClzIfHasFlute()
  lda $0a03 : bit #$0001   ; = flag $18
endmacro

incsrc "iogr_exit_ledger.asr"
incsrc "iogr_asset_ledger.asr"
incsrc "iogr_monster_defaults.asr"
incsrc "iogr_misc_defines.asr"



; Bank $80
{

; BRK/COP handler optimization
org $808007
VectorCop:
jml CopHandler
;VectorNmi:
skip 4
VectorBrk:
jml BrkHandler

; A few bytes are optimized out to allow loading HP from a far address
org $808067
lda.l Config_InitialHp : sta $0aca : sta $0ace
lda #$0001 : sta $0ade
nop : nop : nop : nop : nop   ; (in particular, writing 0 to $0adc is not necessary because mem was init'd to 0)

org $808244
if !SettingDebug
jmp $825c    ; Update HUD every frame.
endif

org $808286
cop #$BD : dl Bg3_StatusEnemyHp    ; Needed because Bg3_StatusEnemyHp moved.

org $8082af
cop #$BD : dl Bg3_StatusEnemyHp    ; Needed because Bg3_StatusEnemyHp moved.

; Now ticks the master frame counter by 1 + the number of IRQs since the last NMI.
org $8082f8
NmiHandler:
phb
rep #$20
pha
phx
phy
jsr SR_NmiSetDbrAndMasterFrameCounter
inc $36
sep #$20
nop
; then stz $420c as normal and the rest of the routine;
; then at the end, don't inc $36 nor plp
org $80837f
ply
plx
pla
plb
rti

; Two bytes are optimized out of this routine, to align CopHandler_Pointers at $808485.
org $808438
SR_DmaClearOamStage:
{
php
sep #$20
  lda #$00 : sta $2183
rep #$20
  lda #$0422 : sta $2181
  ldy #$0200 : sty $4305
sep #$20
lda #$08 : sta $4300
lda #$80 : sta $4301
  sta $4304
ldx.w #.Data : stx $4302
lda #$01 : sta $420B
plp
rts
.Data:
db $e0
nop
}

; Optimized COP+BRK vector.
; I developed this to reduce lag during the Apocalypse Gaia fight,
; and it's harmless to include as part of the normal rando code.
CopHandler:
rep #$20
txy
lda $04,s : sta $0c
lda $02,s : tax : dec : sta $0a
lda [$0a] : and #$00ff
stx $0a
asl
#BrkHandler:
tax
jmp.w (.Pointers,x)
.Pointers:
{
skip 2      ; COP #$00
skip 2      ; COP #$01
skip 2      ; COP #$02
skip 2      ; COP #$03
skip 2      ; COP #$04
skip 2      ; COP #$05
skip 2      ; COP #$06
skip 2      ; COP #$07
skip 2      ; COP #$08
skip 2      ; COP #$09
skip 2      ; COP #$0A
skip 2      ; COP #$0B
skip 2      ; COP #$0C
skip 2      ; COP #$0D
skip 2      ; COP #$0E
skip 2      ; COP #$0F
skip 2      ; COP #$10
skip 2      ; COP #$11
skip 2      ; COP #$12
skip 2      ; COP #$13
skip 2      ; COP #$14
skip 2      ; COP #$15
skip 2      ; COP #$16
skip 2      ; COP #$17
skip 2      ; COP #$18
skip 2      ; COP #$19
skip 2      ; COP #$1A
skip 2      ; COP #$1B
skip 2      ; COP #$1C
skip 2      ; COP #$1D
skip 2      ; COP #$1E
skip 2      ; COP #$1F
skip 2      ; COP #$20
skip 2      ; COP #$21
skip 2      ; COP #$22
dw Cop_23   ; COP #$23
skip 2      ; COP #$24
skip 2      ; COP #$25
skip 2      ; COP #$26
skip 2      ; COP #$27
skip 2      ; COP #$28
skip 2      ; COP #$29
skip 2      ; COP #$2A
skip 2      ; COP #$2B
skip 2      ; COP #$2C
skip 2      ; COP #$2D
skip 2      ; COP #$2E
skip 2      ; COP #$2F
skip 2      ; COP #$30
skip 2      ; COP #$31
skip 2      ; COP #$32
skip 2      ; COP #$33
skip 2      ; COP #$34
skip 2      ; COP #$35
skip 2      ; COP #$36
skip 2      ; COP #$37
skip 2      ; COP #$38
skip 2      ; COP #$39
skip 2      ; COP #$3A
skip 2      ; COP #$3B
skip 2      ; COP #$3C
skip 2      ; COP #$3D
skip 2      ; COP #$3E
skip 2      ; COP #$3F
skip 2      ; COP #$40
skip 2      ; COP #$41
skip 2      ; COP #$42
skip 2      ; COP #$43
skip 2      ; COP #$44
skip 2      ; COP #$45
skip 2      ; COP #$46
skip 2      ; COP #$47
skip 2      ; COP #$48
skip 2      ; COP #$49
skip 2      ; COP #$4A
skip 2      ; COP #$4B
skip 2      ; COP #$4C
skip 2      ; COP #$4D
skip 2      ; COP #$4E
skip 2      ; COP #$4F
skip 2      ; COP #$50
skip 2      ; COP #$51
skip 2      ; COP #$52
skip 2      ; COP #$53
skip 2      ; COP #$54
skip 2      ; COP #$55
skip 2      ; COP #$56
skip 2      ; COP #$57
skip 2      ; COP #$58
skip 2      ; COP #$59
skip 2      ; COP #$5A
skip 2      ; COP #$5B
skip 2      ; COP #$5C
skip 2      ; COP #$5D
skip 2      ; COP #$5E
skip 2      ; COP #$5F
skip 2      ; COP #$60
skip 2      ; COP #$61
skip 2      ; COP #$62
skip 2      ; COP #$63
skip 2      ; COP #$64
skip 2      ; COP #$65
skip 2      ; COP #$66
skip 2      ; COP #$67
skip 2      ; COP #$68
skip 2      ; COP #$69
skip 2      ; COP #$6A
skip 2      ; COP #$6B
skip 2      ; COP #$6C
skip 2      ; COP #$6D
skip 2      ; COP #$6E
skip 2      ; COP #$6F
skip 2      ; COP #$70
skip 2      ; COP #$71
skip 2      ; COP #$72
dw Cop_73   ; COP #$73
; COPs continue to #$E2
}


; Reduce cost of RNG (cop #$23) calls
org $808ffc
Cop_23:
{
;lda $0a : sta $02,s
phy
.FromManaged:
phd
lda #$0400 : tcd
lda #$0000 ; efficiently zero high byte for output
sep #$30
ldx #$0F
clc
-:
  lda $10,x : adc $0f,x : sta $0f,x
  dex : bne -
inc $1f   ; Required to match vanilla RNG outputs
stz $00E6
lda $10
rep #$30
pld
plx
rti
}
warnpc $80902b


; Fixes a vanilla bug wherein cop #$0B masks the wrong tiles if called 
; by a monster of size at least 2x2 on the rightmost tile of a screen.
org $80b2ed
bcs B_80B325
org $80b2f6
J_80B2F6:
org $80b316
rep #$20
dec $1E : beq B_80B325
lda $1A : sta $18
jsr S_80B32B
lda $1C
bra J_80B2F6
B_80B325:
plx
pld
plb
rts
S_80B32B:
php
lda $1C
sep #$20
  clc : adc #$10 : bcs B_80B339
sta $1C
plp
rts
B_80B339:
xba : clc : adc $0693 : xba
rep #$20
sta $1C
plp
rts
warnpc $80b345


org $80b520
db $00,$08
TIndexedPaletteBundle:
cop #$C7 : dl TIndexedPaletteBundleRepl
nop


org $80b7cc
db $00, $08
TFade012NormalToWhite:
cop #$37 : db $18
cop #$39
cop #$3D
rtl

;org $80b7d6
db $00, $08
TFade012WhiteToNormal:
cop #$37 : db $19
cop #$39
cop #$3D
rtl

org $80b88b
; BG parallax thinker conflicts with darkrooms if it writes to CMATH
db $04,$08
jsr SR_DieIfCmathInDarkRoomElseClearBgScrollCounters

org $80be18
; Wavy BG thinker conflicts with darkrooms
db $04,$08
TWavyBgWriter:
jsl LR_SecIfThisMapIsDark : bcc +
  cop #$3D
  rtl
+:
jmp TWavyBgWriterRepl
warnpc $80be39


org $80bcdf
if !ApocalypseGaia == 1

; `cop #$D0 : db $ff,$00 : dw Addr` jumps to Addr during the pre-render frame that runs
; when exiting the inventory. After cop #$C1/#$C2, `bit $0a1e : bpl Addr` is equivalent.
; This is used to refresh HDMA tables clobbered by the inventory screen.

db $04,$08
ECometBG2ShimmerEndpoint:
bit $0A1E : bpl +
  jsr ECometBG2ShimmerEndpointSetup
+:
cop #$02 : dl CometHDMAResetTable : db $10
rtl

db $04,$08
ECometBG2ShimmerA:
lda #$0001 : sta $7F0008,x
cop #$5F : db $00,$88,$08
lda #$0000 : sta $7E8C30
  sta $7E8E30
cop #$C2
bit $0A1E : bpl ECometBG2ShimmerA
cop #$60 : db $05,$02
cop #$61 : db $00,$8C,$7E,$10
rtl

db $04,$08
ECometBG2ShimmerB:
lda #$0008 : sta $7F0008,x
cop #$5F : db $00,$84,$08
cop #$C2
bit $0A1E : bpl ECometBG2ShimmerB
cop #$60 : db $05,$02
cop #$61 : db $00,$84,$7E,$0F
rtl

db $04,$08
ECometBG2ShimmerC:
lda #$0002 : sta $7F0008,x
cop #$5F : db $00,$80,$08
cop #$C2
bit $0A1E : bpl ECometBG2ShimmerC
lda $0A00 : bit #$0002 : bne .CometDead ; cheap alternative to cop #$D0 : db $01,$01 : dw .CometDead
  cop #$60 : db $05,$00
  cop #$61 : db $00,$84,$7E,$0D
  rtl
.CometDead:
lda #$0070 : sta $7F0008,x    ; Materialization magic.
cop #$5F : db $00,$80,$04
cop #$C2
bit $0A1E : bpl .CometDead
lda $7F0008,x : dec : sta $7F0008,x
  beq .TSleep
cop #$60 : db $05,$00
cop #$61 : db $00,$84,$7E,$0D
rtl
.TSleep:
cop #$C1
rtl
endif
warnpc $80BD96



org $80c312
Lut_BossClearRoomSets:
{
db $29,$0c,$29,$00
db $55,$3d,$55,$00
db $67,$5a,$74,$00
db $8a,$82,$a9,$00
db $dd,$cc,$dd,$00
db $f6,$b0,$bf,$00 ; BabelMummyQueen gives rewards.
db $29,$00,$00,$00
db $29,$00,$00,$00
db $29,$00,$00,$00
db $29,$00,$00,$00
db $29,$00,$00,$00
}


org $80c381
jsr SR_IncHpOnceByZ3Setting   ; replaces inc $0aca in boss reward code


org $80c44b
jsr SR_SetWillAbilitySpriteSetOnFlute80   ; replaces cop #$8E : db $04


org $80c66f
db $00 : dw $3000
;ERedJewelPickup:    ; Not enough space here for IOGR implementation,
rtl                  ; so this is nulled out and the new code is elsewhere.



org $80CA42
db $00,$00,$30
EWorldMapTransitionListener:
{
lda $0644
cmp #$0001 : bne +$03 : jmp .HandleMap01
cmp #$000a : bne +$03 : jmp .HandleMap0A
cmp #$0015 : bne +$03 : jmp .HandleMap15
cmp #$001a : bne +$03 : jmp .HandleMap1A
cmp #$001c : bne +$03 : jmp .HandleMap1C
cmp #$0030 : bne +$03 : jmp .HandleMap30
cmp #$0032 : bne +$03 : jmp .HandleMap32
cmp #$003e : bne +$03 : jmp .HandleMap3E
cmp #$0049 : bne +$03 : jmp .HandleMap49
cmp #$0069 : bne +$03 : jmp .HandleMap69
cmp #$0078 : bne +$03 : jmp .HandleMap78
cmp #$0082 : bne +$03 : jmp .HandleMap82
cmp #$0091 : bne +$03 : jmp .HandleMap91
cmp #$00a0 : bne +$03 : jmp .HandleMapA0
cmp #$00ac : bne +$03 : jmp .HandleMapAC
cmp #$00b0 : bne +$03 : jmp .HandleMapB0
cmp #$00c3 : bne +$03 : jmp .HandleMapC3
cmp #$00cc : bne +$03 : jmp .HandleMapCC
rtl
.Done:
lda #$0400 : sta $064A
cop #$C1
rtl
.HandleMap01:
cop #$C1
lda $09A4 : cmp #$0010 : bcc +
  rtl
+:
lda #$0000 : sta $0d60
cop #$66 : dw $00d4,$03a4 : db !OverworldShuffleCapeMenuId
jmp .Done
.HandleMap0A:
lda $09A4 : cmp #$02D0 : beq +
  rtl
+:
lda #$0000 : sta $0D60
cop #$66 : dw $0104,$0334 : db !OverworldShuffleEdMenuId
jmp .Done
.HandleMap15:
cop #$D0 : db $01,$01 : dw ..Flag01Set
cop #$45 : db $2D,$2E,$2F,$30 : dw ..InArea
..Flag01Set:
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $00C4,$02B4 : db !OverworldShuffleItryMenuId
jmp .Done
.HandleMap1A:
cop #$45 : db $14,$1c,$17,$1d : dw ..InArea
rtl
..InArea:
cop #$66 : dw $0090,$0260 : db !OverworldShuffleMoonMenuId
cop #$C1
rtl
.HandleMap1C:
cop #$45 : db $06,$1C,$08,$1E : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0134,$0284 : db !OverworldShuffleIncaMenuId
jmp .Done
.HandleMap30:
cop #$45 : db $03,$00,$06,$01 : dw ..InArea
rtl
..InArea:
cop #$66 : dw $0250,$0350 : db !OverworldShuffleDCstMenuId
cop #$C1
rtl
.HandleMap32:
cop #$45 : db $12,$3C,$16,$3E : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0254,$02D4 : db !OverworldShuffleFrejMenuId
jmp .Done
.HandleMap3E:
cop #$45 : db $0A,$3F,$0C,$40 : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0334,$0334 : db !OverworldShuffleMineMenuId
jmp .Done
.HandleMap49:
cop #$45 : db $07,$0d,$0a,$0e : dw ..InArea
rtl
..InArea:
cop #$66 : dw $0270,$0270 : db !OverworldShuffleNeilMenuId
cop #$C1
rtl
.HandleMap69:
cop #$45 : db $29,$0D,$2C,$0F : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0384,$0164 : db !OverworldShuffleAnglMenuId
jmp .Done
.HandleMap78:
cop #$45 : db $27,$3D,$29,$40 : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $02D4,$01A4 : db !OverworldShuffleWtmaMenuId
jmp .Done
.HandleMap82:
cop #$45 : db $00,$08,$01,$0B : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $02A4,$0124 : db !OverworldShuffleGtWlMenuId
jmp .Done
.HandleMap91:
cop #$45 : db $3F,$42,$40,$48 : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $01D4,$0134 : db !OverworldShuffleEuroMenuId
jmp .Done
.HandleMapA0:
cop #$45 : db $2F,$1B,$30,$1C : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0214,$00B4 : db !OverworldShuffleKresMenuId
jmp .Done
.HandleMapAC:
cop #$45 : db $1F,$1B,$20,$20 : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0124,$01A4 : db !OverworldShuffleNtVlMenuId
jmp .Done
.HandleMapB0:
cop #$45 : db $1D,$4F,$24,$50 : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0134,$0154 : db !OverworldShuffleAnkrMenuId
jmp .Done
.HandleMapC3:
cop #$45 : db $00,$0D,$01,$11 : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0094,$0114 : db !OverworldShuffleDaoMenuId
jmp .Done
.HandleMapCC:
cop #$45 : db $00,$0D,$01,$0F : dw ..InArea
cop #$45 : db $3F,$0D,$40,$0F : dw ..InArea
rtl
..InArea:
lda #$0000 : sta $0D60
cop #$66 : dw $0074,$00B4 : db !OverworldShufflePymdMenuId
jmp .Done
}
warnpc $80cd59


org $80cdb8
jmp EStatueGetCutsceneStatue_BecomeVisible
org $80ce46
; Use cop #$26 when returning from statue-get, not coordinates set by the boss actor.
; Simplifies boss shuffle, which otherwise needs special handling for the return from MQ.
EStatueGetCutsceneStatue_DoWarp:
lda #$0303 : sta $064A
lda #$0002 : sta $0648
lda $28 : sec : sbc #$003a : sta $0000
cop #$D9 : dw $0000, .WarpToOptions
.WarpToOptions:
  dw EStatueGetCutsceneStatue_ToShip
  dw EStatueGetCutsceneStatue_ToSeaPalace
  dw EStatueGetCutsceneStatue_ToRama
  dw EStatueGetCutsceneStatue_ToFanger
  dw EStatueGetCutsceneStatue_ToPyramid
  dw EStatueGetCutsceneStatue_ToBabel
warnpc $80ce7b
; Don't softlock if you already have the statue (using extra space freed up by the above fix)
EStatueGetCutsceneStatue_BecomeVisible:
lda $80ce98,x : and #$00ff : sta $28
stz $2a
txy   ; Statue lookup -> Y, S at -2
plx   ; ActorID -> X, S to base
phy   ; Statue lookup -> S, S to -2
jsl LR_AnimateSprite
lda #$2000 : trb $10
plx   ; Statue lookup -> X, S to base
tdc : pha   ; ActorID -> S, S to -2
jmp $cdbb   ; i.e. jmp EStatueGetCutsceneStatue_CheckIsThisStatue
warnpc $80ce93


; In EPlayer_Die, space optimizations to tick the death counter.
org $80d68b
phb
sed
  lda $0bea : clc : adc #$0001 : cmp #$0999 : bcc +
    lda #$0999
+:
  sta $0bea
cld
lda $0aca : sta $0ace    ; Always restore full HP (there's no reason to punish a 100-DP death)
lda $0ad6 : sec : sbc.w #100 : bcc +
  ; Died with 100 DP
  sta $0ad6
  ldy $0af4
  lda $0af6
  bra ++
+:    ; Died with less than 100 DP
stz $0ad6
stz $0ad4
lda $0644 : cmp #$00e8 : bne +
  lda #$0002 : sta $0ad4
+:
lda #$0000 : tay
-:
sta $0a80,y
iny : iny : cpy #$0020 : bne -
ldy $0af0
lda $0af2
++:   ; = EPlayer_Die_ParseRespawnData
sep #$20
pha : plb
lda $0000,y : sta $0642
lda $0005,y : and #$7F : sta $0650
rep #$20
lda $0001,y : sta $064C
lda $0003,y : sta $064E
lda $0006,y : sta $0652
plb
lda #$0404 : sta $064A
inc $0AF8
stz $0654
cop #$C1
rtl
warnpc $80d718


org $80d796
ERespawnMessage:
lda #$CFF0 : tsb $065A
stz $0AF8
cop #$DA : db $02
lda $0aca : beq .InfiniteDeathLoop    ; i.e. player has reduced max HP to 0 in RJM
.NormalDeath:
cop #$BF : dw ..Text
-:
lda #$CFF0 : trb $065A
cop #$E0
..Text:
db $d3,!PlayerDeathText
.InfiniteDeathLoop:
cop #$BF : dw ..Text
bra -
..Text:
db $cd : dl TextInfiniteDeathLoop
db $ca
warnpc $80d877


; Make monster death look up the correct gem tables.
org $80dadd
jsl LR_GetMonsterGemAtStatAddrY
org $80dc07
jsl LR_GetMonsterGemAtStatAddrY


org $80dbf2
if !SettingOrbRando > 0
nop : nop    ; Don't flag self killed yet, in case player's inventory is full.
endif


org $80DC23 
; To support orb rando, dead monster checks whether its item has been given,
; but doesn't set the item-given flag; EMonsterDeathDoorOrItem does that,
; since it can more easily verify inventory free space.
lda $7F0024,x : beq ++
jsl LR_SecOnMonsterItemFlagA : bcs ++
  cop #$A5 : dl EMonsterDeathDoorOrItem : db $00,$00 : dw $0342
  jsl LR_PrepareMonsterDeathDoorOrb
  bra +++
++:
cop #$D8
+++:
jmp $dc54


org $80ddf2
EMonsterDeathDoorOpener:


org $80e03c
; HP room reward, replacing the unnecessarily complex 
; lda $0ACA : clc : adc #$0001 : bvc $03 : lda #$0255 : sta $0aca
jsr SR_IncHpOnceByZ3Setting
nop : nop : nop : nop : nop : nop : nop : nop : nop
lda $0aca


; In pullable-object code, instead of cop #$21 : db $0f : dw Here+$01, additionally check telekinesis
org $80e263
jsr SR_SecIfShouldBePulledByPlayer : bcs $01
org $80E3D3
jsr SR_SecIfShouldBePulledByPlayer : bcs $01


; Set up Early Firebird and run other IOGR map-level code.
org $80eaed
db $00 : dw $2c00
ECameraEtc:
jsl LR_SetupIogrMap
cop #$C1
jsr SR_RunIogrMapCode
jsr SR_SecIfCameraFrozen : bcc +
  rtl
  nop
+:   ; this is $80eb00



org $80f48f
; bank $80 free space begins here
SR_RunIogrMapCode:
lda #$09c4 : jsl LR_SecOnAnyFlagA : bcc .PostDsWarpCheck
  cop #$CF : dw $09c4
  cop #$9C : dl EDarkSpaceWarper : dw $2300
  lda $0012,y : ora #$1000 : sta $0012,y   ; Make the warp ignore Earthquaker
  lda $0bf6 : sta $0026,y
.PostDsWarpCheck:
if !SettingInfiniteInventory == 1
.StoreSmallInvTank:
sep #$20
phx
ldx #$0000
ldy #$0000
..CheckSmallSlot:
lda.w SramInvSmallHoldingTank,y : bne ..FindNextLargeSlot
..NextSmallSlot:
  iny : cpy #$0010 : bcc ..CheckSmallSlot
    bra .DoneStoringSmallInvTank
..FindNextLargeSlot:
lda.l SramInvHoldingTank,x : beq ...GotSlot
  inx : cpx #$0100 : bcs .DoneStoringSmallInvTank   ; if the big tank is full, I guess we have to give up
  bra ..FindNextLargeSlot
...GotSlot:
lda.w SramInvSmallHoldingTank,y : sta.l SramInvHoldingTank,x
lda #$00 : sta.w SramInvSmallHoldingTank,y
bra ..NextSmallSlot
.DoneStoringSmallInvTank:
plx
rep #$20
endif
if !SettingDebug == 1
jsr SR_CameraUpdatesPositionHundreds
endif
rts


SR_SecIfCameraFrozen:
lda $06EE : bit #$0200 : beq +
  sec
  rts
+:
clc
rts


LR_MarkRoomRewardsObtainedByDifficulty:
{
lda $0b24 : beq +++
  dec : beq ++
  dec : beq +
cop #$CD : dw !RemovedRoomRewardExpertFlag1
cop #$CD : dw !RemovedRoomRewardExpertFlag2
cop #$CD : dw !RemovedRoomRewardExpertFlag3
cop #$CD : dw !RemovedRoomRewardExpertFlag4
cop #$CD : dw !RemovedRoomRewardExpertFlag5
cop #$CD : dw !RemovedRoomRewardExpertFlag6
+:
cop #$CD : dw !RemovedRoomRewardAdvancedFlag1
cop #$CD : dw !RemovedRoomRewardAdvancedFlag2
cop #$CD : dw !RemovedRoomRewardAdvancedFlag3
cop #$CD : dw !RemovedRoomRewardAdvancedFlag4
cop #$CD : dw !RemovedRoomRewardAdvancedFlag5
cop #$CD : dw !RemovedRoomRewardAdvancedFlag6
++:
cop #$CD : dw !RemovedRoomRewardIntermediateFlag1
cop #$CD : dw !RemovedRoomRewardIntermediateFlag2
cop #$CD : dw !RemovedRoomRewardIntermediateFlag3
cop #$CD : dw !RemovedRoomRewardIntermediateFlag4
cop #$CD : dw !RemovedRoomRewardIntermediateFlag5
cop #$CD : dw !RemovedRoomRewardIntermediateFlag6
+++:
rtl
}


; custom actor for RJ pickup spots
macro MTryGiveRedJewelItem(LocationDefName)
  db $a9   ; = lda #
#Config_<LocationDefName>:
  dw !{<LocationDefName>}
  jsl LR_GiveAnyItemA16OrSec
endmacro
db $00 : dw $3000
ERedJewelSpot:
{
lda #$0200 : tsb $12
cop #$C0 : dw .OnInteract
cop #$88 : dl $8ee000
cop #$8D : db $00
cop #$C1
rtl
.OnInteract:
lda $0e : clc : adc #$0080 : jsl LR_SecOnFlag20A : bcc .TryGiveItem
  rtl
.TryGiveItem:
pea.w .GaveItemSuccess-1
lda $0e : sta $0000
cop #$D9 : dw $0000, ..Choices
..Choices:
  dw .Spot00,.Spot01,.Spot02,.Spot03,.Spot04,.Spot05,.Spot06,.Spot07
  dw .Spot08,.Spot09,.Spot0A,.Spot0B,.Spot0C,.Spot0D,.Spot0E,.Spot0F
.Spot00:
%MTryGiveRedJewelItem("CapeLancesHouseItem")
bcs +
rts
.Spot01:
%MTryGiveRedJewelItem("CapeTowerItem")
bcs +
rts
.Spot02:
%MTryGiveRedJewelItem("EDEndBarrelsItem")
bcs +
rts
.Spot03:
%MTryGiveRedJewelItem("ItoryLogsItem")
bcs +
rts
.Spot04:
%MTryGiveRedJewelItem("DiamondCoastJarItem")
bcs +
rts
.Spot05:
%MTryGiveRedJewelItem("FrejHotelItem")
bcs +
rts
.Spot06:
%MTryGiveRedJewelItem("AnglDanceHallItem")
bcs +
rts
+:
bra .InvFull
.Spot07:
%MTryGiveRedJewelItem("AnglIshtarSidePotItem")
bcs .InvFull
rts
.Spot08:
%MTryGiveRedJewelItem("WtrmWestJarItem")
bcs .InvFull
rts
.Spot09:
%MTryGiveRedJewelItem("WtrmDesertJarItem")
bcs .InvFull
rts
.Spot0A:
%MTryGiveRedJewelItem("EuroAlleyItem")
bcs .InvFull
rts
.Spot0B:
%MTryGiveRedJewelItem("EuroSlaveRoomBarrelItem")
bcs .InvFull
rts
.Spot0C:
%MTryGiveRedJewelItem("NativesPotItem")
bcs .InvFull
rts
.Spot0D:
%MTryGiveRedJewelItem("DaoGrassItem")
bcs .InvFull
rts
.Spot0E:
%MTryGiveRedJewelItem("PyramidFoyerItem")
bcs .InvFull
rts
.Spot0F:
%MTryGiveRedJewelItem("BabelPillowItem")
bcs .InvFull
rts
.GaveItemSuccess:
lda $0e : clc : adc #$0080 : jsl LR_SetFlag20A
rtl
.InvFull:
pla   ; reverse earlier pea
rtl
}


; Room rewards are +3 HP normally, but +1 HP in Z3 mode.
SR_IncHpOnceByZ3Setting:
lda.l Config_SettingZ3 : bne +
  inc $0aca
  inc $0aca
+:
inc $0aca
rts


LR_PrepareMonsterDeathDoorOrb:
lda $0012,y : ora #$1000 : sta $0012,y
phx
  lda $7F0024,x
  tyx
  sta $7F0024,x
plx
phx
  lda $7f0022,x
  tyx
  sta $7f0022,x
plx
rtl


; Custom COP #$73 --> "Managed RNG"
Cop_73:
Brk_73:
{
phy
lda #$0000 ; efficiently zero high byte for output
sep #$20
lda $00E6 : inc : cmp #$10 : bcc +
  rep #$20
  jmp Cop_23_FromManaged
+:
sta $00E6
tay
lda $0410,y
plx
rti
}

ECometBG2ShimmerEndpointSetup:
lda #$7010
  sta.l CometHDMAResetTable-$01
  sta.l CometHDMAResetTable+$03
lda #$0100
  sta.l CometHDMAResetTable+$05
  sta.l CometHDMAResetTable+$08
  sta.l CometHDMAResetTable+$0C
lda $06C4
  sta.l CometHDMAResetTable+$01
  sta.l CometHDMAResetTable+$04
  sta.l CometHDMAResetTable+$07
  sta.l CometHDMAResetTable+$0A
rts
CometHDMAResetTable = $7E8C80

EStatueGetCutsceneStatue_ToShip:
stz $0ad4
cop #$26 : db $2e : dw $0250, $01a0 : db $03,$10,$23
cop #$C1
rtl
EStatueGetCutsceneStatue_ToSeaPalace:
stz $0ad4
cop #$26 : db !MapViperExitString    ; May as well skip loading and immediately unloading Viper's map.
cop #$C1
rtl
EStatueGetCutsceneStatue_ToRama:
stz $0ad4
cop #$26 : db $66 : dw $00f0, $0070 : db $03,$00,$22
cop #$C1
rtl
EStatueGetCutsceneStatue_ToFanger:
stz $0ad4
cop #$26 : db $8a : dw $0160, $02c0 : db $03,$00,$33
cop #$C1
rtl
EStatueGetCutsceneStatue_ToPyramid:
stz $0ad4
cop #$26 : db !MapMQExitString
cop #$C1
rtl
EStatueGetCutsceneStatue_ToBabel:
stz $0ad4
cop #$26 : db $de : dw $0170, $00b0 : db $03,$01,$12
cop #$C1
rtl

; The DMA thinker ($80b88b) can't be allowed to write cmath registers if the room is dark.
SR_DieIfCmathInDarkRoomElseClearBgScrollCounters:
jsl LR_SecIfThisMapIsDark : bcc .MapOkay
phx
  lda $7f0002,x : asl : tax
  lda $cc00,x : tax
  lda $0003,x : and #$003f : cmp #$0030 : beq .ThinkerDie
    cmp #$0031 : beq .ThinkerDie
    cmp #$0032 : beq .ThinkerDie
plx
bra .MapOkay
.ThinkerDie:
plx
cop #$3D
pla
rtl
.MapOkay:
jsr $b8c3   ; i.e. jsr SR_ClearBgScrollCounters
rts

db $00,$08
TIndexedPaletteBundleRepl:
jsl LR_SecIfThisMapIsDark : bcc .BundleOkay
lda $7f0002,x    ; Palette bundles that write color math aren't compatible with darkrooms
  cmp #$001b : beq .BundleNotOkay
  cmp #$001c : beq .BundleNotOkay
  cmp #$0028 : beq .BundleNotOkay
  cmp #$002f : beq .BundleNotOkay
  cmp #$0038 : beq .BundleNotOkay
  cmp #$0040 : beq .BundleNotOkay
  cmp #$0061 : beq .BundleNotOkay
  cmp #$0066 : beq .BundleNotOkay
  cmp #$0067 : beq .BundleNotOkay
  cmp #$0069 : beq .BundleNotOkay
  cmp #$006a : beq .BundleNotOkay
  cmp #$0070 : beq .BundleNotOkay
.BundleOkay:
cop #$C1
-:
cop #$36
cop #$39
bra -
.BundleNotOkay:
cop #$3D
rtl

TWavyBgWriterRepl:
-:
lda #$0008 : sta $7f0008,x
cop #$5F : dw $8800 : db $40
cop #$C2
cop #$D0 : db $ff,$00 : dw -
cop #$60 : db $01,$02
cop #$61 : dl $7e8800 : db $0d
rtl

SR_SetWillAbilitySpriteSetOnFlute80:
%MClzIfHasFlute() : bne .WithFlute
.NoFlute:
cop #$8E : db $07
rts
.WithFlute:
cop #$8E : db $04
rts

SR_SecIfShouldBePulledByPlayer:
cop #$21 : db $0f : dw .MaybePullable
.NotPullable:
clc
rts
.MaybePullable:
lda $0ad4 : bne .IsPullable
%MClzIfHasFlute() : bne .IsPullable
lda.l Config_SettingFluteOpt : cmp #$0001 : beq .NotPullable
.IsPullable:
sec
rts

SR_CameraUpdatesPositionHundreds:
stz $1ffc
lda $1014
-:
sec : sbc.w #100 : bmi +
inc $1ffc
bra -
+:
stz $1ffe
lda $1016
-:
sec : sbc.w #100 : bmi +
inc $1ffe
bra -
+:
lda #$1000
rts

IrqVector:
jml IrqHandler
IrqHandler:
sep #$20
pha
lda $804211
lda.l SramIrqCounter : inc : sta.l SramIrqCounter
pla
rti

SR_NmiSetDbrAndMasterFrameCounter:
{
pea.w $8130
plb
sep #$20
lda.w SramIrqCounter : inc : clc : adc.w SramFrameCounter : sta.w SramFrameCounter
stz.w SramIrqCounter
rep #$20
lda.w 1+SramFrameCounter : adc #$0000 : bcc +
  lda #$ffff
+:
sta.w 1+SramFrameCounter
plb
rts
}


warnpc $80FFB0
org $80ffc0
db "IOG Randomizer       "   ; "ILLUSION OF GAIA RANDO" is 1 letter too long

org $80ffee
dw IrqVector


} ; end bank $80



; Bank $81
{

org $818234
incsrc "iogr_81_exit_table.asr"
warnpc $81aade
org $81aade
Lut_RoomClearRewards:
Config_RoomClearRewards:
{
db !RoomClearReward00,!RoomClearReward01,!RoomClearReward02,!RoomClearReward03,!RoomClearReward04,!RoomClearReward05,!RoomClearReward06,!RoomClearReward07,!RoomClearReward08,!RoomClearReward09,!RoomClearReward0A,!RoomClearReward0B,!RoomClearReward0C,!RoomClearReward0D,!RoomClearReward0E,!RoomClearReward0F
db !RoomClearReward10,!RoomClearReward11,!RoomClearReward12,!RoomClearReward13,!RoomClearReward14,!RoomClearReward15,!RoomClearReward16,!RoomClearReward17,!RoomClearReward18,!RoomClearReward19,!RoomClearReward1A,!RoomClearReward1B,!RoomClearReward1C,!RoomClearReward1D,!RoomClearReward1E,!RoomClearReward1F
db !RoomClearReward20,!RoomClearReward21,!RoomClearReward22,!RoomClearReward23,!RoomClearReward24,!RoomClearReward25,!RoomClearReward26,!RoomClearReward27,!RoomClearReward28,!RoomClearReward29,!RoomClearReward2A,!RoomClearReward2B,!RoomClearReward2C,!RoomClearReward2D,!RoomClearReward2E,!RoomClearReward2F
db !RoomClearReward30,!RoomClearReward31,!RoomClearReward32,!RoomClearReward33,!RoomClearReward34,!RoomClearReward35,!RoomClearReward36,!RoomClearReward37,!RoomClearReward38,!RoomClearReward39,!RoomClearReward3A,!RoomClearReward3B,!RoomClearReward3C,!RoomClearReward3D,!RoomClearReward3E,!RoomClearReward3F
db !RoomClearReward40,!RoomClearReward41,!RoomClearReward42,!RoomClearReward43,!RoomClearReward44,!RoomClearReward45,!RoomClearReward46,!RoomClearReward47,!RoomClearReward48,!RoomClearReward49,!RoomClearReward4A,!RoomClearReward4B,!RoomClearReward4C,!RoomClearReward4D,!RoomClearReward4E,!RoomClearReward4F
db !RoomClearReward50,!RoomClearReward51,!RoomClearReward52,!RoomClearReward53,!RoomClearReward54,!RoomClearReward55,!RoomClearReward56,!RoomClearReward57,!RoomClearReward58,!RoomClearReward59,!RoomClearReward5A,!RoomClearReward5B,!RoomClearReward5C,!RoomClearReward5D,!RoomClearReward5E,!RoomClearReward5F
db !RoomClearReward60,!RoomClearReward61,!RoomClearReward62,!RoomClearReward63,!RoomClearReward64,!RoomClearReward65,!RoomClearReward66,!RoomClearReward67,!RoomClearReward68,!RoomClearReward69,!RoomClearReward6A,!RoomClearReward6B,!RoomClearReward6C,!RoomClearReward6D,!RoomClearReward6E,!RoomClearReward6F
db !RoomClearReward70,!RoomClearReward71,!RoomClearReward72,!RoomClearReward73,!RoomClearReward74,!RoomClearReward75,!RoomClearReward76,!RoomClearReward77,!RoomClearReward78,!RoomClearReward79,!RoomClearReward7A,!RoomClearReward7B,!RoomClearReward7C,!RoomClearReward7D,!RoomClearReward7E,!RoomClearReward7F
db !RoomClearReward80,!RoomClearReward81,!RoomClearReward82,!RoomClearReward83,!RoomClearReward84,!RoomClearReward85,!RoomClearReward86,!RoomClearReward87,!RoomClearReward88,!RoomClearReward89,!RoomClearReward8A,!RoomClearReward8B,!RoomClearReward8C,!RoomClearReward8D,!RoomClearReward8E,!RoomClearReward8F
db !RoomClearReward90,!RoomClearReward91,!RoomClearReward92,!RoomClearReward93,!RoomClearReward94,!RoomClearReward95,!RoomClearReward96,!RoomClearReward97,!RoomClearReward98,!RoomClearReward99,!RoomClearReward9A,!RoomClearReward9B,!RoomClearReward9C,!RoomClearReward9D,!RoomClearReward9E,!RoomClearReward9F
db !RoomClearRewardA0,!RoomClearRewardA1,!RoomClearRewardA2,!RoomClearRewardA3,!RoomClearRewardA4,!RoomClearRewardA5,!RoomClearRewardA6,!RoomClearRewardA7,!RoomClearRewardA8,!RoomClearRewardA9,!RoomClearRewardAA,!RoomClearRewardAB,!RoomClearRewardAC,!RoomClearRewardAD,!RoomClearRewardAE,!RoomClearRewardAF
db !RoomClearRewardB0,!RoomClearRewardB1,!RoomClearRewardB2,!RoomClearRewardB3,!RoomClearRewardB4,!RoomClearRewardB5,!RoomClearRewardB6,!RoomClearRewardB7,!RoomClearRewardB8,!RoomClearRewardB9,!RoomClearRewardBA,!RoomClearRewardBB,!RoomClearRewardBC,!RoomClearRewardBD,!RoomClearRewardBE,!RoomClearRewardBF
db !RoomClearRewardC0,!RoomClearRewardC1,!RoomClearRewardC2,!RoomClearRewardC3,!RoomClearRewardC4,!RoomClearRewardC5,!RoomClearRewardC6,!RoomClearRewardC7,!RoomClearRewardC8,!RoomClearRewardC9,!RoomClearRewardCA,!RoomClearRewardCB,!RoomClearRewardCC,!RoomClearRewardCD,!RoomClearRewardCE,!RoomClearRewardCF
db !RoomClearRewardD0,!RoomClearRewardD1,!RoomClearRewardD2,!RoomClearRewardD3,!RoomClearRewardD4,!RoomClearRewardD5,!RoomClearRewardD6,!RoomClearRewardD7,!RoomClearRewardD8,!RoomClearRewardD9,!RoomClearRewardDA,!RoomClearRewardDB,!RoomClearRewardDC,!RoomClearRewardDD,!RoomClearRewardDE,!RoomClearRewardDF
db !RoomClearRewardE0,!RoomClearRewardE1,!RoomClearRewardE2,!RoomClearRewardE3,!RoomClearRewardE4,!RoomClearRewardE5,!RoomClearRewardE6,!RoomClearRewardE7,!RoomClearRewardE8,!RoomClearRewardE9,!RoomClearRewardEA,!RoomClearRewardEB,!RoomClearRewardEC,!RoomClearRewardED,!RoomClearRewardEE,!RoomClearRewardEF
db !RoomClearRewardF0,!RoomClearRewardF1,!RoomClearRewardF2,!RoomClearRewardF3,!RoomClearRewardF4,!RoomClearRewardF5,!RoomClearRewardF6,!RoomClearRewardF7,!RoomClearRewardF8,!RoomClearRewardF9,!RoomClearRewardFA,!RoomClearRewardFB,!RoomClearRewardFC,!RoomClearRewardFD,!RoomClearRewardFE,!RoomClearRewardFF
}
warnpc $81abde

; Intermediate difficulty stat table lives here.
org $81abf0
{
if !SettingZ3 == 0
db $00,$00,$00,$00
db $02,$01,$00,$02
db $02,$01,$00,$01
db $04,$02,$00,$03
db $02,$01,$00,$01
db $02,$01,$00,$01
db $7F,$00,$00,$00
db $08,$01,$46,$00
db $03,$01,$33,$00
db $06,$01,$30,$00
db $03,$01,$00,$02
db $02,$02,$00,$01
db $03,$01,$00,$01
db $04,$02,$00,$02
db $03,$02,$00,$03
db $02,$02,$00,$01
db $06,$02,$00,$00
db $04,$03,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $04,$04,$00,$02
db $02,$04,$00,$01
db $02,$04,$00,$03
db $04,$04,$00,$01
db $04,$05,$00,$02
db $06,$04,$00,$01
db $08,$05,$00,$03
db $02,$01,$00,$00
db $02,$01,$00,$00
db $FF,$04,$00,$00
db $FF,$05,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$07,$7F,$00
db $10,$06,$00,$02
db $0C,$06,$00,$03
db $04,$06,$00,$01
db $03,$06,$00,$01
db $08,$08,$00,$02
db $02,$07,$00,$01
db $04,$08,$00,$03
db $28,$06,$7F,$00
db $28,$07,$7F,$00
db $32,$0A,$7F,$00
db $06,$07,$00,$01
db $10,$08,$00,$02
db $0C,$09,$00,$03
db $0C,$07,$00,$02
db $28,$09,$7F,$00
db $03,$08,$7F,$00
db $08,$04,$00,$03
db $08,$04,$00,$00
db $08,$04,$00,$01
db $06,$06,$00,$00
db $06,$08,$00,$02
db $08,$09,$00,$01
db $08,$08,$00,$01
db $06,$09,$00,$03
db $04,$04,$00,$02
db $02,$04,$00,$01
db $10,$0A,$00,$02
db $08,$0B,$00,$01
db $18,$0A,$00,$03
db $14,$0B,$00,$02
db $08,$0A,$FF,$00
db $08,$0A,$00,$03
db $04,$0A,$00,$00
db $06,$0A,$00,$02
db $03,$0A,$00,$01
db $02,$04,$00,$01
db $08,$0A,$00,$02
db $14,$0B,$00,$00
db $18,$0B,$00,$03
db $0A,$0A,$00,$02
db $28,$0F,$7F,$00
db $10,$09,$00,$02
db $03,$04,$00,$00
db $02,$04,$00,$01
if !ApocalypseGaia == 1
db $14,$08,$7F,$00
db $28,$08,$7F,$00
db $0A,$09,$7F,$00
db $01,$08,$7F,$00
db $14,$0A,$7F,$00
else
db $14,$10,$7F,$00
db $28,$0F,$7F,$00
db $0A,$10,$7F,$00
db $01,$0F,$7F,$00
db $14,$12,$7F,$00
endif
db $06,$06,$00,$02
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $10,$10,$00,$02
db $0A,$10,$00,$02
db $18,$10,$00,$02
db $04,$04,$00,$00
if !ApocalypseGaia == 1
db $01,$07,$7F,$00
db $0A,$09,$7F,$00
db $14,$08,$7F,$00
db $28,$07,$7F,$00
else
db $01,$0D,$7F,$00
db $0A,$10,$7F,$00
db $14,$0F,$7F,$00
db $28,$0D,$7F,$00
endif
db $28,$11,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
else
db $00,$00,$00,$00
db $06,$01,$00,$02
db $05,$01,$00,$01
db $0A,$01,$00,$03
db $03,$01,$00,$01
db $03,$01,$00,$01
db $7F,$00,$00,$00
db $08,$01,$00,$00
db $03,$01,$00,$00
db $06,$01,$00,$00
db $08,$01,$00,$02
db $06,$01,$00,$01
db $09,$01,$00,$01
db $0B,$01,$00,$02
db $08,$01,$00,$03
db $06,$01,$00,$01
db $0E,$01,$00,$00
db $0A,$01,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$02,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $0A,$02,$00,$02
db $05,$02,$00,$01
db $05,$02,$00,$03
db $0C,$02,$00,$01
db $0C,$02,$00,$02
db $10,$02,$00,$01
db $14,$02,$00,$03
db $05,$01,$00,$00
db $05,$01,$00,$00
db $FF,$02,$00,$00
db $FF,$02,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $1A,$03,$00,$02
db $16,$03,$00,$03
db $0C,$03,$00,$01
db $08,$03,$00,$01
db $14,$04,$00,$02
db $05,$04,$00,$01
db $0A,$04,$00,$03
db $28,$03,$7F,$00
db $28,$04,$7F,$00
db $32,$05,$7F,$00
db $0F,$04,$00,$01
db $19,$04,$00,$02
db $16,$04,$00,$03
db $16,$04,$00,$02
db $28,$05,$7F,$00
db $03,$04,$7F,$00
db $14,$02,$00,$03
db $14,$02,$00,$00
db $14,$02,$00,$01
db $10,$03,$00,$00
db $10,$04,$00,$02
db $12,$04,$00,$01
db $12,$04,$00,$01
db $0F,$05,$00,$03
db $0C,$02,$00,$02
db $06,$02,$00,$01
db $19,$05,$00,$02
db $14,$06,$00,$01
db $1E,$05,$00,$03
db $1C,$06,$00,$02
db $14,$05,$FF,$00
db $14,$05,$00,$03
db $0A,$05,$00,$00
db $0F,$05,$00,$02
db $08,$05,$00,$01
db $06,$02,$00,$01
db $0C,$05,$00,$02
db $1C,$06,$00,$00
db $1E,$06,$00,$03
db $14,$05,$00,$02
db $28,$08,$7F,$00
db $19,$05,$00,$02
db $08,$02,$00,$00
db $05,$02,$00,$01
db $14,$08,$7F,$00
db $28,$08,$7F,$00
db $0A,$09,$7F,$00
db $01,$08,$7F,$00
db $14,$0A,$7F,$00
db $10,$03,$00,$02
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $14,$08,$00,$02
db $10,$08,$00,$02
db $1E,$08,$00,$02
db $0A,$02,$00,$00
db $01,$07,$7F,$00
db $0A,$09,$7F,$00
db $14,$08,$7F,$00
db $28,$07,$7F,$00
db $28,$09,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
endif
}

org $81ADA8
Lut_Chests:
.Pointers:
{
dw .Nothing    ; Map $00
dw .Nothing    ; Map $01
dw .Nothing    ; Map $02
dw .Nothing    ; Map $03
dw .Nothing    ; Map $04
dw .Nothing    ; Map $05
dw .Nothing    ; Map $06
dw .Nothing    ; Map $07
dw .Nothing    ; Map $08
dw .Nothing    ; Map $09
dw .Nothing    ; Map $0A
dw .Nothing    ; Map $0B
dw .Nothing    ; Map $0C
dw .Nothing    ; Map $0D
dw .Map0E      ; Map $0E
dw .Nothing    ; Map $0F
dw .Map10      ; Map $10
dw .Nothing    ; Map $11
dw .Map12      ; Map $12
dw .Nothing    ; Map $13
dw .Nothing    ; Map $14
dw .Nothing    ; Map $15
dw .Nothing    ; Map $16
dw .Nothing    ; Map $17
dw .Nothing    ; Map $18
dw .Nothing    ; Map $19
dw .Nothing    ; Map $1A
dw .Nothing    ; Map $1B
dw .Nothing    ; Map $1C
dw .Map1D      ; Map $1D
dw .Nothing    ; Map $1E
dw .Nothing    ; Map $1F
dw .Nothing    ; Map $20
dw .Map21      ; Map $21
dw .Nothing    ; Map $22
dw .Nothing    ; Map $23
dw .Nothing    ; Map $24
dw .Nothing    ; Map $25
dw .Map26      ; Map $26
dw .Nothing    ; Map $27
dw .Nothing    ; Map $28
dw .Nothing    ; Map $29
dw .Nothing    ; Map $2A
dw .Nothing    ; Map $2B
dw .Nothing    ; Map $2C
dw .Nothing    ; Map $2D
dw .Map2E      ; Map $2E
dw .Nothing    ; Map $2F
dw .Nothing    ; Map $30
dw .Nothing    ; Map $31
dw .Nothing    ; Map $32
dw .Nothing    ; Map $33
dw .Nothing    ; Map $34
dw .Nothing    ; Map $35
dw .Nothing    ; Map $36
dw .Nothing    ; Map $37
dw .Nothing    ; Map $38
dw .Nothing    ; Map $39
dw .Nothing    ; Map $3A
dw .Nothing    ; Map $3B
dw .Nothing    ; Map $3C
dw .Nothing    ; Map $3D
dw .Nothing    ; Map $3E
dw .Map3F      ; Map $3F
dw .Nothing    ; Map $40
dw .Nothing    ; Map $41
dw .Nothing    ; Map $42
dw .Nothing    ; Map $43
dw .Nothing    ; Map $44
dw .Nothing    ; Map $45
dw .Nothing    ; Map $46
dw .Nothing    ; Map $47
dw .Nothing    ; Map $48
dw .Nothing    ; Map $49
dw .Nothing    ; Map $4A
dw .Nothing    ; Map $4B
dw .Nothing    ; Map $4C
dw .Map4D      ; Map $4D
dw .Nothing    ; Map $4E
dw .Nothing    ; Map $4F
dw .Map50      ; Map $50
dw .Map51      ; Map $51
dw .Map52      ; Map $52
dw .Map53      ; Map $53
dw .Nothing    ; Map $54
dw .Nothing    ; Map $55
dw .Nothing    ; Map $56
dw .Nothing    ; Map $57
dw .Nothing    ; Map $58
dw .Nothing    ; Map $59
dw .Map5A      ; Map $5A
dw .Map5B      ; Map $5B
dw .Map5C      ; Map $5C
dw .Nothing    ; Map $5D
dw .Nothing    ; Map $5E
dw .Map5F      ; Map $5F
dw .Map60      ; Map $60
dw .Map61      ; Map $61
dw .Nothing    ; Map $62
dw .Nothing    ; Map $63
dw .Nothing    ; Map $64
dw .Nothing    ; Map $65
dw .Nothing    ; Map $66
dw .Nothing    ; Map $67
dw .Nothing    ; Map $68
dw .Nothing    ; Map $69
dw .Nothing    ; Map $6A
dw .Nothing    ; Map $6B
dw .Nothing    ; Map $6C
dw .Nothing    ; Map $6D
dw .Nothing    ; Map $6E
dw .Nothing    ; Map $6F
dw .Map70      ; Map $70
dw .Nothing    ; Map $71
dw .Nothing    ; Map $72
dw .Nothing    ; Map $73
dw .Map74      ; Map $74
dw .Map75      ; Map $75
dw .Nothing    ; Map $76
dw .Nothing    ; Map $77
dw .Nothing    ; Map $78
dw .Nothing    ; Map $79
dw .Nothing    ; Map $7A
dw .Nothing    ; Map $7B
dw .Nothing    ; Map $7C
dw .Nothing    ; Map $7D
dw .Nothing    ; Map $7E
dw .Nothing    ; Map $7F
dw .Nothing    ; Map $80
dw .Nothing    ; Map $81
dw .Nothing    ; Map $82
dw .Map83      ; Map $83
dw .Nothing    ; Map $84
dw .Map85      ; Map $85
dw .Nothing    ; Map $86
dw .Nothing    ; Map $87
dw .Nothing    ; Map $88
dw .Nothing    ; Map $89
dw .Nothing    ; Map $8A
dw .Nothing    ; Map $8B
dw .Nothing    ; Map $8C
dw .Nothing    ; Map $8D
dw .Nothing    ; Map $8E
dw .Nothing    ; Map $8F
dw .Nothing    ; Map $90
dw .Nothing    ; Map $91
dw .Nothing    ; Map $92
dw .Nothing    ; Map $93
dw .Nothing    ; Map $94
dw .Nothing    ; Map $95
dw .Nothing    ; Map $96
dw .Nothing    ; Map $97
dw .Nothing    ; Map $98
dw .Nothing    ; Map $99
dw .Nothing    ; Map $9A
dw .Nothing    ; Map $9B
dw .Nothing    ; Map $9C
dw .Nothing    ; Map $9D
dw .Nothing    ; Map $9E
dw .Nothing    ; Map $9F
dw .Nothing    ; Map $A0
dw .Nothing    ; Map $A1
dw .MapA2      ; Map $A2
dw .Nothing    ; Map $A3
dw .MapA4      ; Map $A4
dw .Nothing    ; Map $A5
dw .MapA6      ; Map $A6
dw .MapA7      ; Map $A7
dw .Nothing    ; Map $A8
dw .MapA9      ; Map $A9
dw .Nothing    ; Map $AA
dw .Nothing    ; Map $AB
dw .Nothing    ; Map $AC
dw .Nothing    ; Map $AD
dw .Nothing    ; Map $AE
dw .Nothing    ; Map $AF
dw .Nothing    ; Map $B0
dw .MapB1      ; Map $B1
dw .Nothing    ; Map $B2
dw .Nothing    ; Map $B3
dw .Nothing    ; Map $B4
dw .MapB5      ; Map $B5
dw .Nothing    ; Map $B6
dw .Nothing    ; Map $B7
dw .Nothing    ; Map $B8
dw .MapB9      ; Map $B9
dw .Nothing    ; Map $BA
dw .MapBB      ; Map $BB
dw .Nothing    ; Map $BC
dw .Nothing    ; Map $BD
dw .MapBE      ; Map $BE
dw .Nothing    ; Map $BF
dw .Nothing    ; Map $C0
dw .Nothing    ; Map $C1
dw .Nothing    ; Map $C2
dw .Nothing    ; Map $C3
dw .Nothing    ; Map $C4
dw .Nothing    ; Map $C5
dw .Nothing    ; Map $C6
dw .Nothing    ; Map $C7
dw .Nothing    ; Map $C8
dw .Nothing    ; Map $C9
dw .Nothing    ; Map $CA
dw .Nothing    ; Map $CB
dw .Nothing    ; Map $CC
dw .Nothing    ; Map $CD
dw .Nothing    ; Map $CE
dw .Nothing    ; Map $CF
dw .Nothing    ; Map $D0
dw .MapD1      ; Map $D1
dw .Nothing    ; Map $D2
dw .Nothing    ; Map $D3
dw .MapD4      ; Map $D4
dw .Nothing    ; Map $D5
dw .MapD6      ; Map $D6
dw .Nothing    ; Map $D7
dw .Nothing    ; Map $D8
dw .MapD9      ; Map $D9
dw .Nothing    ; Map $DA
dw .Nothing    ; Map $DB
dw .Nothing    ; Map $DC
dw .Nothing    ; Map $DD
dw .Nothing    ; Map $DE
dw .Nothing    ; Map $DF
dw .Nothing    ; Map $E0
dw .Nothing    ; Map $E1
dw .Nothing    ; Map $E2
dw .Nothing    ; Map $E3
dw .Nothing    ; Map $E4
dw .Nothing    ; Map $E5
dw .Nothing    ; Map $E6
dw .Nothing    ; Map $E7
dw .Nothing    ; Map $E8
dw .MapE9      ; Map $E9
dw .Nothing    ; Map $EA
dw .Nothing    ; Map $EB
dw .Nothing    ; Map $EC
dw .Nothing    ; Map $ED
dw .Nothing    ; Map $EE
dw .Nothing    ; Map $EF
dw .Nothing    ; Map $F0
dw .Nothing    ; Map $F1
dw .Nothing    ; Map $F2
dw .Nothing    ; Map $F3
dw .Nothing    ; Map $F4
dw .Nothing    ; Map $F5
dw .Nothing    ; Map $F6
dw .Nothing    ; Map $F7
dw .Nothing    ; Map $F8
dw .Nothing    ; Map $F9
dw .Nothing    ; Map $FA
dw .Nothing    ; Map $FB
dw .Nothing    ; Map $FC
dw .Nothing    ; Map $FD
dw .Nothing    ; Map $FE
; No map $FF pointer.
}
;org $81AFA6
{
.Nothing:
db $ff
.Map0E:
db $04,$1A
#Config_EDSpikeChestItem:
dw !EDSpikeChestItem
db $01
db $ff
.Map10:
db $07,$08
#Config_EDSmallRoomChestItem:
dw !EDSmallRoomChestItem
db $02
db $ff
.Map12:
db $11,$1E
#Config_EDEndChestItem:
dw !EDEndChestItem
db $03
db $ff
.Map1D:
db $06,$06
#Config_IncaDiamondBlockChestItem:
dw !IncaDiamondBlockChestItem
db $04
db $ff
.Map21:
db $02,$17
#Config_IncaStatueChestItem:
dw !IncaStatueChestItem
db $05
db $ff
.Map26:
db $10,$1B
#Config_IncaMazeChestItem:
dw !IncaMazeChestItem
db $06
db $08,$1F
#Config_IncaWormChestItem:
dw !IncaWormChestItem
db $07
db $ff
.Map2E:
db $25,$19 : dw $0038 : db $08
db $ff
.Map3F:
db $38,$27
#Config_MineChestItem:
dw !MineChestItem
db $09
db $ff
.Map4D:
db $39,$31
#Config_SGNEStatueChestItem:
dw !SGNEStatueChestItem
db $0A
db $09,$33
#Config_SGNEWestChestItem:
dw !SGNEWestChestItem
db $0B
db $34,$05
#Config_SGNENorthChestItem:
dw !SGNENorthChestItem
db $0C
db $ff
.Map50:
db $37,$06
#Config_SGSEChestItem:
dw !SGSEChestItem
db $0D
db $ff
.Map51:
db $03,$2F
#Config_SGSWTopChestItem:
dw !SGSWTopChestItem
db $0E
db $ff
.Map52:
db $07,$08
#Config_SGSWBotChestItem:
dw !SGSWBotChestItem
db $0F
db $ff
.Map53:
db $35,$32
#Config_SGNWTopChestItem:
dw !SGNWTopChestItem
db $10
db $31,$36
#Config_SGNWBotChestItem:
dw !SGNWBotChestItem
db $11
db $ff
.Map5A:
db $37,$1A
#Config_SeaPalSideChestItem:
dw !SeaPalSideChestItem
db $12
db $ff
.Map5B:
db $07,$07
#Config_SeaPalTopChestItem:
dw !SeaPalTopChestItem
db $13
db $ff
.Map5C:
db $09,$17
#Config_SeaPalBotChestItem:
dw !SeaPalBotChestItem
db $14
db $ff
.Map5F:
db $20,$19
#Config_MuRamaChestNItem:
dw !MuRamaChestNItem
db $15
db $2F,$27
#Config_MuHopeRoomChestItem:
dw !MuHopeRoomChestItem
db $16
db $ff
.Map60:
db $1E,$18
#Config_MuEmptyChest1Item:
dw !MuEmptyChest1Item
db $2E
db $2D,$1C
#Config_MuRamaChestEItem:
dw !MuRamaChestEItem
db $17
db $ff
.Map61:
db $0A,$33
#Config_MuEmptyChest2Item:
dw !MuEmptyChest2Item
db $18
db $ff
.Map70:
db $07,$28
#Config_AnglSliderChestItem:
dw !AnglSliderChestItem
db $19
db $ff
.Map74:
db $27,$08
#Config_AnglIshtarWinChestItem:
dw !AnglIshtarWinChestItem
db $1A
db $ff
.Map75:
db $47,$08
#Config_AnglPuzzleChest1Item:
dw !AnglPuzzleChest1Item
db $1B
db $57,$08
#Config_AnglPuzzleChest2Item:
dw !AnglPuzzleChest2Item
db $1C
db $ff
}
warnpc $81B086

org $81c3c4    ; Due to new 2-byte chest IDs, some chests are moved to this freespace block.
{
Lut_Chests_Map83:
db $1A,$59
#Config_GtWlChest1Item:
dw !GtWlChest1Item
db $1D
db $ff
Lut_Chests_Map85:
db $05,$1A
#Config_GtWlChest2Item:
dw !GtWlChest2Item
db $1E
db $ff
Lut_Chests_MapA2:
db $18,$36
#Config_KressChest1Item:
dw !KressChest1Item
db $1F
db $ff
Lut_Chests_MapA4:
db $12,$0B
#Config_KressChest2Item:
dw !KressChest2Item
db $20
db $ff
Lut_Chests_MapA6:
db $05,$08
#Config_KressChest3Item:
dw !KressChest3Item
db $21
db $ff
Lut_Chests_MapA7:
db $22,$10
#Config_KressChest4Item:
dw !KressChest4Item
db $22
db $ff
Lut_Chests_MapA9:
db $0E,$05
#Config_KressChest5Item:
dw !KressChest5Item
db $23
db $ff
Lut_Chests_MapB1:
db $67,$05
#Config_WatChest1Item:
dw !WatChest1Item
db $24
db $ff
Lut_Chests_MapB5:
db $07,$4E
#Config_WatChest2Item:
dw !WatChest2Item
db $25
db $ff
Lut_Chests_MapB9:
db $07,$06
#Config_WatChest3Item:
dw !WatChest3Item
db $26
db $ff
Lut_Chests_MapBB:
db $11,$20
#Config_WatChest4Item:
dw !WatChest4Item
db $27
db $ff
Lut_Chests_MapBE:
db $05,$16
#Config_WatChest5Item:
dw !WatChest5Item
db $28
db $ff
Lut_Chests_MapD1:
db $37,$59
#Config_PyramidRoom2ChestItem:
dw !PyramidRoom2ChestItem
db $29
db $ff
Lut_Chests_MapD4:
db $46,$49
#Config_PyramidRoom5ChestItem:
dw !PyramidRoom5ChestItem
db $2A
db $ff
Lut_Chests_MapD6:
db $47,$09
#Config_PyramidRoom3ChestItem:
dw !PyramidRoom3ChestItem
db $2B
db $ff
Lut_Chests_MapD9:
db $75,$29
#Config_PyramidRoom4ChestItem:
dw !PyramidRoom4ChestItem
db $2C
db $ff
Lut_Chests_MapE9:
db $37,$16
#Config_MansionChestItem:
dw !MansionChestItem
db $2D
db $ff
}
warnpc $81c455


org $81CBA6
if !OptionMuteMusic == 1
Table_MusicAddresses:   ; Some callers (e.g. COP) use 1-indexed, some use 0.
{
dl $DF2A1D    ; City
dl $DF2A1D    ; City (dupe)
dl $DF2A1D    ; Village
dl $DF2A1D    ; "Ominous Whispers"
dl $DF2A1D    ; Castle
dl $DF2A1D    ; Dungeon
dl $DF2A1D    ; Inca
dl $DF2A1D    ; Sky Garden
dl $DF2A1D    ; Mu
dl $DF2A1D    ; Great Wall
dl $DF2A1D    ; Angkor Wat
dl $DF2A1D    ; Pyramid
dl $DF2A1D    ; City (dupe)
dl $DF2A1D    ; Space flight chorus
dl $DF2A1D    ; Boss music
dl $DF2A1D    ; Comet
dl $DF2A1D    ; Dream / Angkor Wat spirit cutscene
dl $DF2A1D    ; World map / Main menu
dl $DF2A1D    ; Credits, end ("Rebirth")
dl $DF2A1D    ; Credits, title theme remix
dl $DF2A1D    ; Raft / Lance+Lily cutscene
dl $DF2A1D    ; Dark Space
dl $DF2A1D    ; City (dupe)
dl $DD57FC    ; Item fanfare
dl $DE6C12    ; Lola's Melody
dl $DE6B33    ; Inca Melody
dl $DF2A1D    ; Silence
dl $DF2A1D    ; South Cape (i.e. City with pelicans)
dl $DF2BCB    ; Ishtar's waterfall
dl $DE2A6E    ; Memory Melody
}
endif
warnpc $81cc00

; Add Fluteless Will sprite source
org $81D971
Table_PlayerSpriteSources:
{
; Format: dl AnimList, dl CharData
dl $958000, $9A8000   ; Will
dl $8E8000, $9AC000   ; Freedan
dl $948000, $9BC000   ; Shadow
dl $958000, AVramWillFluteless    ; Fluteless Will
dl $8F8000, $9A8000   ; Will abilities
dl $8FC000, $9B8000   ; Transformations
dl $97A000, $9C8000   ; Freedan abilities
dl $8F8000, AVramWillFluteless   ; Fluteless Will abilities
dl $97C000, $9BC000   ; Shadow abilities
}

org $81da4c
table "table_invtext.txt",rtl
db "RANDO CODE: "
Config_RandoTitleScreenHashString:
db "!RandoTitleScreenHashString"
table "table_dialogue.txt",rtl


org $81dabf
table "table_invtext.txt",rtl
Text_ItemNamesCond:
.Pointers:
{
dw .Null             ;
dw .RedJewel         ;
dw .PrisonKey        ;
dw .IncaStatueA      ;
dw .IncaStatueB      ;
dw .IncaMelody       ; (unused)
dw .Herb             ;
dw .DiamondBlock     ;
dw .WindMelody       ;
dw .LolasMelody      ;
dw .Meat             ;
dw .MineKeyA         ;
dw .MineKeyB         ;
dw .MemoryMelody     ;
dw .CrystalBall      ;
dw .MineElevatorKey  ;
dw .MuPalaceKey      ; Item $10
dw .PurifyStone      ; 
dw .HopeStatue       ; 
dw .RamaStatue       ; 
dw .MagicDust        ; 
dw .BlueJournal      ; 
dw .LancesLetter     ; 
dw .Necklace         ; 
dw .RussianGlassWill ; 
dw .Teapot           ; 
dw .MushroomDrops    ; 
dw .BagOfGold        ; 
dw .BlackGlasses     ; 
dw .GorgonFlower     ; 
dw .Hieroglyph1E     ; 
dw .Hieroglyph1F     ; 
dw .Hieroglyph20     ; Item $20
dw .Hieroglyph21     ; 
dw .Hieroglyph22     ; 
dw .Hieroglyph23     ; 
dw .Aura             ; 
dw .LolasLetter      ; 
dw .FathersJournal   ; 
dw .CrystalRing      ; 
dw .Apple            ; 
dw .Blank29          ; 
dw .Blank2A          ; 
dw .Blank2B          ; 
dw .Blank2C          ; 
dw .Blank2D          ; 
dw .TwoRedJewels     ; 
dw .ThreeRedJewels   ; 
dw .Blank30          ; Item $30
dw .Blank31          ; 
dw .Blank32          ; 
dw .Blank33          ; 
dw .Blank34          ; 
dw .Blank35          ; 
dw .Blank36          ; 
dw .Blank37          ; 
dw .MysticStatue1    ; 
dw .MysticStatue2    ; 
dw .MysticStatue3    ; 
dw .MysticStatue4    ; 
dw .MysticStatue5    ; 
dw .MysticStatue6    ; 
dw .MysticStatue7    ; 
dw .MysticStatue8    ; Item $3f
}
{
.Null:
.Blank29:
.Blank2A:
.Blank2B:
.Blank2C:
.Blank2D:
.Blank30:
.Blank31:
.Blank32:
.Blank33:
.Blank34:
.Blank35:
.Blank36:
.Blank37:
db $00
.RedJewel:
db "Red Jewel",$00
.PrisonKey:
db "Prison Key",$00
.IncaStatueA:
db "Inca",$11
db "_Statue A",$00
.IncaStatueB:
db "Inca",$11
db "_Statue B",$00
.IncaMelody:
db "Inca Melody",$00
.Herb:
db "Herb",$00
.DiamondBlock:
db "Diamond",$11
db "_Block",$00
.WindMelody:
db "Wind",$11
db "_Melody",$00
.LolasMelody:
db "Lola's",$11
db "_Melody",$00
.Meat:
db "Meat",$00
.MineKeyA:
db "Mine Key A",$00
.MineKeyB:
db "Mine Key B",$00
.MemoryMelody:
db "Memory",$11
db "_Melody",$00
.CrystalBall:
db "Crystal",$11
db "_Ball",$00
.MineElevatorKey:
db "Elevator",$11
db "_Key",$00
.MuPalaceKey:
db "Mu Palace",$11
db "_Key",$00
.PurifyStone:
db "Purity",$11
db "_Stone",$00
.HopeStatue:
db "Statue",$11
db "_of Hope",$00
.RamaStatue:
db "Rama",$11
db "_Statue",$00
.MagicDust:
db "Magic",$11
db "_Dust",$00
.BlueJournal:
db "Blue",$11
db "_Journal",$00
.LancesLetter:
db "Lance's",$11
db "_Letter",$00
.Necklace:
db "Necklace",$00
.RussianGlassWill:
db "Will",$00
.Teapot:
db "Teapot",$00
.MushroomDrops:
db "Mushroom",$11
db "_Drops",$00
.BagOfGold:
db "Bag of Gold",$00
.BlackGlasses:
db "Black",$11
db "_Glasses",$00
.GorgonFlower:
db "Gorgon",$11
db "_Flower",$00
.Hieroglyph1E:
.Hieroglyph1F:
.Hieroglyph20:
.Hieroglyph21:
.Hieroglyph22:
.Hieroglyph23:
db "Hieroglyph",$00
.Aura:
db "Aura",$00
.LolasLetter:
db "Lola's",$11
db "_Letter",$00
.FathersJournal:
db "Father's",$11
db "_Journal",$00
.CrystalRing:
db "Crystal",$11
db "_Ring",$00
.Apple:
db "Red",$11
db "_Apple",$00
.TwoRedJewels:
db "Two Red",$11
db "_Jewels",$00
.ThreeRedJewels:
db "Three Red",$11
db "_Jewels",$00
.MysticStatue1:
.MysticStatue2:
.MysticStatue3:
.MysticStatue4:
.MysticStatue5:
.MysticStatue6:
.MysticStatue7:
.MysticStatue8:
db "Mystic",$11
db "_Statue",$00
}
warnpc $81de1e


org $81de1e
table "table_invtext.txt",rtl
Text_ItemNamesInv:
.Pointers:
{
dw .Null            
dw .RedJewel        
dw .PrisonKey       
dw .IncaStatueA     
dw .IncaStatueB     
dw .IncaMelody      
dw .Herb            
dw .DiamondBlock    
dw .WindMelody      
dw .LolasMelody     
dw .Meat            
dw .MineKeyA        
dw .MineKeyB        
dw .MemoryMelody    
dw .CrystalBall     
dw .MineElevatorKey 
dw .MuPalaceKey     
dw .PurifyStone     
dw .HopeStatue      
dw .RamaStatue      
dw .MagicDust     
dw .BlueJournal     
dw .LancesLetter    
dw .Necklace        
dw .RussianGlassWill
dw .Teapot          
dw .MushroomDrops   
dw .BagOfGold       
dw .BlackGlasses    
dw .GorgonFlower    
dw .Hieroglyph1E    
dw .Hieroglyph1F    
dw .Hieroglyph20    
dw .Hieroglyph21    
dw .Hieroglyph22    
dw .Hieroglyph23    
dw .Aura            
dw .LolasLetter     
dw .FathersJournal  
dw .CrystalRing     
dw .Apple           
dw .Blank29         
dw .Blank2A         
dw .Blank2B         
dw .Blank2C         
dw .Blank2D         
dw .TwoRedJewels
dw .ThreeRedJewels
dw .Blank30         
dw .Blank31         
dw .Blank32         
dw .Blank33         
dw .Blank34         
dw .Blank35         
dw .Blank36         
dw .Blank37         
dw .MysticStatue1   
dw .MysticStatue2   
dw .MysticStatue3   
dw .MysticStatue4   
dw .MysticStatue5   
dw .MysticStatue6   
dw .MysticStatue7   
dw .MysticStatue8   
}
{
.Null:
.IncaMelody:
.BagOfGold:
.Blank29:
.Blank2A:
.Blank2B:
.Blank2C:
.Blank2D:
.Blank30:
.Blank31:
.Blank32:
.Blank33:
.Blank34:
.Blank35:
.Blank36:
.Blank37:
db $00
.RedJewel:
db "Red Jewel"
if !SettingInfiniteInventory == 1
db $04 : dl TextInvYouHaveCountRedJewelsInclude : dw $0bfa
endif
db $00
.PrisonKey:
db "Prison Key",$00
.IncaStatueA:
db "Inca Statue A",$00
.IncaStatueB:
db "Inca Statue B",$00
.Herb:
db "Herb"
db $04 : dl TextInvYouHaveCountHerbsInclude : dw $0bfa
db $00
.DiamondBlock:
db "Diamond Block",$00
.WindMelody:
db "Wind Melody",$00
.LolasMelody:
db "Lola's Melody",$00
.Meat:
db "Meat",$00
.MineKeyA:
db "Mine Key A",$00
.MineKeyB:
db "Mine Key B",$00
.MemoryMelody:
db "Memory Melody",$00
.CrystalBall:
db "Crystal Ball"
if !SettingInfiniteInventory == 1
db $04 : dl TextInvYouHaveCountCrystalBallsInclude : dw $0bfa
endif
db $00
.MineElevatorKey:
db "Elevator Key",$00
.MuPalaceKey:
db "Mu Palace Key",$00
.PurifyStone:
db "Purification Stone",$00
.HopeStatue:
if !SettingInfiniteInventory == 1
db "Statue"
db $04 : dl TextInvYouHaveCountHopeStatuesInclude : dw $0bfa
db "of Hope ("
db $05 : db 1 : dw $0bec
db ")"
db $00
else
db "Statue of Hope",$00
endif
.RamaStatue:
db "Rama Statue"
if !SettingInfiniteInventory == 1
db $04 : dl TextInvYouHaveCountRamaStatuesInclude : dw $0bfa
endif
db $00
.MagicDust:
db "Magic Dust",$00
.BlueJournal:
db "Blue Journal",$00
.LancesLetter:
db "Lance's Letter",$00
.Necklace:
db "Necklace",$00
.RussianGlassWill:
db "Will",$00
.Teapot:
db "Teapot",$00
.MushroomDrops:
db "Mushroom Drops"
if !SettingInfiniteInventory == 1
db " ("
db $05 : db 1 : dw $0bf0
db ")"
endif
db $00
.BlackGlasses:
db "Black Glasses",$00
.GorgonFlower:
db "Gorgon Flower",$00
.Hieroglyph1E:
.Hieroglyph1F:
.Hieroglyph20:
.Hieroglyph21:
.Hieroglyph22:
.Hieroglyph23:
db "Hieroglyph",$00
.Aura:
db "Aura",$00
.LolasLetter:
db "Lola's Letter",$00
.FathersJournal:
db "Father's Journal",$00
.CrystalRing:
db "Crystal Ring",$00
.Apple:
db "Red Apple",$00
.TwoRedJewels:
db "Two Red Jewels",$00
.ThreeRedJewels:
db "Three Red Jewels",$00
.MysticStatue1:
.MysticStatue2:
.MysticStatue3:
.MysticStatue4:
.MysticStatue5:
.MysticStatue6:
.MysticStatue7:
.MysticStatue8:
db "Mystic Statue",$00
}
warnpc $81e12a


org $81e12a
Lut_ItemDroppableFlags:    ; or "not-droppable" perhaps I should have written
db %10011111 ;$9f
db %11111111 ;$ff
db %10011111 ;$9f
db %11111111 ;$ff
db %11111111 ;$ff
db %11000001 ;$01
db $00
db $00

warnpc $81e132
org $81e132
table "table_invtext.txt",rtl
Text_ItemDescriptions:
.Pointers:
{
dw .Null             
dw .RedJewel         
dw .PrisonKey        
dw .IncaStatueA      
dw .IncaStatueB      
dw .IncaMelody       
dw .Herb             
dw .DiamondBlock     
dw .WindMelody       
dw .LolasMelody      
dw .Meat             
dw .MineKeyA         
dw .MineKeyB         
dw .MemoryMelody     
dw .CrystalBall      
dw .MineElevatorKey  
dw .MuPalaceKey      
dw .PurifyStone      
dw .HopeStatue       
dw .RamaStatue       
dw .MagicDust      
dw .BlueJournal      
dw .LancesLetter     
dw .Necklace         
dw .RussianGlassWill 
dw .Teapot           
dw .MushroomDrops    
dw .BagOfGold        
dw .BlackGlasses     
dw .GorgonFlower     
dw .Hieroglyph1E     
dw .Hieroglyph1F     
dw .Hieroglyph20     
dw .Hieroglyph21     
dw .Hieroglyph22     
dw .Hieroglyph23     
dw .Aura             
dw .LolasLetter      
dw .FathersJournal   
dw .CrystalRing      
dw .Apple            
dw .Blank29   ; Artificial item IDs for upgrades
dw .Blank2A   ; Artificial item IDs for upgrades
dw .Blank2B   ; Artificial item IDs for upgrades
dw .Blank2C   ; Artificial item IDs for upgrades
dw .Blank2D   ; Artificial item IDs for upgrades
dw .TwoRedJewels     
dw .ThreeRedJewels   
}
{
.Null:
db "Zilch."
.BagOfGold:
.IncaMelody:
.Blank29:
.Blank2A:
.Blank2B:
.Blank2C:
.Blank2D:
db $00
.PrisonKey:
db $0D
db $02 : dl TextInvPrisonKey
db $00
.IncaStatueA:
db $0d
db """I throw the",$0d
db "ball to Naturally."""
db $00
.IncaStatueB:
db $0D
db """No, you throw",$0d
db "the ball to Who."""
db $00
.Herb:
db $0D
db "Tastes great!",$0d
db "Less filling!"
db $00
.DiamondBlock:
db $0D
db "Perfect for a",$0D
db "diamond-shaped",$0d
db "hole."
db $00
.WindMelody:
db $0D
db $02 : dl TextInvWindMelody
db $00
.LolasMelody:
db $0D
db "Brigadooooon"
db $00
.Meat:
db $0D
db "Delivered right",$0D
db "to your village",$0d
db "by Blue Tunic!"
db $00
.MineKeyA:
.MineKeyB:
db $0D
db "Use in the mine.",$0D
db "Duh."
db $00
.MemoryMelody:
db $0D
db "Don't let your life",$0d
db "pass you by."
db $00
.CrystalBall:
db $0D
db "Perfect for a",$0D
db "crystal-ball-shaped",$0d
db "hole."
db $00
.MineElevatorKey:
db $0D
db "Mined the gap."
db $00
.MuPalaceKey:
db $0D
db "Includes Bubble",$0d
db "Armor! But it's",$0d
db "too small for you."
db $00
.PurifyStone:
db $0D
db "Removes even the",$0d
db "toughest stains!",$0d
db "Oil! Grass! Blood!"
db $00
.HopeStatue:
db $0D
db "Grants any wish,",$0d
db "as long as the wish",$0d
db "is for drought."
db $00
.RamaStatue:
db $0D
db "Fuzzy Rama,",$0d
db "funny Rama,",$0d
db "Rama, Rama, Duck"
db $00
.MagicDust:
db $0D
db "The only magical",$0d
db "item. All others",$0d
db "are true science."
db $00
.BlueJournal:
db $0D
db "tl;dr"
db $00
.LancesLetter:
db $0D
db $02 : dl TextInvLancesLetter
db $00
.Necklace:
db $0D
db "Well, it's the",$0d
db "thought that",$0d
db "counts."
db $00
.RussianGlassWill:
db $0D
db "You cheated and won",$0d
db "a dying man's",$0d
db "fortune. Heroism!"
db $00
.Teapot:
db $0D
db $02 : dl TextInvTeapot
db $00
.MushroomDrops:
db $0D
db "Wait until Happy",$0d
db "Gardener's Monthly",$0d
db "hears about this!"
db $00
.BlackGlasses:
db $0D
db "Lookin' sharp!",$0d
db "Lookin' for love!"
db $00
.GorgonFlower:
db $0D
db "Smells like ozone."
db $00
.Hieroglyph1E:
.Hieroglyph1F:
.Hieroglyph20:
.Hieroglyph21:
.Hieroglyph22:
.Hieroglyph23:
db $0D
db "Perfect for a",$0D
db "hieroglyph-shaped",$0d
db "hole."
db $00
.Aura:
db $0D
db "What's Shadow's",$0d
db "favorite fruit?",$0d
db ".....Auranges"
db $00
.LolasLetter:
db $0D
db "-shdotdotdot dotdot",$0d
db "dotdashdot dashdot-",$0d
db "dot dotdotdash dot-"
db $00
.FathersJournal:
db $0D
db "This is, like,",$0d
db "90 percent self-",$0d
db "insert fanfiction."
db $00
.CrystalRing:
db $0D
db "If you like it...",$0D
db "you know the rest."
db $00
.Apple:
db $0D
db "Ironically not for",$0D
db "eating."
db $00
.ThreeRedJewels:
db $0d
db "Shiny!"
.TwoRedJewels:
db $0d
db "Shiny!"
.RedJewel:
db $0d
db "Shiny!"
db $00
}
warnpc $81e5ec

org $81e7f6    ; HUD structure.
Bg3_StatusBase:
if !SettingDebug == 1
db $01 : dw $0046
db $03 : db $14
db $02 : dl Bg3_DebugPositionTracker    ; Ref. x/y tracker.
else
db $01 : dw $0048 
db $03 : db $14
db $0c : db $01,02,$03,$04,$05 : db $ff 
endif
db $01 : dw $0084 
db $03 : db $08
db $0A 
db $03 : db $14
db $01 : dw $006c
db $0C : db $08,$09,$0A,$0B,$0C : db $FF   ; "ENEMY" moved here from below, to make HUDless maps work
db $01 : dw $009C 
db $05 : db $01 : dw $0AD8 
db $01 : dw $00A2 
db $0e : dw $0AD6 
db $00 

Bg3_StatusEnemyHp:
db $03 : db $04 
db $01 : dw $00a8
db $0B 
db $00 
warnpc $81e82b

; Updates to inv menus
org $81e905
if !SettingDsWarp == 1
db "Warp"
db $00
endif

org $81e919
if !SettingInfiniteInventory == 1
db $03 : db $00 
db $01 : dw $0596 
db $02 : dl TextInvItemMenuHoverFragment
db $03 : db $14 
db $04 : dl $81E94C : dw $0B26   ; Draws "B" or "Y" based on controller setting.
db $03 : db $00 
db " in-game to use",$0d
db "equipped item."
db $00 
endif
warnpc $81e94c

org $81ea39
if !SettingDsWarp == 1
db $03 : db $00 
db $01 : dw $0584 
db "Cond;",$0d
db "Warp"
db $00 
endif

org $81EA70
if !SettingDsWarp == 1
db $03 : db $00 
db $01 : dw $0596 
db "Your condition."
db $0d 
db "Press Attack to"
db $0d 
db "warp to Dark Space."
db $00 
endif
warnpc $81eab4

org $81ead1
Bg3_RadarForce:
db $01 : dw $01C6
db $04 : dl Bg3_IogrForceText : dw $0bfa
db $00
warnpc $81eadc

org $81ff6c
; Bank $81 freespace begins here.
Bg3_IogrForceText:
.Pointers:
{
dw .Force
dw .PlusHp
dw .PlusStr
dw .PlusDef
}
{
.Force:
db $03 : db $14
db $46,$4F,$52,$43,$45
db $00
.PlusHp:
db $03 : db $14
db $2d
if !SettingZ3 == 1
db $31
else
db $33
endif
db $48,$50
db $00
.PlusStr:
db $03 : db $14
db $2d,$31,$53,$54,$52
db $00
.PlusDef:
db $03 : db $14
db $2d,$31,$44,$45,$46
db $00
}

Bg3_DebugPositionTracker:
db $0e : dw $1ffc
db $0e : dw $1014
db $03 : db $20
db $0e : dw $1ffe
db $0e : dw $1016
db $00

} ; end bank $81



; Bank $82
{

org $8281a6
lda #$31 : sta $804200   ; When disabling NMI, enable IRQs, so we can count frames


; Reduce cost of multiplication and division.
org $8281D1
LR_MultiplyBytesOfA:
{
sta $804202
xba
sta $804203
nop : nop : nop ; : nop ; reduce unneeded filler cycles
lda $804217
xba
lda $804216
rtl
nop ; filler
}
LR_DivideYByA:
{
sty $4204
sta $4206
pha : pla ;nop : nop : nop : nop ; reduce unneeded filler cycles
pha : pla ;nop : nop : nop : nop ; reduce unneeded filler cycles
lda $4216
xba
lda $4214
rtl
nop : nop : nop : nop ; filler
}
warnpc $8281FE

org $82a02f
; Default MMIO values; we set the frame-counting IRQ near the middle of line 224.
dw $4207 : db 180
dw $4208 : db 0
dw $4209 : db 224
dw $420a : db 0

; Removes 5 pointless nops.
org $82a5e8
plp : rtl


org $82a5f9
; Part of LR_UpdateTilemapOpenChests, updated for 2-byte item IDs.
skip 3   ; lda $0000,x
skip 3   ; bit #$0080
skip 2   ; bne B_82A65B
phx
lda $0004,x : and #$007f : jsl LR_SecOnFlag20A : bcc UpdateTilemapChestsCheckNext
org $82a652
UpdateTilemapChestsCheckNext:
rep #$21
pla : adc #$0005 : tax

org $82a65d
SR_CheckChestCollide:
org $82a6e4
{
.GetChestListForRoom:
ldy $0646
ldx.w Lut_Chests,y
.CheckNextChest:
lda $0000,x : bmi .NoMatchedChest
cmp $18 : bne ..NotMatchedX
lda $0001,x : cmp $1C : beq .GotMatchedChest
..NotMatchedX:
inx : inx : inx : inx : inx
bra .CheckNextChest
.NoMatchedChest:
rep #$20
ldy #$FF48
jsl LR_ParseDialogueScriptAtY
rts
.GotMatchedChest:
rep #$20
phx
lda #$0080 : tsb $09EC
lda #$00FC : sta $06
jsr $A8B2    ; Set chest tiles to "open"
lda $01,s : tax
lda $0002,x : beq .ChestEmpty
sep #$20
lda #$2A : sta $06F9
rep #$20
lda #$0001 : sta $0bfc    ; Slow item get text speed.
lda $0002,x : jsl LR_GiveAnyItemA16OrSec : bcc .GaveItemSuccess
.CannotGiveItem:
lda $01,s : tax
lda #$00F8 : sta $06
jsr $A8B2
bra .ReturnControl
.ChestEmpty:
ldy #$FF36
jsl LR_ParseDialogueScriptAtY
lda $01,s : tax
lda $0004,x : and #$007F : jsl LR_SetFlag20A
bra .ReturnControl
.GaveItemSuccess:
lda $01,s
phx
tax
lda #$0080 : trb $09EC
plx
.SetItemFlagAndReturn:
lda $01,s : tax
lda $0004,x : and #$007F : jsl LR_SetFlag20A
plx
rts
.ReturnControl:
lda #$0080 : trb $09EC
plx
rts
}
warnpc $82a7b8

if !SettingDebug == 1
org $82b065
ldx #$0180    ; Push 1 more row...
org $82b078
ldx #$7820    ; ...to 1 row higher...
org $82b07e
ldx #$0240    ; ...sourced 1 row higher.
endif

org $82b7b3
EPlayerChargeListenerSpawner:
jsr SR_SecIfCombatEnabledOrSnakeGame : bcs EPlayerChargeListener
  cop #$E0
  nop : nop : nop   ; dunno whether this padding is needed anymore
EPlayerChargeListener:
{
lda #$0001 : trb $09AE
cop #$C1
lda $09AE : bit #$2A00 : beq +
  rtl
+:
lda $0AD4 : cmp #$0002 : bcc +
  rtl
+:
cop #$40 : dw $8001, .OkayCharge
  rtl
.OkayCharge:
lda #$0001 : tsb $09AE
lda #$8000 : tsb $0658
lda $0AD4 : beq .WillCharge
  jmp .FreedanCharge
.WillCharge:
{
lda $0AA2 : bit #$0005 : bne +
  rtl
+:
cop #$CA : db $28
  cop #$41 : dw $8001, EPlayerChargeListener    ; Check button held.
cop #$CB
jsr .SR_SetPosAtPlayer
cop #$A5 : dl $82c308 : dw $0000, $2C00    ; i.e. EWillChargePalette
sty $22
lda #$0078 : sta $24
cop #$C1
jsr .SR_QuitChargeIfForbidden
cop #$41 : dw $8001, .QuitCharge
dec $24 : bmi ..Ready
  rtl
..Ready:
lda $0AA2 : bit #$0004 : bne ..CanSpinDash
cop #$C1
jsr .SR_QuitChargeIfForbidden
cop #$41 : dw $8001, ..TryPsychoDash
rtl
..CanSpinDash:
cop #$C1
jsr .SR_QuitChargeIfForbidden
cop #$41 : dw $8001, ..TryPsychoDash
jsr .SR_ClcIfStationary : bcc +
  rtl
+:
cop #$40 : dw $0030, ..TrySpinDash
rtl
..TryPsychoDash:
jsr .SR_QuitPsychoDashIfForbidden
lda.w #EPlayer_DoPsychoDash : jsr .SR_SetPlayerPointerToA   ; i.e. lda #$bea0
jmp .QuitCharge
..TrySpinDash:
jsr .SR_QuitAbilityIfForbidden
lda.w #EPlayer_DoSpinDash : jsr .SR_SetPlayerPointerToA   ; i.e. lda #$c0a9 : jsr $b926
jmp .QuitCharge
} ; EPlayerChargeListener_WillCharge

.FreedanCharge:
{
lda $0AA2 : bit #$0030 : bne +
  rtl
+:
cop #$CA : db $28
  cop #$41 : dw $8001, EPlayerChargeListener
cop #$CB
jsr .SR_SetPosAtPlayer
cop #$A5 : dl $82c315 : dw $0000, $2C00    ; i.e. EFreedanChargePalette
sty $22
lda #$0064 : sta $24
cop #$C1
jsr .SR_QuitChargeIfForbidden    ; $b946
cop #$41 : dw $8001, .QuitCharge
cop #$40 : dw $40B0, .QuitCharge
dec $24 : bmi ..Ready
  rtl
..Ready:
lda $0AA2 : bit #$0020 : bne ..CanAuraBarrier
cop #$C1
jsr .SR_QuitChargeIfForbidden
cop #$41 : dw $8001, ..TryFriar
rtl
..CanAuraBarrier:
cop #$C1
jsr .SR_QuitChargeIfForbidden
cop #$41 : dw $8001, ..TryFriar
cop #$40 : dw $0F00, ...NotStationary
cop #$40 : dw $0030, ..TryAuraBarrier
...NotStationary:
rtl
..TryFriar:
lda #$0001 : sta $00EA
jsr .SR_QuitFriarIfForbidden
lda.w #EPlayer_DoFriar : jsr .SR_SetPlayerPointerToA    ; i.e. lda #$bb3b
bra .QuitCharge
..TryAuraBarrier:
lda $09B2 : ora $09B4 : beq ...OkayNotRunning
  rtl
...OkayNotRunning:
lda #$0002 : sta $00EA
jsr .SR_QuitAbilityIfForbidden
lda.w #EPlayer_DoAuraBarrier : jsr .SR_SetPlayerPointerToA   ; i.e. lda #$b97f
bra .QuitCharge
}

.QuitCharge:
{
phx
phd
lda $22 : beq ..KilledPalette
  tcd : tax
  cop #$A7    ; "Die" while impersonating palette setter.
..KilledPalette:
pld
plx
lda $0AD4 : bne ..RestorePaletteFreedan
..RestorePaletteWill:
cop #$37 : db $0B
cop #$39
cop #$C4 : dl EPlayerChargeListener
..RestorePaletteFreedan:
cop #$37 : db $0C
cop #$39
cop #$C4 : dl EPlayerChargeListener
}

.SR_SetPlayerPointerToA:
ldy $09AA : sta $0000,y
lda #$0000 : sta $0008,y
rts

.SR_QuitAbilityIfForbidden:
lda $09AE : bit #$3A00 : bne .SR_QuitCharge
cop #$48 : cmp #$0004 : bcs .SR_QuitCharge
rts

.SR_QuitCharge:
pla : bra EPlayerChargeListener_QuitCharge

.SR_QuitChargeIfForbidden:
lda $09AE : bit #$2B00 : bne .SR_QuitCharge
rts

.SR_SetPosAtPlayer:
ldy $09AA
lda $0014,y : sta $14
lda $0016,y : sta $16
rts

.SR_ClcIfStationary:
lda $09AE : bit #$8000 : beq ..NoActiveSpecialAnimation
..SecAndReturn:
  sec
  rts
..NoActiveSpecialAnimation:
ldy $09AA
lda $0028,y : bmi ..SecAndReturn
  cmp #$0004 : bcc ..ClcAndReturn
  sec : sbc #$0010 : cmp #$0004 : bcs ..SecAndReturn
..ClcAndReturn:
clc
rts
warnpc $82b97f
}

org $82bec4
jsr SR_SetWillAbilitySpriteSetOnFlute   ; Instead of cop #$8E : db $04, here and below.
org $82bed7
jsr SR_SetWillAbilitySpriteSetOnFlute
org $82beea
jsr SR_SetWillAbilitySpriteSetOnFlute
org $82befa
jsr SR_SetWillAbilitySpriteSetOnFlute
org $82c0be
jsr SR_SetWillAbilitySpriteSetOnFlute


org $82c4dd
EPlayer_ActPressDown:
nop
lda #$0000 : jsr SR_SecIfCanStartRunningInDirectionA : bcc $13
;...
org $82c514
jsr SR_RunningConsiderReturnToActRepl


org $82C524
EPlayer_ActPressUp:
nop : nop
lda #$0001 : jsr SR_SecIfCanStartRunningInDirectionA : bcc $13
;...
org $82c55c
jsr SR_RunningConsiderReturnToActRepl


org $82C56C
EPlayer_ActPressLeft:
nop : nop : nop
lda #$0002 : jsr SR_SecIfCanStartRunningInDirectionA : bcc $13
;...
org $82c5a5
jsr SR_RunningConsiderReturnToActRepl


org $82C5B5
EPlayer_ActPressRight:
nop : nop : nop : nop
lda #$0003 : jsr SR_SecIfCanStartRunningInDirectionA : bcc $13
;...
org $82c5ef
jsr SR_RunningConsiderReturnToActRepl


org $82cc05
jsr SR_SetWillAbilitySpriteSetOnFlute
org $82cc58
jsr SR_SetWillAbilitySpriteSetOnFlute


org $82ca63
jsr SR_MaybeAllowBlock    ; Instead of lda #$0100 in EPlayer_ShieldCommon.


; Early Firebird checks.
; Replaces "lda $0644 : cmp #$00e8 : bne .PostFirebird"
org $82cd07
nop : nop : nop : jsr SR_SecIfFirebirdAllowed : bcc $09
org $82cd88
nop : nop : nop : jsr SR_SecIfFirebirdAllowed : bcc $09
org $82ce06
nop : nop : nop : jsr SR_SecIfFirebirdAllowed : bcc $09
org $82ce84
nop : nop : nop : jsr SR_SecIfFirebirdAllowed : bcc $09


org $82ceee
SR_PlayerAttackFreezeAndSound:
lda $0656 : and #$0F00 : sta $0656
  ora #$8000 : sta $0658
lda $0AD4 : beq .AsWill
lda #$0100 : trb $10
cop #$06 : db $02
rts
.AsWill:
jmp SR_PlayerAttackFreezeAndSound_SetupWill
warnpc $82cf0f


org $82cf58
if !SettingZ3 == 1
lda $0ade    ; Instead of lda #$0001, doubles jump-slash damage
endif


org $82e402
if !SettingInfiniteInventory == 1
cop #$C2
jsr SR_InvInitOverflow
endif

org $82e487
; Add setup when an item is pointed at to draw its counter correctly.
jsr SR_InvSetupPointedItem
nop : nop : nop : nop : nop : nop : nop : nop

org $82e50b
; When the pick-item submenu is left, restore the page counter.
jsr SR_InvCleanupPointedItem
nop : nop : nop

org $82e64e
jsr SR_FixInvHandAfterOrdering
nop : nop : nop

org $82e6bd
jsr SR_ClcIfItemAIsDroppable   ; replacing a call to this routine with a call to my customized version

org $82e6da
; Replacing the straightforward ldy $22 : lda $0ab4,y : and #$ff00 : sta $0ab4,y .
ldy $22
jsr SR_InvClearItemInViewSlotY
nop : nop : nop : nop : nop : nop

org $82e719
EInvScreenManager_CondMenu:
if !SettingDsWarp == 1
jsr SR_SecIfCanDsWarpFromMenu : bcs +
  cop #$06 : db $12
  jmp $e40c   ; Return to main menu loop
+:
stz $0AE6
cop #$BD : dl $81E90B   ; Clear the upper-right box
cop #$BD : dl $81EA39   ; "Dark Power" in the upper-right box
sty $20
stz $22
-:
cop #$BD : dl $81E912   ; Clear the lower-right box
cop #$BD : dl TextInvOfferDsWarp   ; Ask whether to warp to DS
stz $28
cop #$C2
jsr $EBC6 : bcs +       ; Routine handles flickering the arrow, and "No"/"Yes" selection
  rtl
+:
lda $28 : beq .DeclineWarp
.AcceptWarp:
cop #$06 : db $11
cop #$CD : dw $09c4
cop #$CC : db $00   ; Queue exit from inv screen
jmp $e40c
.DeclineWarp:
cop #$CF : dw $09c4
jmp $e40c
warnpc $82e7a3
endif

org $82e816
EInvScreenManager_HoverCondLine:
if !SettingDsWarp == 1
jsr $EB45
jsr $EB0B
cop #$BD : dl $81E912   ; Clear the lower-right box
cop #$BD : dl $81E870   ; Draw the upper-left box
jsr SR_DrawInvScreenTextForDsWarpState
nop : nop
; The rest of this code goes as usual.
endif


if !SettingInfiniteInventory == 1
; Called after an item is moved or removed
org $82e9ed
SR_RefreshItemSlotIndexA:
jsr SR_UpdateInvFromViewSlotA    ; Replacing sta $000e
endif

if !SettingInfiniteInventory == 1
; Part of the inv screen input handler.
org $82ec6a
cop #$40 : dw $6000, $ecbe    ; X button no longer exits the inv screen
cop #$40 : dw $0040, EInvScreenManager_MaybeChangeInvPage    ; New
lda $1c
  inc $1c
  bit #$000f : bne +
    jsr SR_InvToggleMainCursorState   ; For space reasons, moved into a separate routine
+:
clc
rts
warnpc $82ec8a
endif

if !SettingInfiniteInventory == 1
; In LR_OpenInventoryScreen, a few bytes are optimized out to give holding tank items.
org $82ed44
stz $2123
stz $2125
stz $2128
stz $212a
jsl LR_GiveQueuedItems
sep #$20
lda $0a1f : and #$7f : sta $0a1f
bra $06
endif

org $82ee61
; Fix a base-game bug where the inv screen clobbers $09ec.
sep #$20
jsl $8283e7   ; This loads map assets, which alters $09ec; thus restoring $09ec needs to come after it.
plx : stx $09ec
plx : stx $06e4

org $82eeae
cop #$BD : dl Bg3_StatusEnemyHp    ; Needed because Bg3_StatusEnemyHp moved.


org $82f08c
; Beginning of bank $82 free space.

if !SettingInfiniteInventory == 1
SR_UpdateInvFromViewSlotA:
pha
tay
jsl LR_UpdateInvFromViewSlotY
pla : sta $000e
rts

EInvScreenManager_MaybeChangeInvPage:
lda #$0040 : tsb $0658    ; Mark button as recently pressed, so it's not detected for a few frames
lda $0afa : cmp #$0003 : bne +    ; Only when the inventory is in view
  clc
  rts
+:
jsr SR_CycleInventoryPage
cop #$BD : dl $81E919   ; Re-draw the text
cop #$06 : db $0D
clc
rts

SR_CycleInventoryPage:
lda $7f0010,x : tay   ; This is slot 0; need to advance Y to slot 4
lda $0006,y : tay
lda $0006,y : tay
lda $0006,y : tay
lda $0006,y : tay
lda.l SramInvActivePageId : inc : cmp #$0003 : bcc +
  lda #$0000
+:
sta.l SramInvActivePageId
asl : asl : pha
  asl : clc : adc $01,s : sta $01,s
pla : tax
; Now X = 12*ActivePageNumber, Y = ActorID of slot 4; refresh and update the 12 slots
lda.w #12 : sta $000e
-:
dec $000e : bmi .Done
lda #$e8cd : sta $0000,y
lda #$0000 : sta $0008,y
  sta $002a,y
sep #$20
  lda.l SramInvPages,x : sta $0028,y
rep #$20
lda $0006,y : tay
inx
bra -
.Done:
tdc : tax
jsl LR_UpdateItemViewFull
lda $0ac4 : cmp #$0004 : bcc +
  ; Unequip the equipped item if it was on slots 4-15
  lda #$ffff : sta $0ac4
    sta $1a
  stz $0ac6
  jsr $ea73   ; Remove the item picker hand
+:
cop #$A5 : dl EInvPagePaletteWriter : db 0,0 : dw $2800
lda.l SramInvActivePageId : sta $0026,y
  inc : sta $0bfa
rts

SR_InvInitOverflow:
cop #$A5 : dl EInvPagePaletteWriter : db 0,0 : dw $2800
lda.l SramInvActivePageId : sta $0026,y
  inc : sta $0bfa
lda #$0000 : sta $0024,y
stz $0afa
rts
endif

SR_InvClearItemInViewSlotY:
-:
lda $0ab4,y : and #$00ff : jsl LR_DecStackForItemAReturningCountOrSec : bne -
lda $0ab4,y : and #$ff00 : sta $0ab4,y
if !SettingInfiniteInventory == 1
jsl LR_UpdateInvFromViewSlotY
endif
rts

SR_FixInvHandAfterOrdering:
lda $0ac4 : bmi +    ; If nothing was selected, there's no bug
  sta $1a
  tay
  lda $0ab4,y : and #$00ff : cmp $0ac6 : beq ++
    ; If the item in our equipped slot changed, unequip whatever it is.
    lda #$ffff : sta $0ac4
      sta $1a
    stz $0ac6
++:
jsr $ea73
+:
lda #$4040 : tsb $0658
rts

SR_InvToggleMainCursorState:
lda $1c : bit #$0010 : bne +
  jsr $ecce
  rts
+:
jsr $ece8
rts

SR_DrawInvScreenTextForDsWarpState:
cop #$D1 : dw $09c4 : db $01 : dw .YesWarp
.NoWarp:
cop #$BD : dl $81EA70    ; Say you can warp
rts
.YesWarp:
cop #$BD : dl TextInvCondMenuYouWillWarp
rts


SR_SecIfFirebirdAllowed:
{
lda $0644 : cmp #$00e8 : beq .OkayFirebird
lda.l Config_SettingEarlyFirebird : beq .NoFirebird
lda $0ad4 : cmp #$0002 : bne .NoFirebird
cop #$D0 : db $3e,$00 : dw .NoFirebird
cop #$D0 : db $8a,$00 : dw .NoFirebird
.OkayFirebird:
lda $213f : adc $2137 : adc $213c : adc $0036
  and #$000f : sec : sbc #$0004 : sta $09e2   ; Firebird damage randomizer.
sec
rts
.NoFirebird:
clc
rts
}


if !SettingZ3 == 0
{
Lut_VitalsDifficulty0:
db $00,$00,$00,$00
db $04,$01,$00,$02
db $03,$01,$00,$01
db $07,$01,$00,$03
db $02,$01,$00,$01
db $02,$01,$00,$01
db $55,$00,$00,$00
db $05,$01,$00,$00
db $02,$01,$00,$00
db $04,$01,$00,$00
db $05,$01,$00,$02
db $04,$01,$00,$01
db $06,$01,$00,$01
db $07,$01,$00,$02
db $05,$01,$00,$03
db $04,$01,$00,$01
db $09,$01,$00,$00
db $07,$01,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$02,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $07,$02,$00,$02
db $03,$02,$00,$01
db $03,$02,$00,$03
db $08,$02,$00,$01
db $08,$02,$00,$02
db $0B,$02,$00,$01
db $0D,$02,$00,$03
db $03,$01,$00,$00
db $03,$01,$00,$00
db $AA,$02,$00,$00
db $AA,$02,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $11,$03,$00,$02
db $0F,$03,$00,$03
db $08,$03,$00,$01
db $05,$03,$00,$01
db $0D,$04,$00,$02
db $03,$04,$00,$01
db $07,$04,$00,$03
db $28,$03,$7F,$00
db $28,$04,$7F,$00
db $21,$05,$7F,$00
db $0A,$04,$00,$01
db $11,$04,$00,$02
db $0F,$04,$00,$03
db $0F,$04,$00,$02
db $28,$05,$7F,$00
db $02,$04,$7F,$00
db $0D,$02,$00,$03
db $0D,$02,$00,$00
db $0D,$02,$00,$01
db $0B,$03,$00,$00
db $0B,$04,$00,$02
db $0C,$04,$00,$01
db $0C,$04,$00,$01
db $0A,$05,$00,$03
db $08,$02,$00,$02
db $04,$02,$00,$01
db $11,$05,$00,$02
db $0D,$06,$00,$01
db $14,$05,$00,$03
db $13,$06,$00,$02
db $0D,$05,$FF,$00
db $0D,$05,$00,$03
db $07,$05,$00,$00
db $0A,$05,$00,$02
db $05,$05,$00,$01
db $04,$02,$00,$01
db $08,$05,$00,$02
db $13,$06,$00,$00
db $14,$06,$00,$03
db $0D,$05,$00,$02
db $28,$08,$7F,$00
db $11,$05,$00,$02
db $05,$02,$00,$00
db $03,$02,$00,$01
db $0D,$08,$7F,$00
db $28,$08,$7F,$00
db $07,$09,$7F,$00
db $01,$08,$7F,$00
db $0D,$0A,$7F,$00
db $0B,$03,$00,$02
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $0D,$08,$00,$02
db $0B,$08,$00,$02
db $14,$08,$00,$02
db $07,$02,$00,$00
db $01,$07,$7F,$00
db $07,$09,$7F,$00
db $0D,$08,$7F,$00
db $28,$07,$7F,$00
db $28,$09,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
Lut_VitalsDifficulty1:
db $00,$00,$00,$00
db $06,$01,$00,$02
db $05,$01,$00,$01
db $0A,$01,$00,$03
db $03,$01,$00,$01
db $03,$01,$00,$01
db $7F,$00,$00,$00
db $08,$01,$00,$00
db $03,$01,$00,$00
db $06,$01,$00,$00
db $08,$01,$00,$02
db $06,$01,$00,$01
db $09,$01,$00,$01
db $0B,$01,$00,$02
db $08,$01,$00,$03
db $06,$01,$00,$01
db $0E,$01,$00,$00
db $0A,$01,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$02,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $0A,$02,$00,$02
db $05,$02,$00,$01
db $05,$02,$00,$03
db $0C,$02,$00,$01
db $0C,$02,$00,$02
db $10,$02,$00,$01
db $14,$02,$00,$03
db $05,$01,$00,$00
db $05,$01,$00,$00
db $FF,$02,$00,$00
db $FF,$02,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $1A,$03,$00,$02
db $16,$03,$00,$03
db $0C,$03,$00,$01
db $08,$03,$00,$01
db $14,$04,$00,$02
db $05,$04,$00,$01
db $0A,$04,$00,$03
db $28,$03,$7F,$00
db $28,$04,$7F,$00
db $32,$05,$7F,$00
db $0F,$04,$00,$01
db $19,$04,$00,$02
db $16,$04,$00,$03
db $16,$04,$00,$02
db $28,$05,$7F,$00
db $03,$04,$7F,$00
db $14,$02,$00,$03
db $14,$02,$00,$00
db $14,$02,$00,$01
db $10,$03,$00,$00
db $10,$04,$00,$02
db $12,$04,$00,$01
db $12,$04,$00,$01
db $0F,$05,$00,$03
db $0C,$02,$00,$02
db $06,$02,$00,$01
db $19,$05,$00,$02
db $14,$06,$00,$01
db $1E,$05,$00,$03
db $1C,$06,$00,$02
db $14,$05,$FF,$00
db $14,$05,$00,$03
db $0A,$05,$00,$00
db $0F,$05,$00,$02
db $08,$05,$00,$01
db $06,$02,$00,$01
db $0C,$05,$00,$02
db $1C,$06,$00,$00
db $1E,$06,$00,$03
db $14,$05,$00,$02
db $28,$08,$7F,$00
db $19,$05,$00,$02
db $08,$02,$00,$00
db $05,$02,$00,$01
db $14,$08,$7F,$00
db $28,$08,$7F,$00
db $0A,$09,$7F,$00
db $01,$08,$7F,$00
db $14,$0A,$7F,$00
db $10,$03,$00,$02
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $28,$08,$7F,$00
db $14,$08,$00,$02
db $10,$08,$00,$02
db $1E,$08,$00,$02
db $0A,$02,$00,$00
db $01,$07,$7F,$00
db $0A,$09,$7F,$00
db $14,$08,$7F,$00
db $28,$07,$7F,$00
db $28,$09,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
Lut_VitalsDifficulty2:
db $00,$00,$00,$00
db $06,$02,$00,$02
db $05,$02,$00,$01
db $0A,$02,$00,$03
db $03,$02,$00,$01
db $03,$02,$00,$01
db $7F,$00,$00,$00
db $08,$02,$04,$00
db $03,$02,$03,$00
db $06,$02,$03,$00
db $08,$02,$00,$02
db $06,$02,$00,$01
db $09,$02,$00,$01
db $0B,$03,$00,$02
db $08,$02,$00,$03
db $06,$02,$00,$01
db $0E,$02,$00,$00
db $0A,$03,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $0A,$05,$00,$02
db $05,$04,$00,$01
db $05,$04,$00,$03
db $0C,$05,$00,$01
db $0C,$05,$00,$02
db $10,$05,$00,$01
db $14,$05,$00,$03
db $05,$02,$00,$00
db $05,$02,$00,$00
db $FF,$05,$00,$00
db $FF,$05,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$07,$7F,$00
db $1A,$07,$00,$02
db $16,$06,$00,$03
db $0C,$07,$00,$01
db $08,$07,$00,$01
db $14,$08,$00,$02
db $05,$07,$01,$01
db $0A,$08,$01,$03
db $28,$07,$7F,$00
db $28,$07,$7F,$00
db $32,$0A,$7F,$00
db $0F,$07,$01,$01
db $19,$08,$01,$02
db $16,$09,$00,$03
db $16,$07,$00,$02
db $28,$09,$7F,$00
db $03,$08,$7F,$00
db $14,$05,$00,$03
db $14,$05,$00,$00
db $14,$05,$00,$01
db $10,$07,$00,$00
db $10,$08,$01,$02
db $12,$09,$01,$01
db $12,$08,$01,$01
db $0F,$09,$01,$03
db $0C,$05,$00,$02
db $06,$05,$00,$01
db $19,$0A,$01,$02
db $14,$0B,$01,$01
db $1E,$0A,$01,$03
db $1C,$0B,$01,$02
db $14,$0A,$FF,$00
db $14,$0A,$01,$03
db $0A,$0A,$01,$00
db $0F,$0A,$01,$02
db $08,$0A,$01,$01
db $06,$05,$00,$01
db $0C,$0A,$01,$02
db $1C,$0B,$01,$00
db $1E,$0B,$01,$03
db $14,$0A,$01,$02
db $28,$0F,$7F,$00
db $19,$09,$01,$02
db $08,$05,$00,$00
db $05,$05,$00,$01
db $14,$0F,$7F,$00
db $28,$09,$7F,$00
db $0A,$10,$7F,$00
db $01,$0F,$7F,$00
db $14,$12,$7F,$00
db $10,$07,$00,$02
db $28,$0F,$7F,$00
db $28,$0F,$7F,$00
db $28,$0F,$7F,$00
db $28,$0F,$7F,$00
db $28,$0F,$7F,$00
db $28,$0F,$7F,$00
db $28,$0F,$7F,$00
db $14,$0F,$01,$02
db $10,$0F,$01,$02
db $1E,$0F,$01,$02
db $0A,$04,$00,$00
db $01,$08,$7F,$00
db $0A,$0A,$7F,$00
db $14,$09,$7F,$00
db $28,$08,$7F,$00
db $28,$11,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
Lut_VitalsDifficulty3:
db $00,$00,$00,$00
db $06,$04,$00,$02
db $05,$03,$00,$01
db $0A,$04,$00,$03
db $03,$04,$00,$01
db $03,$03,$00,$01
db $7F,$00,$00,$00
db $08,$04,$06,$00
db $03,$04,$05,$00
db $06,$04,$04,$00
db $08,$04,$00,$02
db $06,$04,$00,$01
db $09,$04,$00,$01
db $0B,$05,$00,$02
db $08,$04,$00,$03
db $06,$04,$00,$01
db $0E,$04,$00,$00
db $0A,$05,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$06,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $0A,$07,$00,$02
db $05,$06,$00,$01
db $05,$06,$00,$03
db $0C,$07,$00,$01
db $0C,$07,$00,$02
db $10,$07,$00,$01
db $14,$07,$00,$03
db $05,$03,$00,$00
db $05,$03,$00,$00
db $FF,$07,$00,$00
db $FF,$07,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$09,$7F,$00
db $1A,$09,$01,$02
db $16,$08,$00,$03
db $0C,$09,$00,$01
db $08,$09,$00,$01
db $14,$0A,$01,$02
db $05,$09,$01,$01
db $0A,$0A,$01,$03
db $28,$09,$7F,$00
db $28,$09,$7F,$00
db $32,$0C,$7F,$00
db $0F,$09,$01,$01
db $19,$0A,$01,$02
db $16,$0B,$01,$03
db $16,$09,$01,$02
db $28,$0B,$7F,$00
db $03,$0A,$7F,$00
db $14,$07,$01,$03
db $14,$07,$01,$00
db $14,$07,$01,$01
db $10,$09,$01,$00
db $10,$0A,$01,$02
db $12,$0B,$01,$01
db $12,$0A,$01,$01
db $0F,$0B,$01,$03
db $0C,$07,$01,$02
db $06,$07,$00,$01
db $19,$0C,$01,$02
db $14,$0D,$01,$01
db $1E,$0C,$01,$03
db $1C,$0D,$01,$02
db $14,$0C,$FF,$00
db $14,$0C,$01,$03
db $0A,$0C,$01,$00
db $0F,$0C,$01,$02
db $08,$0C,$01,$01
db $06,$07,$00,$01
db $0C,$0C,$01,$02
db $1C,$0D,$01,$00
db $1E,$0D,$01,$03
db $14,$0C,$01,$02
db $28,$11,$7F,$00
db $19,$0B,$02,$02
db $08,$07,$01,$00
db $05,$07,$00,$01
db $14,$11,$7F,$00
db $28,$0A,$7F,$00
db $0A,$12,$7F,$00
db $01,$11,$7F,$00
db $14,$14,$7F,$00
db $10,$09,$01,$02
db $28,$11,$7F,$00
db $28,$11,$7F,$00
db $28,$11,$7F,$00
db $28,$11,$7F,$00
db $28,$11,$7F,$00
db $28,$11,$7F,$00
db $28,$11,$7F,$00
db $14,$11,$02,$02
db $10,$11,$02,$02
db $1E,$11,$02,$02
db $0A,$06,$01,$00
db $01,$09,$7F,$00
db $0A,$0B,$7F,$00
db $14,$0A,$7F,$00
db $28,$09,$7F,$00
db $28,$13,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
}
else
{
Lut_VitalsDifficulty0:
db $00,$00,$00,$00
db $02,$01,$00,$02
db $02,$01,$00,$01
db $04,$02,$00,$03
db $02,$01,$00,$01
db $02,$01,$00,$01
db $7F,$00,$00,$00
db $08,$01,$46,$00
db $03,$01,$33,$00
db $06,$01,$30,$00
db $03,$01,$00,$02
db $02,$02,$00,$01
db $03,$01,$00,$01
db $04,$02,$00,$02
db $03,$02,$00,$03
db $02,$02,$00,$01
db $06,$02,$00,$00
db $04,$03,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $04,$04,$00,$02
db $02,$04,$00,$01
db $02,$04,$00,$03
db $04,$04,$00,$01
db $04,$05,$00,$02
db $06,$04,$00,$01
db $08,$05,$00,$03
db $02,$01,$00,$00
db $02,$01,$00,$00
db $FF,$04,$00,$00
db $FF,$05,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$07,$7F,$00
db $10,$06,$00,$02
db $0C,$06,$00,$03
db $04,$06,$00,$01
db $03,$06,$00,$01
db $08,$08,$00,$02
db $02,$07,$00,$01
db $04,$08,$00,$03
db $28,$06,$7F,$00
db $28,$07,$7F,$00
db $32,$0A,$7F,$00
db $06,$07,$00,$01
db $10,$08,$00,$02
db $0C,$09,$00,$03
db $0C,$07,$00,$02
db $28,$09,$7F,$00
db $03,$08,$7F,$00
db $08,$04,$00,$03
db $08,$04,$00,$00
db $08,$04,$00,$01
db $06,$06,$00,$00
db $06,$08,$00,$02
db $08,$09,$00,$01
db $08,$08,$00,$01
db $06,$09,$00,$03
db $04,$04,$00,$02
db $02,$04,$00,$01
db $10,$0A,$00,$02
db $08,$0B,$00,$01
db $18,$0A,$00,$03
db $14,$0B,$00,$02
db $08,$0A,$FF,$00
db $08,$0A,$00,$03
db $04,$0A,$00,$00
db $06,$0A,$00,$02
db $03,$0A,$00,$01
db $02,$04,$00,$01
db $08,$0A,$00,$02
db $14,$0B,$00,$00
db $18,$0B,$00,$03
db $0A,$0A,$00,$02
db $28,$0F,$7F,$00
db $10,$09,$00,$02
db $03,$04,$00,$00
db $02,$04,$00,$01
db $14,$10,$7F,$00
db $28,$0F,$7F,$00
db $0A,$10,$7F,$00
db $01,$0F,$7F,$00
db $14,$12,$7F,$00
db $06,$06,$00,$02
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $10,$10,$00,$02
db $0A,$10,$00,$02
db $18,$10,$00,$02
db $04,$04,$00,$00
db $01,$0D,$7F,$00
db $0A,$10,$7F,$00
db $14,$0F,$7F,$00
db $28,$0D,$7F,$00
db $28,$11,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
Lut_VitalsDifficulty1:
db $00,$00,$00,$00
db $02,$01,$00,$02
db $02,$01,$00,$01
db $04,$02,$00,$03
db $02,$01,$00,$01
db $02,$01,$00,$01
db $7F,$00,$00,$00
db $08,$01,$46,$00
db $03,$01,$33,$00
db $06,$01,$30,$00
db $03,$01,$00,$02
db $02,$02,$00,$01
db $03,$01,$00,$01
db $04,$02,$00,$02
db $03,$02,$00,$03
db $02,$02,$00,$01
db $06,$02,$00,$00
db $04,$03,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $04,$04,$00,$02
db $02,$04,$00,$01
db $02,$04,$00,$03
db $04,$04,$00,$01
db $04,$05,$00,$02
db $06,$04,$00,$01
db $08,$05,$00,$03
db $02,$01,$00,$00
db $02,$01,$00,$00
db $FF,$04,$00,$00
db $FF,$05,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$07,$7F,$00
db $10,$06,$00,$02
db $0C,$06,$00,$03
db $04,$06,$00,$01
db $03,$06,$00,$01
db $08,$08,$00,$02
db $02,$07,$00,$01
db $04,$08,$00,$03
db $28,$06,$7F,$00
db $28,$07,$7F,$00
db $32,$0A,$7F,$00
db $06,$07,$00,$01
db $10,$08,$00,$02
db $0C,$09,$00,$03
db $0C,$07,$00,$02
db $28,$09,$7F,$00
db $03,$08,$7F,$00
db $08,$04,$00,$03
db $08,$04,$00,$00
db $08,$04,$00,$01
db $06,$06,$00,$00
db $06,$08,$00,$02
db $08,$09,$00,$01
db $08,$08,$00,$01
db $06,$09,$00,$03
db $04,$04,$00,$02
db $02,$04,$00,$01
db $10,$0A,$00,$02
db $08,$0B,$00,$01
db $18,$0A,$00,$03
db $14,$0B,$00,$02
db $08,$0A,$FF,$00
db $08,$0A,$00,$03
db $04,$0A,$00,$00
db $06,$0A,$00,$02
db $03,$0A,$00,$01
db $02,$04,$00,$01
db $08,$0A,$00,$02
db $14,$0B,$00,$00
db $18,$0B,$00,$03
db $0A,$0A,$00,$02
db $28,$0F,$7F,$00
db $10,$09,$00,$02
db $03,$04,$00,$00
db $02,$04,$00,$01
db $14,$10,$7F,$00
db $28,$0F,$7F,$00
db $0A,$10,$7F,$00
db $01,$0F,$7F,$00
db $14,$12,$7F,$00
db $06,$06,$00,$02
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $10,$10,$00,$02
db $0A,$10,$00,$02
db $18,$10,$00,$02
db $04,$04,$00,$00
db $01,$0D,$7F,$00
db $0A,$10,$7F,$00
db $14,$0F,$7F,$00
db $28,$0D,$7F,$00
db $28,$11,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
Lut_VitalsDifficulty2:
db $00,$00,$00,$00
db $02,$01,$00,$02
db $02,$01,$00,$01
db $04,$02,$00,$03
db $02,$01,$00,$01
db $02,$01,$00,$01
db $7F,$00,$00,$00
db $08,$01,$46,$00
db $03,$01,$33,$00
db $06,$01,$30,$00
db $03,$01,$00,$02
db $02,$02,$00,$01
db $03,$01,$00,$01
db $04,$02,$00,$02
db $03,$02,$00,$03
db $02,$02,$00,$01
db $06,$02,$00,$00
db $04,$03,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $04,$04,$00,$02
db $02,$04,$00,$01
db $02,$04,$00,$03
db $04,$04,$00,$01
db $04,$05,$00,$02
db $06,$04,$00,$01
db $08,$05,$00,$03
db $02,$01,$00,$00
db $02,$01,$00,$00
db $FF,$04,$00,$00
db $FF,$05,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$07,$7F,$00
db $10,$06,$00,$02
db $0C,$06,$00,$03
db $04,$06,$00,$01
db $03,$06,$00,$01
db $08,$08,$00,$02
db $02,$07,$00,$01
db $04,$08,$00,$03
db $28,$06,$7F,$00
db $28,$07,$7F,$00
db $32,$0A,$7F,$00
db $06,$07,$00,$01
db $10,$08,$00,$02
db $0C,$09,$00,$03
db $0C,$07,$00,$02
db $28,$09,$7F,$00
db $03,$08,$7F,$00
db $08,$04,$00,$03
db $08,$04,$00,$00
db $08,$04,$00,$01
db $06,$06,$00,$00
db $06,$08,$00,$02
db $08,$09,$00,$01
db $08,$08,$00,$01
db $06,$09,$00,$03
db $04,$04,$00,$02
db $02,$04,$00,$01
db $10,$0A,$00,$02
db $08,$0B,$00,$01
db $18,$0A,$00,$03
db $14,$0B,$00,$02
db $08,$0A,$FF,$00
db $08,$0A,$00,$03
db $04,$0A,$00,$00
db $06,$0A,$00,$02
db $03,$0A,$00,$01
db $02,$04,$00,$01
db $08,$0A,$00,$02
db $14,$0B,$00,$00
db $18,$0B,$00,$03
db $0A,$0A,$00,$02
db $28,$0F,$7F,$00
db $10,$09,$00,$02
db $03,$04,$00,$00
db $02,$04,$00,$01
db $14,$10,$7F,$00
db $28,$0F,$7F,$00
db $0A,$10,$7F,$00
db $01,$0F,$7F,$00
db $14,$12,$7F,$00
db $06,$06,$00,$02
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $10,$10,$00,$02
db $0A,$10,$00,$02
db $18,$10,$00,$02
db $04,$04,$00,$00
db $01,$0D,$7F,$00
db $0A,$10,$7F,$00
db $14,$0F,$7F,$00
db $28,$0D,$7F,$00
db $28,$11,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
Lut_VitalsDifficulty3:
db $00,$00,$00,$00
db $02,$01,$00,$02
db $02,$01,$00,$01
db $04,$02,$00,$03
db $02,$01,$00,$01
db $02,$01,$00,$01
db $7F,$00,$00,$00
db $08,$01,$46,$00
db $03,$01,$33,$00
db $06,$01,$30,$00
db $03,$01,$00,$02
db $02,$02,$00,$01
db $03,$01,$00,$01
db $04,$02,$00,$02
db $03,$02,$00,$03
db $02,$02,$00,$01
db $06,$02,$00,$00
db $04,$03,$00,$03
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$04,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $04,$04,$00,$02
db $02,$04,$00,$01
db $02,$04,$00,$03
db $04,$04,$00,$01
db $04,$05,$00,$02
db $06,$04,$00,$01
db $08,$05,$00,$03
db $02,$01,$00,$00
db $02,$01,$00,$00
db $FF,$04,$00,$00
db $FF,$05,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $28,$07,$7F,$00
db $10,$06,$00,$02
db $0C,$06,$00,$03
db $04,$06,$00,$01
db $03,$06,$00,$01
db $08,$08,$00,$02
db $02,$07,$00,$01
db $04,$08,$00,$03
db $28,$06,$7F,$00
db $28,$07,$7F,$00
db $32,$0A,$7F,$00
db $06,$07,$00,$01
db $10,$08,$00,$02
db $0C,$09,$00,$03
db $0C,$07,$00,$02
db $28,$09,$7F,$00
db $03,$08,$7F,$00
db $08,$04,$00,$03
db $08,$04,$00,$00
db $08,$04,$00,$01
db $06,$06,$00,$00
db $06,$08,$00,$02
db $08,$09,$00,$01
db $08,$08,$00,$01
db $06,$09,$00,$03
db $04,$04,$00,$02
db $02,$04,$00,$01
db $10,$0A,$00,$02
db $08,$0B,$00,$01
db $18,$0A,$00,$03
db $14,$0B,$00,$02
db $08,$0A,$FF,$00
db $08,$0A,$00,$03
db $04,$0A,$00,$00
db $06,$0A,$00,$02
db $03,$0A,$00,$01
db $02,$04,$00,$01
db $08,$0A,$00,$02
db $14,$0B,$00,$00
db $18,$0B,$00,$03
db $0A,$0A,$00,$02
db $28,$0F,$7F,$00
db $10,$09,$00,$02
db $03,$04,$00,$00
db $02,$04,$00,$01
db $14,$10,$7F,$00
db $28,$0F,$7F,$00
db $0A,$10,$7F,$00
db $01,$0F,$7F,$00
db $14,$12,$7F,$00
db $06,$06,$00,$02
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $28,$10,$7F,$00
db $10,$10,$00,$02
db $0A,$10,$00,$02
db $18,$10,$00,$02
db $04,$04,$00,$00
db $01,$0D,$7F,$00
db $0A,$10,$7F,$00
db $14,$0F,$7F,$00
db $28,$0D,$7F,$00
db $28,$11,$7F,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
db $00,$00,$00,$00
}
endif


EPlayerChargeListener_SR_QuitPsychoDashIfForbidden:
lda $0AA2 : bit #$0001 : bne +
  jmp EPlayerChargeListener_SR_QuitCharge
+:
jmp EPlayerChargeListener_SR_QuitAbilityIfForbidden
EPlayerChargeListener_SR_QuitFriarIfForbidden:
lda $0aa2 : bit #$0010 : bne +
  jmp EPlayerChargeListener_SR_QuitCharge
+:
jmp EPlayerChargeListener_SR_QuitAbilityIfForbidden

SR_MaybeAllowBlock:
{
lda $0ad4 : bne +
%MClzIfHasFlute() : bne +
  lda #$0000
  rts
+:
lda #$0100
rts
SR_PlayerAttackFreezeAndSound_SetupWill:
%MClzIfHasFlute() : bne .HasFlute
  lda #$0400 : tsb $10
  lda #$0200 : trb $10
  rts
.HasFlute:
lda #$0100 : trb $10
cop #$06 : db $01
rts
SR_SecIfCombatEnabledOrSnakeGame:
lda $0644 : cmp #$00C6 : beq .SecAndReturn
lda $09AE : bit #$0008 : beq .SecAndReturn
.ClcAndReturn:
clc
rts
.SecAndReturn:
sec
rts
}

SR_SetWillAbilitySpriteSetOnFlute:
%MClzIfHasFlute() : bne .WithFlute
.NoFlute:
cop #$8E : db $07
rts
.WithFlute:
cop #$8E : db $04
rts

SR_SecIfCanDsWarpFromMenu:
; Reserved for future use
sec
rts

SR_ClcIfItemAIsDroppable:
{
cmp #$0013 : beq .IsDungeon3Item   ; Rama Statue
cmp #$001e : bcc .IsNormalItem   ; Hieroglyphs are $1e - $23
cmp #$0024 : bcc .IsDungeon5Item
cmp #$0026 : beq .IsDungeon5Item   ; Father's Journal
.IsNormalItem:
phx
sta $0000
lsr : lsr : lsr : tay
lda #$0000
sep #$20
lda $0000 : and #$07 : tax
lda.l ..PowersOfTwo,x : and.w Lut_ItemDroppableFlags,y : sec : bne +
  clc
+:
rep #$20
plx
rts
..PowersOfTwo:
db $01,$02,$04,$08,$10,$20,$40,$80
.IsDungeon3Item:
lda.l Config_SettingDungeonShuffle
  ora.l Config_SettingBossShuffle
  ora.l Config_SettingStatuesPlayerChoice
  ora.l Config_Dungeon3Required
  bne .NoDropSpecial
.CanDropSpecial:
clc
rts
.NoDropSpecial:
sec
rts
.IsDungeon5Item:
lda.l Config_SettingDungeonShuffle
  ora.l Config_SettingBossShuffle
  ora.l Config_SettingStatuesPlayerChoice
  ora.l Config_Dungeon5Required
  bne .NoDropSpecial
bra .CanDropSpecial
}

SR_InvSetupPointedItem:
ldy $1a
lda $0ab4,y : and #$00ff : sta $0ae8
stz $0bfa
jsl LR_GetItemAStackedCountBcd : cmp.w #2 : bcc +   ; Count=1 -> $0bfa=0
  inc $0bfa
  cmp.w #10 : bcc +    ; 1<Count<10 -> $0bfa=1
    inc $0bfa
+:
rts

SR_InvCleanupPointedItem:
lda.l SramInvActivePageId : inc : sta $0bfa
lda #$c040 : tsb $0658
rts

; In the base game, you run if you tap in the direction you're facing while $040c is non-negative.
; $040c is non-negative only for ~12 frames after you tap any direction from a stationary position.
; This routine extends the logic to allow running under some circumstances if the unused button is pressed.
; Input is a proposed direction, 0/1/2/3 = S/N/W/E; player's facing direction should be in $24.
SR_SecIfCanStartRunningInDirectionA:
{
sta $0000
cmp $24 : beq .FacingInProposedDirection
.NotFacingInProposedDirection:
; If A-to-run is enabled, you can run in a non-blocked direction if you aren't pressing your facing direction.
;lda $0bea : beq .ClcAndReturn
lda $0656 : bit #$0080 : beq .ClcAndReturn
lda $24 : beq ..FacingSouth
  dec : beq ..FacingNorth
  dec : beq ..FacingWest
..FacingEast:
lda #$0100
bra ..CheckButtons
..FacingSouth:
lda #$0400
bra ..CheckButtons
..FacingNorth:
lda #$0800
bra ..CheckButtons
..FacingWest:
lda #$0200
;bra ..CheckButtons
..CheckButtons:
bit $0656 : bne .ClcAndReturn
lda $0000 : jsr .SR_SecIfDirectionAIsBlocked : bcs .ClcAndReturn
bra .SecAndReturn
.FacingInProposedDirection:
lda $040c : bpl .SecAndReturn   ; Double-tapping a direction works.
; If A-to-run is enabled, you can start running in the non-blocked direction you're facing.
;lda $0bea : beq .ClcAndReturn
lda $0656 : bit #$0080 : beq .ClcAndReturn
lda $09ae : bit #$1000 : bne .ClcAndReturn   ; no running up ramps
lda $24 : jsr .SR_SecIfDirectionAIsBlocked : bcs .ClcAndReturn
;bra .SecAndReturn
.SecAndReturn:
sec
rts
.ClcAndReturn:
clc
rts
.SR_SecIfDirectionAIsBlocked:
pha
lda $1014 : lsr : lsr : lsr : lsr : sta $0018
lda $1016 : sec : sbc #$0008 : lsr : lsr : lsr : lsr : sta $001c
pla : beq ..FacingSouth
  dec : beq ..FacingNorth
  dec : beq ..FacingWest
..FacingEast:
inc $0018
bra ..CheckBlocked
..FacingSouth:
inc $001c
bra ..CheckBlocked
..FacingNorth:
dec $001c
bra ..CheckBlocked
..FacingWest:
dec $0018
;bra ..CheckBlocked
..CheckBlocked:
phd
lda #$0000 : tcd
jsl $83d78a    ; = jsl LR_GetTileTableIndex83
pld
sep #$20
phx
  tyx
  lda $7fc000,x
plx
  bit #$f0 : beq +
    lsr : lsr : lsr : lsr   ; Use the current effective type, if any
+:
  cmp #$02 : bcc ..NotBlocked  ; Nonsolid and semisolid never block.
  cmp #$0e : bcs ..IsBlocked   ; Solids always block.
  cmp #$0c : beq ...RampNorth
  cmp #$0a : beq ...RampEast
  cmp #$05 : beq ...RampWest
  cmp #$03 : beq ...RampSouth
  cmp #$02 : beq ..IsBlocked   ; Ladder
  cmp #$07 : beq ..IsBlocked   ; Sideling wall
  cmp #$08 : beq ..IsBlocked   ; Dropdown ledge
bra ..NotBlocked
...RampNorth:
lda $24 : beq ..IsBlocked
bra ..NotBlocked
...RampEast:
lda $24 : cmp #$02 : beq ..IsBlocked
bra ..NotBlocked
...RampWest:
lda $24 : cmp #$03 : beq ..IsBlocked
bra ..NotBlocked
...RampSouth:
lda $24 : dec : beq ..IsBlocked
;bra ..NotBlocked
..NotBlocked:
rep #$20
clc
rts
..IsBlocked:
rep #$20
sec
rts
}

SR_RunningConsiderReturnToActRepl:
cop #$40 : dw $8000, .DoReturn
lda $09b2 : ora $09b4 : bne .DoReturn
lda $0656 : bit #$0080 : beq .NoReturn
lda $09ae : bit #$1000 : bne .NoReturn
; With A-to-run and A pressed, should ParseAct occasionally to e.g. start running from a walk.
lda $2a : cmp #$0004 : bcc .NoReturn
lda $24 : cmp #$0002 : bcs .NoReturn
bra .DoReturn
.NoReturn:
lda $09ae : bit #$1000
rts
.DoReturn:
pla
cop #$C5



}



; Bank $83
{

org $8381cd
lda $81aade,x : jsr SR_SetupRadarForceTextOrSec : bcs B_838248
org $838248
B_838248:

org $838294
lda $81adac,x   ; radar screen chest counter, updated for chest table with 2-byte items
rep #$20
and #$007f : jsl LR_SecOnFlag20A
sep #$20 : bcs +
org $8382f9
inc $0002
+:
inx : inx : inx : inx : inx : jmp $828e


org $83843f
; LR_HandleUseItem_Pointers:
skip 2*$27
dw SR_UseItemCrystalRing    ; Item $27
dw SR_UseItemApple    ; Item $28
skip 2    ; Item $29, artificial for HP upgrade
skip 2    ; Item $2a, artificial for STR upgrade
skip 2    ; Item $2b, artificial for DEF upgrade
skip 2    ; Item $2c, artificial for Psycho Dash upgrade
skip 2    ; Item $2d, artificial for Friar upgrade
dw SR_UseItemTwoJewels    ; Item $2e 
dw SR_UseItemThreeJewels    ; Item $2f 
skip 2    ; Item $30 


org $8384d5
SR_UseItemRedJewel:
if !SettingRedJewelMadness == 1
cop #$BF : dw .UseText
jsr SR_RemoveHeldItem
jsl LR_IncJewelCounter
jsl LR_DecHP
phx
phd
  lda $09AA : tcd : tax
  cop #$A5 : dl $838566 : dw $0000,$2000
  tyx
  lda #$0000 : sta $0012,x
  lda #$3000 : sta $000E,x
  lda $1014 : sta $0014,x
  lda $1016 : sta $0016,x
pld
plx
rts
.UseText:
db $cd : dl TextUsedRedJewelRJM
db $c0
endif
warnpc $838566


org $8385cf
db $13    ; Allow Prison Key use from south of door.
org $8385dc
; Remove the key; don't run cop #$33 here, and instead just set flag $24 and let the listener do so.
cop #$D5 : db $02
cop #$BF : dw $861f
cop #$CC : db $24
cop #$08 : db $0e,$0e
cop #$10 : db $0e,$11
cop #$10 : db $0f,$11
rts


org $83888a
table "table_dialogue.txt",rtl
SR_UseItemHerb:
cop #$BF : dw .TextOfferUse
cop #$BE : db $02,$01 : dw .UseOptions
.UseOptions:
  dw .ChooseDecline
  dw .ChooseAccept, .ChooseDecline
.ChooseAccept:
cop #$BF : dw ..Text
jsr SR_GetHerbHealAmount : sta $0b22    ; Instead of lda #$0008, uses difficulty level to set heal amount.
jsr SR_RemoveHeldItem
rts
..Text:
db $cd : dl TextUsedHerbOverflow
db $c0
.ChooseDecline:
cop #$BF : dw ..Text
rts
..Text:
db $cd : dl TextDeclinedHerbOverflow
db $c0
.TextOfferUse:
db $d3
db $c6 : dw $0002, $0aaa    ; <number>
db "_left - take one?",$cb
db "_Yes",$cb
db "_No"
db $ca
warnpc $838917


org $83899a
SR_UseItemWindMelody:
jsr SR_SecIfCanPlayMusic : db $90   ; i.e. jsr ... : bcc ..., replacing lda $0ad4 : bne ...


org $838BA4
SR_UseItemLolasMelody:
{
jsr SR_SecIfCanPlayMusic : bcc .NoFlute
lda $0644 : cmp #$0015 : beq .InItory
  cmp #$0011 : bne .NothingHappened
.InEdwardsFlowerRoom:
cop #$BF : dw ..Text
rts
..Text:
db $d3
db $cd : dl TextLongLolasMelodyInEdwards
db $c0
.InItory:
cop #$D0 : db $40, $01 : dw .NothingHappened
.DoPlaySong:
lda #$0080 : tsb $09EC
cop #$BF : dw TextLayDownDatFunkCat
phx
ldx #$0000
cop #$A5 : dl $839FCA : dw $0000, $2000    ; i.e. EFluteSongPlayer
cpy #$1FC0 : bne +
  jmp ++
+:
lda #$CFF0 : tsb $065A
++:
lda $0012,y : ora #$1000 : sta $0012,y
lda #$0018 : sta $0026,y
lda #$0001 : sta $0020,y
plx
rts
.NothingHappened:
cop #$BF : dw $8CDB
rts
.NoFlute:
cop #$BF : dw TextUsedSongNoFlute
rts

EFluteSongPlayer_PostLolasMelody:
lda $0644 : cmp #$0015 : bne EFluteSongPlayer_PostLolasMelody_ButNothingHappened
cop #$CC : db $40
cop #$BF : dw $8ca0
cop #$D5 : db $09
cop #$C5
EFluteSongPlayer_PostLolasMelody_ButNothingHappened:
cop #$BF : dw $8d05
cop #$C5

TextLayDownDatFunkCat:
db $D3
db "Lay down dat funk, cat."
db $C0
}
warnpc $838d67

org $838f17
SR_UseItemMemoryMelody:
{
jsr SR_SecIfCanPlayMusic : bcs +
  cop #$BF : dw TextUsedSongNoFlute
  rts
+:
lda $0644 : cmp #$0049 : beq +
  cop #$BF : dw TextUsedMemoryMelodyWrongMap
  rts
+:
lda #$0080 : tsb $09ec
cop #$BF : dw TextUsedMemoryMelodyCorrectMap
phx
ldx #$0000
cop #$A5 : dl $839fca : db $00,$00 : dw $2000
lda $0012,y : ora #$1000 : sta $0012,y
lda #$001d : sta $0026,y
lda #$0002 : sta $0020,y
plx
lda #$000e : sta $06f2
rts
EFluteSongPlayer_PostMemoryMelody:
cop #$D5 : db $0d
cop #$CC : db $14
cop #$C5

TextUsedSongNoFlute:
db $D3
db "He doesn't have",$cb
db "the Flute."
db $C0

TextUsedMemoryMelodyWrongMap:
db $D3
db $cd : dl TextUsedMemoryMelodyIncl
db $CF
db "But nothing happened."
db $C0

TextUsedMemoryMelodyCorrectMap:
db $D3
db $CE
db $cd : dl TextUsedMemoryMelodyIncl
db $C0

TextUsedMemoryMelodyIncl:
db "Will began playing the",$cb
db "melody he remembered."
db $ca
}
warnpc $838ff3

org $839174
rts   ; End Mu key use before excessive text.

org $8391d7
db $c0    ; Shorten Mu door text.

org $839299
SR_UseItemHopeStatue:   ; Use 2-byte flags for statue placement, to separate placement from water level
cop #$BF : dw .TextRaisedStatue
lda $0644 : cmp #$0063 : bne .NothingHappened
cop #$45 : db $06, $06, $0A, $08 : dw .InLeftRoom
cop #$45 : db $16, $06, $1A, $08 : dw .InRightRoom
bra .NothingHappened
.InRightRoom:
cop #$D1 : dw $02b1 : db $01 : dw .NothingHappened
jsr SR_RemoveHeldItem
cop #$BF : dw $930B
cop #$CD : dw $02b1
rts
.InLeftRoom:
cop #$D1 : dw $02b0 : db $01 : dw .NothingHappened
jsr SR_RemoveHeldItem
cop #$BF : dw $930B
cop #$CD : dw $02b0
rts
.NothingHappened:
cop #$BF : dw $92FB
rts
.TextRaisedStatue:
db $cd : dl TextRaisedStatueOfHope
db $ca
warnpc $8392FB

org $8393a5
; Magic Dust check.
{
jsl LR_SecIfAtKaraLocation : bcs +
  cop #$BF : dw $93ea
  rts
+:
cop #$BF : dw $93fa
cop #$D5 : db $14
cop #$CC : db $8a   ; Sets a unique flag instead of temp flag $01
rts
}
warnpc $8393c5

org $839427
SR_UseItemBlueJournal:
{
if !SettingDebug == 1
phx
phd
jsl LR_DebugSubActor
pld
plx
rts
else
cop #$BF : dw .TextIntro
cop #$BE : db $03,$01 : dw .UseOptions
.UseOptions:
  dw .ChooseDecline
  dw .ChooseOption1, .ChooseOption2, .ChooseOption3
.ChooseDecline:
cop #$BF : dw .TextDecline
rts
.ChooseOption1:
cop #$BF : dw .TextOption1
rts
.ChooseOption2:
cop #$BF : dw .TextOption2
rts
.ChooseOption3:
cop #$BF : dw .TextOption3
rts
.TextIntro:
db $cd : dl TextBlueJournalIntro
db $ca
.TextDecline:
db $cd : dl TextBlueJournalDecline
db $c0
.TextOption1:
if !SettingRedJewelHunt == 1
db $cd : dl TextBlueJournalOption1RJH
else
db $cd : dl TextBlueJournalOption1Normal
endif
db $c0
.TextOption2:
db $cd : dl TextBlueJournalOption2
db $c0
.TextOption3:
db $cd : dl TextBlueJournalOption3
db $c0
endif
}

warnpc $83950c
org $83950c
; Lance's letter
{
lda.l Config_KaraLocation : dec : sta $0bfa
cop #$BF : dw Text_LancesLetter    ; $9514
stz $0bfa
cop #$CC : db $8e
rts

Text_LancesLetter:
db $D3
db $C2,$04
db "Will, Kara is in",$cb
db $C5 : dw .LocNames, $0bfa
db $CB 
db "________-Lance",$C0
.LocNames:
dw ..EdDg
dw ..Mine
dw ..Angl
dw ..Kres
dw ..Ankr
..EdDg:
db "Edward's Prison"
db $ca
..Mine:
db "Diamond Mine"
db $ca
..Angl:
db "Angel Village"
db $ca
..Kres:
db "Mt. Kress"
db $ca
..Ankr:
db "Ankor Wat"
db $ca
}
warnpc $83966a

org $83983d
; Teapot
{
cop #$BF : dw $9861
lda $0644 : cmp #$001a : bne +
  cop #$45 : db $07,$05,$17,$10 : dw DoUseTeapot
+:
cop #$BF : dw $9880
rts
DoUseTeapot:
cop #$BF : dw $9890
cop #$D5 : db $19
cop #$CC : db $2a
rts
}

org $83997f
SR_UseItemBlackGlasses:
{
cop #$BF : dw .TextPutOn
cop #$CC : db $f5
cop #$D5 : db $1c
rts
.TextPutOn:
table "table_dialogue.txt",rtl
db $d3
db "Coolness intensifies!"
db $c0
}


;org $839b89
;; Set which tile is created by each hieroglyph item.
;db !HieroItemTile1
;skip 4
;db !HieroItemTile2
;skip 4
;db !HieroItemTile3
;skip 4
;db !HieroItemTile4
;skip 4
;db !HieroItemTile5
;skip 4
;db !HieroItemTile6


org $839CDC    ; In SR_UseItemAura, this is the not-Shadow branch.
cop #$BF : dw TextYouCantUseAura
rts
TextYouCantUseAura:
table "table_dialogue.txt",rtl
db $d3
db $cd : dl TextLongYouCantUseAura
db $c0

warnpc $839d09
org $839d09
; End of Lola's Letter use code.
{
cop #$CC : db $11
cop #$D5 : db $25
cop #$BF : dw Text_LolasLetter
rts
Text_LolasLetter:
db $D3
db $C2,$03
db $cd : dl TextUseLolasLetter
db $C0
}

SR_UseItemTwoJewels:
jsr SR_RemoveHeldItem
phx
ldx #$0002
-:
jsl LR_IncJewelCounter
if !SettingRedJewelMadness == 1
jsl LR_DecHP
endif
dex : bne -
plx
cop #$BF : dw .Text
rts
.Text:
db $cd : dl TextUsedTwoRedJewels
db $C0

SR_UseItemThreeJewels:
jsr SR_RemoveHeldItem
phx
ldx #$0003
-:
jsl LR_IncJewelCounter
if !SettingRedJewelMadness == 1
jsl LR_DecHP
endif
dex : bne -
plx
cop #$BF : dw .Text
rts
.Text:
db $cd : dl TextUsedThreeRedJewels
db $C0

org $839e15
SR_UseItemFathersJournal:
jsl LR_DisplayFathersJournalText
rts
LR_DisplayFathersJournalText:
phx
ldy #$0000
-:
tyx
lda.l Config_HieroOrderAnchor,x : dec : asl : tax
lda.l .HieroCharacters,x
tyx
sta.l 1+SramTextBuffer,x
iny : iny : cpy #$000c : bcc -
tyx
lda.l .HieroCharacters,x : sta.l 1+SramTextBuffer,x
sep #$20
lda #$d8 : sta.l SramTextBuffer
rep #$20
plx
cop #$BF : dw .Text
rtl
.Text:
db $cd : dl TextUseFathersJournalWithSram
db $c0
.HieroCharacters:
db $c0,$c1
db $c2,$c3
db $c4,$c5
db $c6,$c7
db $c8,$c9
db $ca,$cb
db $00,$ca

warnpc $839f30
org $839f30
SR_UseItemCrystalRing:
cop #$BF : dw .TextBlingBling
cop #$CC : db $3e
cop #$D5 : db $27
rts
.TextBlingBling:
table "table_dialogue.txt",rtl
db $d3
db "Bling bling."
db $c0

org $839f5d
SR_UseItemApple:
cop #$BF : dw .Text
rts
.Text:
db $D3
db $cd : dl TextUseApple
db $C0


org $839fb2
; If the held item is a stack, removes one from the stack.
SR_RemoveHeldItem:
ldy $0ac4
lda $0ab4,y : and #$00ff : jsl LR_DecStackForItemAReturningCountOrSec : bne +
  jsr SR_FullClearHeldItem
+:
jsl LR_DoUnequip
rts
warnpc $839fca


org $83a068
; Pointers to code to play after the three songs -- some addrs have changed in IOGR
dw $8a16 ;EFluteSongPlayer_PostWindMelody
dw EFluteSongPlayer_PostLolasMelody
dw EFluteSongPlayer_PostMemoryMelody

org $83b401
Lut_MapChoices:
{
.Pointers:
{
dw .Index00   ; Inaccessible.
dw .ContinentSW
dw .ContinentSE
dw .ContinentNE
dw .ContinentNN
dw .ContinentNW
}
; Continent SE.
{
.Index00:
.ContinentSE:
cop #$BF : dw ..Text
cop #$BE : db $53,$00 : dw ..Options
cop #$C5
..Options:
dw OverworldMapChoices_!OverworldShuffleFrejLabel
dw OverworldMapChoices_!OverworldShuffleFrejLabel
dw OverworldMapChoices_!OverworldShuffleNzcaLabel
dw OverworldMapChoices_!OverworldShuffleNeilLabel
dw OverworldMapChoices_!OverworldShuffleDCstLabel
dw OverworldMapChoices_!OverworldShuffleMineLabel
..Text:
db $C1,$02,$14   ; This + next line, instead of $C2,$11;
db $C7,$0E,$03   ; because "Where do you go?" doesn't fit with 5 options.
db $D2,$00
db $AC,"!OverworldShuffleFrejText",$AC,$AC,"!OverworldShuffleDCstText"
db $CB
db $AC,"!OverworldShuffleNzcaText",$AC,$AC,"!OverworldShuffleMineText"
db $CB
db $AC,"!OverworldShuffleNeilText"
db $CA
}
; Continent NE.
{
.ContinentNE:
cop #$BF : dw ..Text
cop #$BE : db $32,$01 : dw ..Options
cop #$C5
..Options:
dw OverworldMapChoices_!OverworldShuffleWtmaLabel
dw OverworldMapChoices_!OverworldShuffleWtmaLabel
dw OverworldMapChoices_!OverworldShuffleGtWlLabel
dw OverworldMapChoices_!OverworldShuffleAnglLabel
..Text:
db $C2,$11
db $D2,$00
db $AC,"!OverworldShuffleWtmaText",$AC,$AC,"!OverworldShuffleAnglText"
db $CB
db $AC,"!OverworldShuffleGtWlText"
db $CA
}
; Continent N.
{
.ContinentNN:
cop #$BF : dw ..Text
cop #$BE : db $42,$01 : dw ..Options
cop #$C5
..Options:
dw OverworldMapChoices_!OverworldShuffleEuroLabel
dw OverworldMapChoices_!OverworldShuffleEuroLabel
dw OverworldMapChoices_!OverworldShuffleNtVlLabel
dw OverworldMapChoices_!OverworldShuffleKresLabel
dw OverworldMapChoices_!OverworldShuffleAnkrLabel
..Text:
db $C2,$11
db $D2,$00
db $AC,"!OverworldShuffleEuroText",$AC,$AC,"!OverworldShuffleKresText"
db $CB
db $AC,"!OverworldShuffleNtVlText",$AC,$AC,"!OverworldShuffleAnkrText"
db $CA
}
; Continent NW.
{
.ContinentNW:
cop #$BF : dw ..Text
cop #$BE : db $02,$01 : dw ..Options
cop #$C5
..Options:
dw OverworldMapChoices_!OverworldShuffleDaoLabel
dw OverworldMapChoices_!OverworldShuffleDaoLabel
dw OverworldMapChoices_!OverworldShufflePymdLabel
..Text:
db $C2,$11
db $D2,$00
db $AC,"!OverworldShuffleDaoText"
db $CB
db $AC,"!OverworldShufflePymdText"
db $CA
}
; Continent SW.
{
.ContinentSW:
cop #$BF : dw ..Text
cop #$BE : db $53,$00 : dw ..Options
cop #$C5
..Options:
dw OverworldMapChoices_!OverworldShuffleCapeLabel
dw OverworldMapChoices_!OverworldShuffleCapeLabel
dw OverworldMapChoices_!OverworldShuffleEdLabel
dw OverworldMapChoices_!OverworldShuffleMoonLabel
dw OverworldMapChoices_!OverworldShuffleIncaLabel
dw OverworldMapChoices_!OverworldShuffleItryLabel
..Text:
db $C1,$02,$14   ; This + next line, instead of $C2,$11;
db $C7,$0E,$03   ; because "Where do you go?" doesn't fit with 5 options.
db $D2,$00
db $AC,"!OverworldShuffleCapeText",$AC,$AC,"!OverworldShuffleIncaText"
db $CB
db $AC,"!OverworldShuffleEdText",$AC,$AC,"!OverworldShuffleItryText"
db $CB
db $AC,"!OverworldShuffleMoonText"
db $CA
}

}


org $83b955
; mapdest.bin, where options in Lut_MapChoices take you
OverworldMapChoices:
{
.Cape:
cop #$26 : db $01 : dw $0178,$0040 : db $03,$00,$43
cop #$C5
.Ed:
cop #$26 : db $0A : dw $01F8,$02C0 : db $00,$20,$34
cop #$C5
.Moon:
cop #$26 : db $1A : dw $0150,$01A0 : db $00,$00,$22
cop #$C5
.Inca:
cop #$26 : db $1C : dw $0070,$0160 : db $00,$00,$22
cop #$C5
.DCst:
cop #$26 : db $30 : dw $0048,$0020 : db $03,$00,$21
cop #$C5
.Frej:
cop #$26 : db $32 : dw $0130,$0350 : db $00,$00,$45
cop #$C5
.Mine:
cop #$26 : db $3E : dw $00A8,$03D0 : db $80,$00,$42
cop #$C5
.Neil:
cop #$26 : db $49 : dw $0088,$00C0 : db $00,$00,$11
cop #$C5
.Nzca:
cop #$26 : db $4B : dw $0120,$0080 : db $00,$00,$44
cop #$C5
.SeaP:
cop #$26 : db $5A : dw $0090,$0070 : db $83,$00,$14
cop #$C5
.Mu:
cop #$26 : db $5F : dw $0088,$0050 : db $07,$00,$44
cop #$C5
.Angl:
cop #$26 : db $69 : dw $02A0,$00C0 : db $00,$00,$13
cop #$C5
.Wtma:
cop #$26 : db $78 : dw $0278,$0390 : db $00,$00,$45
cop #$C5
.GtWl:
cop #$26 : db $82 : dw $0020,$0090 : db $87,$00,$18
cop #$C5
.Euro:
cop #$26 : db $91 : dw $03D0,$0430 : db $06,$00,$54
cop #$C5
.Kres:
cop #$26 : db $A0 : dw $02C8,$01B0 : db $86,$00,$23
cop #$C5
.NtVl:
cop #$26 : db $AC : dw $01C0,$01D0 : db $06,$00,$22
cop #$C5
.Ankr:
cop #$26 : db $B0 : dw $01F8,$04C0 : db $80,$00,$54
cop #$C5
.Dao:
cop #$26 : db $C3 : dw $0010,$00E0 : db $07,$00,$23
cop #$C5
.Pymd:
cop #$26 : db $CC : dw $0010,$00D0 : db $87,$00,$44
cop #$C5
.Babl:
cop #$26 : db $DE : dw $0078,$00C0 : db $00,$00,$11
cop #$C5
.Itry:
cop #$26 : db $15 : dw $02D8,$0370 : db $00,$00,$45
cop #$C5
}


; Changes to make monster stats look up the new tables.
org $83be52
db $82   ; i.e. #BankOf(Lut_VitalsDifficulty0)
org $83bfba
jsr SR_GetMonsterHpAtStatAddrY
org $83bfc3
jsr SR_GetMonsterDefAtStatAddrY
org $83c45d
jsr SR_GetMonsterStrAtStatAddrY



org $83c464
if !SettingZ3 == 1
jsr SR_HalveAPerDef    ; Instead of sbc $0adc, halves damage per DEF instead of reducing it by 1 per DEF
endif


; SetSpriteOrder and RenderActors read/write 512 bytes by setting S and running pla/pha respectively;
; so effectively there's no stack, and we need to disable IRQs by cutting bytes to fit in a sei.
org $83c69b   ; This is LR_SetSpriteOrder_AllActorsChecked, just before the stack games start.
lda #$ffff : sta $0c00,y
inc : tcd   ; reprobate's shortening of lda #$0000 : tcd
nop
sei
; A cli isn't needed because the routine preserves P (via php - code - plp - rtl).

org $83c736   ; This is near the top of LR_RenderActors, going into the stack games.
{
lda #$0004 : sta $0e
sei
tsc : sta $00
lda #$0622 : sta $06
dec : tcs   ; the above were all rearranged to make this 'dec' possible, freeing 2 bytes
ldx #$0010
lda #$E080
-:
pha : pha : pha : pha : pha : pha : pha : pha
pha : pha : pha : pha : pha : pha : pha : pha
dex : bne -
lda $00 : tcs
cli   ; Could leave sei, or pull the original i, but cli is probably best
}
warnpc $83c763


org $83c849
LR_WriteSpriteIfVisible:
{
; Optimization: D=0, so $00??,x -> $??,x if x is LowRAM or ROM bank $00.
phb 
sep #$21
  lda $7f0008,x : pha : plb 
rep #$20
lda $14,x  ; sec provided by sep #$21 up there
  sbc $18,x : sec : sbc $1a : sta $18
lda $16,x : sec : sbc $1a,x : sec : sbc $1e : sta $1c
lda $0e,x : sta $04         ; $04 = SpriteFlags.
stz $02
lda $10,x : bit #$0080 : beq +
  bit #$0010 : bne +
lda $7F0028,x : beq ++
lsr : bcc ++
  lda #$0E00 : sta $02
++:
lda $10,x
+:
bpl +
  jmp $c928
+:
lda $7f000c,x : clc : adc #$0008 : tax 
lda $0000,x : and #$00ff : sta $10
.MegaLoop:
lda $0004,x : bit $04 : bpl +
  xba
+:
and #$00ff : clc : adc $1c : cmp #$00f0 : bcs .NoFlushOffScreenSprite
  sbc #$0010 : sta $0423,y
lda $0006,x : eor $04 : ora $02 : sta $0424,y
lda $0002,x : bit $04 : bvc +
  xba 
+:
and #$00ff : clc : adc $18 : cmp #$0110 : bcs .FlushOffScreenSprite
  sbc #$000f
sep #$20
  sta $0422,y
xba : lsr : ror $00
lda $0001,x : lsr : ror $00
dec $0e : bne +
  lda $00 : sta ($06)
  inc $06
  lda #$04 : sta $0e
+:
rep #$21
tya : adc #$0004 : tay
cpy #$0200 : beq .Finish
.TryNextSprite:
txa : adc #$0007 : tax
dec $10 : bne .MegaLoop
.Finish:
plb 
rts 
.FlushOffScreenSprite:
lda #$e080 : sta $0422,y
.NoFlushOffScreenSprite:
clc
bra .TryNextSprite
}
warnpc $83c926

org $83c936
; Override body sprite source to allow fluteless Will.
jsr SR_GetBodySpriteSourceIndex
bra $04;nop : nop : nop : nop : nop : nop

org $83CA55
LR_AnimateSprite:
{
; Similar optimizations.
phb
sep #$20
  lda $7F0008,x : pha : plb
rep #$21
lda $28 : asl : adc $7F0006,x : tay
lda $2A : asl : asl : adc $0000,y : tay
lda $0000,y : bmi .SecAndReturn
  sta $08
lda $0002,y : tay
  clc : adc #$0004 : sta $7F000C,x
lda $0002,y : bit $0E : bpl +
  xba
+:
sep #$20
  sta $1A
  xba
  sta $1E
rep #$20
lda $0000,y : bit $0E : bvc +
  xba
+:
sep #$20
sta $18
stz $19
xba
sta $1C
stz $1D
bpl +
  lda #$FF : sta $1D
+:
xba
bpl +
  lda #$FF : sta $19
+:
inc $2A
lda $13 : lsr : bcs .ClcAndReturn    ; Flag means "no-update hitbox".
lda $18 : sta $20    ; Do update hitbox.
lda $1C : sta $21
lda $1E : sta $23
lda $1A : bit $12 : bmi +    ; Flag means "no-trim hitbox Y".
  sbc #$09    ; Actually subtract 8, but c=0 is guaranteed.
+:
sta $22
.ClcAndReturn:
rep #$21
plb
rtl
.SecAndReturn:
rep #$20
stz $2A
sec
plb
rtl
}
warnpc $83CAF5


org $83cffb
jsr SR_MapVitalOffsetByDifficulty    ; Another monster stat lookup.

org $83d003
jsr SR_GetMonsterHpAtStatAddrY    ; jsr to lookup for new stat blocks

org $83d0db
; Extensive modifications to this routine.
SR_FixMapAndSecIfMonDead:
{
phy
phx
sta $0000
lsr : lsr : lsr : tay
lda #$0000
sep #$20
lda $0000 : and #$07 : tax
if !SettingDungeonShuffle == 0    ; In dungeon shuffle, monsters always respawn upon entering a room.
lda.l Lut_PowersOfTwo83,x : and $0A80,y : bne .MonIsDead
endif
clc
rep #$20
plx
ply
rts
.MonIsDead:
if !SettingOrbRando > 0
rep #$20
bra .DoneOrSkippedRearrange
else
lda $03,s : tay    ; High byte of A and Y both are guaranteed to be 0.
lda [$3E],y
rep #$20
beq .DoneOrSkippedRearrange
jsl LR_GetItemId8ForMonsterItemFlagA
jsl $82a363    ; = jsl LR_StageMapRearrange
bcs .DoneOrSkippedRearrange
ldy $3E : phy
ldy $40 : phy
jsl $82a220    ; = jsl LR_DoMapRearrange
ply : sty $40
ply : sty $3E
endif
.DoneOrSkippedRearrange:
sec
plx
ply
rts
warnpc $83d125
org $83d125
Lut_PowersOfTwo83:
db $01,$02,$04,$08,$10,$20,$40,$80
}
warnpc $83d12d



org $83e03a
nop : nop    ; Load Firebird assets in every map, in case Early Firebird is enabled.


org $83e2cb
dw SR_PadTextToColumn   ; Replace a nonfunctional text-draw routine (card $c4) with a useful one


org $83e849
; In the base game, on a two-column menu, pressing Up on option 0 underflows to the final option;
; but pressing Down on the final option overflows to the top of the second column, not to option 0.
; The inconsistency is visible and annoying in the DS warp menu, so it's rectified here.
; At this point, A contains the controller bitmask; $01,s is the index of the selected menu option;
; and $03,s is the cop #$BE OptCounts argument: high nibble = option count, low nibble = left column size.
LR_HandleBg3Menu:
{
phd
phx
pha
lda #$0000 : tcd
  pha
  sta $0994
.AwaitInput:
jsr $e983
jsr $e7b2    ; delays dialogue box by 1 frame
lda $0656 : bit #$CF80 : beq .AwaitInput
LR_HandleBg3MenuInput:
pha
  lda #$CFF0 : tsb $0658
pla : bit #$0c00 : bne .PressedUpOrDown
  bit #$8080 : bne .PressedConfirm
  bit #$4000 : bne .PressedCancel
  bit #$0300 : beq LR_HandleBg3Menu_AwaitInput
    jmp .PressedLeftOrRight
.PressedCancel:
jsr $ea2a
pla
lda #$0000
bra .Done
.PressedConfirm:
lda $000A : pha
  lda $000C : pha
    sep #$20
      lda #$11 : sta $06F9    ; Confirmation sound
    rep #$20
  pla : sta $000C
pla : sta $000A
stz $0994
jsr $e983
pla : inc
.Done:
pha
  jsr $e7b2    ; delays dialogue box by 1 frame
pla
stz $0994
stz $0990
stz $0992
ply
plx
pld
sec
rtl
.PressedUpOrDown:
stz $0994
sep #$20    ; High byte of A contains the up/down mask, and is now protected
lda #$10 : sta $06f9    ; Cursor move sound
lda $03,s : and #$0F : sta $1C   ; Left column option count
lda $03,s : lsr : lsr : lsr : lsr : sta $18   ; Total number of options
xba : bit #$08 : bne .PressedUp
.PressedDown:
lda $01,s : cmp $1C : bcs ..InRightColumn
..InLeftColumn:
  inc : cmp $1C : bcs ...DidOverflow
    bra ..Done
...DidOverflow:
lda #$00
bra ..Done
..InRightColumn:
inc : cmp $18 : bcc ..Done
  lda $1C    ; Did overflow, so set pos to first right-column option
..Done:
sta $01,s
rep #$20
jmp LR_HandleBg3Menu_AwaitInput
.PressedUp:
lda $01,s : beq ..AtTopOfLeftCol
  cmp $1C : beq ..AtTopOfRightCol
bra ..DecAndDone
..AtTopOfLeftCol:
lda $1C : bra ..DecAndDone
..AtTopOfRightCol:
lda $18 ;: bra ..DecAndDone
..DecAndDone:
dec : sta $01,s
rep #$20
jmp LR_HandleBg3Menu_AwaitInput
warnpc $83e93c
org $83e93c
.PressedLeftOrRight:
}


org $83ecc2
if !SettingDebug == 1
db $80   ; bcs -> bra in bg3 number draw, to not hide 10s in numbers
endif

; Fix BG3 script card $05 to draw hex digits A-F correctly
org $83ed90
lda $0000,y : clc : jsr SR_GetBg3CharForNibble
org $83eda6
lda $0000,y : sec : jsr SR_GetBg3CharForNibble : iny : nop : nop : nop : nop

org $83edce
lda #$30   ; In BG3 script card $05, draw leading zeroes as zeroes instead of dots

org $83ef3e
; Change BG3 card $09 to act like $0e (2-digit decimal number draw) but showing leading zeroes.
SR_Bg3ScriptCard09:
{
phy
lda $05,s : tax    ; DestTile.
lda $099E : ora #$0030 : sta $0004    ; Tile mask, with base char ID of $30 = number 0.
lda $0000,y : tay    ; y=ArgAddr -> y=Arg
lda $0000,y          ; y=Arg -> y=(Arg)
sec
.RemoveHundreds:
sbc.w #100 : bcs .RemoveHundreds
adc.w #100
stz $0000   ; Tens-counter.
.CollectTens:
inc $0000
sec : sbc.w #10 : bcs .CollectTens
.DrawOnesAndTens:
adc.w #10 : ora $0004 : sta $7F0202,x
lda $0000 : dec : ora $0004 : sta $7F0200,x
.Done:
inx : inx : inx : inx : txa : sta $05,s
ply
iny : iny
rts
}
warnpc $83ef97

org $83ef97
LR_GiveItemAnchor:   ; Utility for cop #$D4 and other callers. Redirects to my custom handler.
jml LR_GiveNormalItemA8OrSec
warnpc $83f08d
org $83f08d
LR_RemoveItemA:    ; Utility for cop #$D5 and other callers. If the item is stacked, only removes one.
if !SettingInfiniteInventory == 1
jml LR_DecOrClearItemA
endif
warnpc $83f0b3
org $83f0b3
LR_ClcIfPlayerHasItemA:   ; Utility for cop #$D6 and other callers.
if !SettingInfiniteInventory == 1
jsr SR_ClcIfInfiniteInventoryHasItemA : bcc .HasItem
sec
rtl
.HasItem:
clc
rtl
endif
warnpc $83f0ca


org $83f177
; Pointers to lists of effective facing directions for special body values.
skip 2   ; Body $04 = Will abilities
skip 2   ; Body $05
skip 2   ; Bdoy $06
dw $f17f   ; Body $07 is fluteless Will abilities, so should match body $04


; Bank $83 free space begins here.
org $83f201
SR_HalveAPerDef:
phx
ldx $0ADC
-:
cpx #$0000 : beq +
lsr a
dex
bra -
+:
plx
cmp #$0000  
rts

SR_SetupRadarForceTextOrSec:
and #$00ff : beq .SecAndReturn
  sta $0bfa
cop #$D0 : db $f5,$01 : dw .ClcAndReturn
stz $0bfa
.ClcAndReturn:
clc
rts
.SecAndReturn:
sec
rts

SR_GetHerbHealAmount:
lda $0B24 : beq +++
  dec : beq ++
  dec : beq +
if !SettingZ3 == 0
lda #$0004
else
lda #$0008
endif
bra ++++
+:
if !SettingZ3 == 0
lda #$0006
else
lda #$000e
endif
bra ++++
++:
if !SettingZ3 == 0
lda #$0008
else
lda #$0028
endif
bra ++++
+++:
lda #$0028 ;: bra ++++
++++:
rts

; Maps a relative address in the base vitals table (i.e. the x in $81abf0,x) to the
; corresponding absolute address in the difficulty-specific vitals table (i.e. the x in $820000,x).
SR_MapVitalOffsetByDifficulty:
pha
lda $0B24 : beq +++
  dec : beq ++
    dec : beq +
      pla : adc.w #Lut_VitalsDifficulty3
      bra ++++
+:
    pla : adc.w #Lut_VitalsDifficulty2
    bra ++++
++:
  pla : adc.w #Lut_VitalsDifficulty1
  bra ++++
+++:
pla : adc.w #Lut_VitalsDifficulty0
++++:
rts

; Maps an absolute address in the base vitals table (i.e. the x in $810000,x) to the difficulty-specific table. 
; Addresses in the difficulty-specific tables, as well as $0000, are unmodified.
SR_MapVitalAbsoluteByDifficulty:
cpy #$B000 : bcs +
  tya : beq +
    sec : sbc #$ABF0 : clc : jsr SR_MapVitalOffsetByDifficulty : tay
+:
rts

SR_GetMonsterHpAtStatAddrY:
jsr SR_MapVitalAbsoluteByDifficulty
phx
tyx
lda $820000,x
plx
rts
SR_GetMonsterStrAtStatAddrY:
jsr SR_MapVitalAbsoluteByDifficulty
phx
tyx
lda $820001,x
plx
rts
SR_GetMonsterDefAtStatAddrY:
jsr SR_MapVitalAbsoluteByDifficulty
phx
tyx
lda $820002,x
plx
rts
LR_GetMonsterGemAtStatAddrY:   ; LR because this is called from two banks.
tay : jsr SR_MapVitalAbsoluteByDifficulty
phx
tyx
lda $820003,x
plx
rtl

SR_GetBodySpriteSourceIndex:
lda $0ad4 : bne ++
%MClzIfHasFlute() : bne +
  lda.w #18
  rts
+:
lda #$0000
rts
++:
asl : adc $0ad4 : asl
rts

SR_SecIfCanPlayMusic:
lda $0ad4 : bne .ClcAndReturn
lda.l Config_SettingFluteOpt : cmp #$0001 : bne .SecAndReturn
%MClzIfHasFlute() : beq .ClcAndReturn
.SecAndReturn:
sec
rts
.ClcAndReturn:
clc
rts

SR_ClcIfInfiniteInventoryHasItemA:
php
phx
sep #$20
ldx #$0000
.CheckNextInvSlot:
  cmp.l SramInvItems,x : beq .HasItem
  inx : cpx.w #(SramInvEndOfList-SramInvItems) : bne .CheckNextInvSlot
.NoItem:
plx
plp
sec
rts
.HasItem:
plx
plp
clc
rts

SR_FullClearHeldItem:
ldy $0ac4
sep #$20
  lda #$00 : sta $0AB4,y
rep #$20
if !SettingInfiniteInventory == 1
jsl LR_UpdateInvFromViewSlotY
endif
jsl LR_DoUnequip
rts

; Used for dynamically drawing Jeweler's inventory, and maybe other things too.
SR_PadTextToColumn:
phy
stx $0998
txa : and #$003f : lsr : sec
sep #$20
  sbc $0000,y
rep #$20
  bit #$0080 : beq .Done   ; Nothing to do if here-there>=0 (we're at or past the target column)
    ora #$ff00 : eor #$ffff : inc : tay
-:
lda #$00ac : ora $0986 : ora #$2100 : sta $7f0200,x
  clc : adc #$0010 : sta $7f0240,x
inx : inx
stx $0998
dey : bne -
.Done:
ply
iny
rts

; Used by BG3 script card $05 to fix drawing A-F.
; Input byte in A; clc for low nibble, sec for high nibble.
SR_GetBg3CharForNibble:
bcc .LowNibble
.HighNibble:
lsr : lsr : lsr : lsr
.LowNibble:
and #$0f : ora #$30 : cmp #$3a : bcc .Done
  clc : adc #$07
.Done:
rts
}



; Bank $84
{

org $848377    ; Cape fisherman appears at the east side of the docks.
cop #$D0 : db $10,$01 : dw $83aa
nop

org $848468
; Fisherman
%MTryGiveItemAndFlag("CapeFisherItem", $d7)
rtl

org $848a03
db $10   ; Seth's house flag

org $848a8c
db $35 : dw $1000
ECapeTeacher:
lda #$0200 : tsb $12
cop #$C0 : dw .OnInteract
cop #$0B
cop #$C1
rtl
.OnInteract:
cop #$CC : db $38   ; Flag for tracker to know that we've talked to the teacher
if !SettingRedJewelHunt == 1
cop #$BF : dw .TextNoStatues
rtl
endif
lda.l Config_SettingStatuesPlayerChoice : beq ..ForGameChoice
  jmp ..ForPlayerChoice
..ForGameChoice:
clc
lda.l Config_Statue1Required
  adc.l Config_Statue2Required
  adc.l Config_Statue3Required
  adc.l Config_Statue4Required
  adc.l Config_Statue5Required
  adc.l Config_Statue6Required
  sta $0000
bne ...NonzeroStatues
  cop #$BF : dw .TextNoStatues
  rtl
...NonzeroStatues:
cmp #$0001 : bne ...SomeStatues
  ; One statue
  phx
  ldx #$0000
-:
  lda.l Config_Statue1Required,x : bne +
  inx : inx
  bra -
+:
  txa : lsr : inc : sta $0bfa
  plx
  cop #$BF : dw .TextYouNeedStatueSingle
  rtl
...SomeStatues:
phx
lda #$0000 : sta $0002  ; $0002 = next statue to check
  sta $0004   ; $0004 = position in text buffer
ldy $0000   ; Y = count of statue numbers not yet appended
....CheckNext:
sep #$20
lda $0002 : asl : tax
lda.l Config_Statue1Required,x : bne ....GotStatue
inc $0002
bra ....CheckNext
....GotStatue:
ldx $0004
lda $0002 : clc : adc #$21 : sta.l SramTextBuffer,x   ; Char #$21 = 1, etc.
inx
inc $0002
inc $0004
dey
cpy #$0000 : beq ....Done
cpy #$0001 : beq ....OneLeft
....SomeLeft:
rep #$20
db $a9,",_" : sta.l SramTextBuffer,x   ; eq. lda.w #", "
inx : inx
stx $0004
lda #$0000
bra ....CheckNext
....OneLeft:
lda $0000 : cmp #$03 : bcc +
  db $a9,"," : sta.l SramTextBuffer,x   ; Comma before " and " only if 3 or more statues
  inx
  inc $0004
+:
rep #$20
db $a9,"_a" : sta.l SramTextBuffer,x
inx : inx
db $a9,"nd" : sta.l SramTextBuffer,x
inx : inx
sep #$20
db $a9,"_" : sta.l SramTextBuffer,x
inx
stx $0004
lda #$00 : xba
bra ....CheckNext
....Done:
lda #$CA : sta.l SramTextBuffer,x
rep #$20
plx
cop #$BF : dw .TextYouNeedMysticStatues
rtl
..ForPlayerChoice:
lda.l Config_StatuesRequiredCount : sta $0bfa
  beq ...NoStatues
  dec : beq ...OneStatue
...SomeStatues:
cop #$BF : dw .TextNumStatues
rtl
...OneStatue:
cop #$BF : dw .TextOneStatue
rtl
...NoStatues:
cop #$BF : dw .TextNoStatues
rtl
.TextYouNeedMysticStatues:
db $cd : dl .TextYouNeedMysticStatueIncl
db "s_"
db $cb
db $cd : dl SramTextBuffer
db "!"
db $c0
.TextYouNeedStatueSingle:
db $cd : dl .TextYouNeedMysticStatueIncl
db "_"
db $c6 : dw 1, $0bfa
db "!"
db $c0
.TextYouNeedMysticStatueIncl:
db $d3
db "You need Mystic Statue"
db $ca
.TextNoStatues:
db $d3
db "No"
db $cd : dl .TextStatuesAreRequiredIncl
db $c0
.TextOneStatue:
db $d3
db "One statue is"
db $cd : dl .TextRequiredIncl
db $c0
.TextNumStatues:
db $d3
db $c6 : dw 1, $0bfa
db $cd : dl .TextStatuesAreRequiredIncl
db $c0
.TextStatuesAreRequiredIncl:
db "_statues are"
db $cd : dl .TextRequiredIncl
db $ca
.TextRequiredIncl:
db "_required!"
db $ca
warnpc $848d21


org $84922f
cop #$C0 : dw TutorialNpcOnInteract

org $84928a
db $10   ; Lola flag 1

org $849873
db $10   ; Lola flag 2

org $849985
rtl      ; Skip Lola's Melody cutscene

org $8499d8
; Lola
{
cop #$D0 : db $35,$01 : dw LolaGotItem
%MTryGiveItemAndFlag("CapeLolaItem", $35)
rtl
LolaGotItem:
cop #$BF : dw $9d94
rtl
}

org $84b8b1
db $0a : dw $1000
EErikInCapeCave:
cop #$25 : db $08,$09
cop #$0B
cop #$C0 : dw .OnInteract
cop #$C1
rtl
.OnInteract:
cop #$D0 : db $12,$01 : dw .AskWhere
cop #$D0 : db $11,$01 : dw .SetTravelFlag
cop #$BF : dw .TextNoTravel
rtl
.SetTravelFlag:
cop #$CC : db $12
cop #$BF : dw .TextFirstTravel
.AskWhere:
cop #$BF : dw .TextWhereTravel
cop #$BE : db $42,$01 : dw .TravelOptions
.TravelOptions:
dw ..ChooseCancel
dw ..ChooseCancel,        ..ChooseToWatermia
dw ..ChooseToDiamondCoast,..ChooseToSouthCape
..ChooseCancel:
cop #$BF : dw .TextCancel
rtl
..ChooseToWatermia:
cop #$26 : db $78 : dw $0278,$0390 : db $00,$00,$45
cop #$C5
..ChooseToDiamondCoast:
cop #$26 : db $30 : dw $0048,$0110 : db $03,$00,$21
cop #$C5
..ChooseToSouthCape:
cop #$26 : db $02 : dw $0070,$0080 : db $03,$00,$11
cop #$C5
.TextNoTravel:
db $C2,$0A
db $C2,$03
db $cd : dl TextErikNoTravel
db $C0
.TextFirstTravel:
db $C2,$0A
db $C2,$03
db $cd : dl TextErikFirstTravel
db $C0
.TextWhereTravel:
db $D3
db $C2,$05
db $D5,$00
db $cd : dl TextErikOfferTravel
db $CA
.TextCancel:
db $CE
db $C2,$05
db $D5,$00
db "Seth: Well, thanks for",$cb
db "noticing me..."
db $C0


org $84be3b
jmp $be57   ; Seaside Cave exit listener, skip the plot/dialogue

org $84be6a
db !Map02Exit01

org $84c20e
%MTryGiveItemAndFlag("ECHiddenGuardItem", $d8)
rtl

org $84c297
db $c0   ; End the hidden guard's text early

org $84c3d4
cop #$C0 : dw $c406    ; Skip first half of Edward interaction

org $84c4fb
; Edward's dialogue
db $D3
db $cd : dl TextEdwardGoToJail
db $C0

org $84c69f
; Speed up the guards' response after talking to Edward
db $1c : dw $1800
ECEdwardThroneGuard:
cop #$C0 : dw $c765;.OnInteract
cop #$B6 : db $30
cop #$0B
cop #$D2 : db $0a,$01    ; i.e. await the setting of this flag by Edward
cop #$9C : dl $84c721 : dw $2000   ; Darkens the screen and does the map warp
cop #$0C
cop #$C0 : dw $0000
cop #$85 : db $20, $04, $12
cop #$8A
cop #$86 : db $1f, $04, $12
cop #$8A
cop #$81 : db $20,$12
cop #$89
cop #$80 : db $1c
cop #$89
lda #$0800 : trb $10
cop #$CC : db $0b
cop #$D2 : db $0c,$01
cop #$DA : db $0b
cop #$86 : db $1E, $05, $11
cop #$8A
cop #$C1
rtl

org $84c746
db $10    ; Don't set a flag upon talking to Edward

org $84c755
db !MapPrisonWarpString

org $84caf5   ; Castle guard top floor text
db $d3
db "!SpoilerTextCastleGuard"
db $c0

org $84d0da
; Castle basement barrel
{
cop #$C0 : dw CastleBasementBarrelInteract
cop #$C1
rtl
CastleBasementBarrelInteract:
cop #$D0 : db $46,$00 : dw CastleBasementBarrelGiveItem
cop #$E0
CastleBasementBarrelGiveItem:
%MTryGiveItemAndFlag("ECBasementItem", $46)
rtl
}

org $84d1a0
; The jail guard's dialogue
{
cop #$C0 : dw CastleBasementGuardOnInteract
cop #$BC : db $00,$08
---:
cop #$0B
cop #$0D : db $00,$01
cop #$0D : db $00,$FF
cop #$D2 : db $01,$01
cop #$0C
cop #$10 : db $10,$3b
cop #$10 : db $10,$3c
lda #$0008 : sta $09b2
cop #$DA : db $1d
cop #$CE : db $01
bra ---
CastleBasementGuardOnInteract:
cop #$BF : dw TextCastleBasementGuard
cop #$CC : db $01
rtl
TextCastleBasementGuard:
db $C2,$0B
db "This is the prison.",$cb
db "Innocents can't enter."
db $C0
}

; Several tweaks to skip the prison cell cutscene.
db $23 : dw $3800
ECPlotDriver:
cop #$D0 : db $24,$01 : dw .DoorAlreadyOpen
cop #$0F : db $0e,$11
cop #$0F : db $0f,$11
cop #$9C : dl ECDoorOpeningListener : dw $2000
lda #$0800 : trb $10
.DoorAlreadyOpen:
cop #$D0 : db $23,$01 : dw .Die ; $d2d6
.SpawnHamlet:
cop #$DA : db $04
lda #$1000 : tsb $10
lda #$2000 : trb $10
cop #$BF : dw $d4a5
cop #$86 : db $27,$06,$02
cop #$8A
cop #$85 : db $29,$02,$01
cop #$8A
cop #$82 : db $27,$12
cop #$89
cop #$9E : dl ECHamletItemGiver : dw $0000, $fff0, $1000
cop #$D2 : db $23,$01
cop #$86 : db $26, $0e, $01
cop #$8A
.Die:
cop #$E0

ECHamletItemGiver:
lda #$0200 : tsb $12
cop #$88 : dl $8ee000
cop #$C0 : dw .OnInteract
cop #$80 : db $00
cop #$89
cop #$D2 : db $23,$01
.Die:
cop #$E0
.OnInteract:
%MTryGiveItemAndFlag("EDHamletItem",$23)
cop #$D0 : db $23,$01 : dw .Die
rtl

ECDoorOpeningListener:
cop #$D2 : db $24,$01
cop #$32 : db $06
cop #$33
cop #$CD : dw $0106
cop #$E0
warnpc $84d329

org $84dc5e
; Dialogue of person in west dungeon cell
db $d3
db $cd : dl TextEdwardJailedPerson
db $c0

org $84e2a3
; modified itory entrance handler
{
db $00 : dw $3000
EItoryEntranceHandler:
cop #$45 : db $20,$30,$40,$40 : dw .PlayerInArea
cop #$E0
.PlayerInArea:
cop #$C1
cop #$D0 : db $40,$01 : dw .DoEnterItory
cop #$45 : db $2d,$37,$2e,$38 : dw .DoNothing
.LeaveItory:
cop #$BF : dw .TextYouNeedLolasMelody
cop #$66 : dw $00c0,$02c0 : db !OverworldShuffleItryMenuId
cop #$C1
.DoNothing:
rtl
.TextYouNeedLolasMelody:
db $d3
db "(Looks like you'll",$cb
db "need to find and use",$cb
db "a certain item to",$cb
db "enter the town...)"
db $c0
.DoEnterItory:
lda #$1000 : tsb $10
lda #$eff0 : tsb $065a
lda #$0380 : sta $2130
cop #$3C : dl $80b7ce
cop #$DA : db $af
cop #$CC : db $01
cop #$CA : db $10
lda $06c2 : sec : sbc #$0010 : sta $06c2
ldy $09aa
lda $0016,y : sec : sbc #$0010 : sta $0016,y
lda $16 : sec : sbc #$0010 : sta $16
cop #$CB
lda #$0300 : sta $06dc
cop #$CE : db $01
cop #$DA : db $3b
cop #$3C : dl $80b7d8
cop #$DA : db $9d
cop #$DA : db $29
lda #$eff0 : trb $065a
lda #$0800 : tsb $10
cop #$82 : db $1e,$11
cop #$89
cop #$81 : db $21,$01
cop #$89
cop #$86 : db $1e,$02,$01
cop #$8A
lda #$cff0 : trb $065a
cop #$85 : db $21,$06,$01
cop #$8A
cop #$82 : db $1e,$11
cop #$89
cop #$85 : db $21,$02,$01
cop #$8A
cop #$86 : db $1f,$06,$12
cop #$8A
cop #$81 : db $21,$11
cop #$89
cop #$80 : db $1d
cop #$89
lda #$0800 : trb $10
cop #$D2 : db $04,$01
lda #$0001 : jsl $80c6e4
cop #$80 : db $1a
cop #$89
cop #$BF : dw $e53c
lda #$0800 : tsb $10
cop #$86 : db $1f,$02,$12
cop #$8A
cop #$86 : db $1f,$04,$12
cop #$8A
cop #$E0
}
warnpc $84e5a1


org $84e5a1
db $1c : dw $1000
ELillyInItory:
cop #$D0 : db $6f,$01 : dw .Die
cop #$0B
cop #$C0 : dw .OnInteract
rtl
.OnInteract:
cop #$D6 : db $17 : dw .TakeNecklace
cop #$BF : dw .TextNoNecklace
rtl
.TakeNecklace:
cop #$CC : db $37
cop #$CC : db $6f
cop #$D5 : db $17
cop #$BF : dw .TextTakeNecklace
.Die:
cop #$0C
cop #$E0
.TextNoNecklace:
db $C2,$0B
db $C2,$02
db "Lilly: I lost the necklace",$cb
db "Lance gave me! I feel",$cb
db "so awful..."
db $C0
.TextTakeNecklace:
db $C2,$0B
db $C2,$02
db $cd : dl TextGiveLillyNecklace
db $C0


org $84e933
db $10   ; Itory elder is always visible

org $84e97a
cop #$BF : dw TextSpoilerItoryElder    ; Itory elder just talks upon interaction
rtl

org $84e9ff
TextSpoilerItoryElder:
db $d3
db "!SpoilerTextItoryElder"
db $c0

org $84f373
; Itory cave statue
%MTryGiveItemAndFlag("ItoryCaveItem", $2d)
rtl

org $84f8b7
; Moon tribe time limit in seconds, as BCD (e.g. 20 seconds = $20), is enemizer-dependent
if !SettingEnemizer == 0
lda #$0020
elseif !SettingEnemizer == 1
lda #$0025
else
lda #$0030
endif

org $84fadf
; Moon Tribe cave statue
%MTryGiveItemAndFlag("MoonTribeCaveItem", $48)
rtl

org $84fb3f
; Bank $84 free space begins here.

TutorialNpcOnInteract:
{
cop #$BF : dw .TextChat
cop #$BE : db $02,$01 : dw .ChatOptions
.ChatOptions:
  dw ..ChooseNo
  dw ..ChooseNo, ..ChooseYes
..ChooseNo:
cop #$BF : dw .TextChoseNo
rtl
..ChooseYes:
cop #$D6 : db $15 : dw ..AlreadyHaveBook
cop #$D4 : db $15 : dw ..YourInvFull
cop #$BF : dw .TextGetBook
rtl
..YourInvFull:
cop #$BF : dw .TextYourInvFull
rtl
..AlreadyHaveBook:
cop #$BF : dw .TextAlreadyHaveBook
rtl
.TextChat:
db $D3
db "Want a tutorial?",$cb
db "_No",$cb
db "_Yes"
db $CA
.TextChoseNo:
db $CE
db "You're right, reading's",$cb
db "for nerds."
db $C0
.TextAlreadyHaveBook:
db $CE
db "You already have one!",$cb
db "Greedy..."
db $C0
.TextGetBook:
db $CE
db "You got the Blue Journal!"
db $C0
.TextYourInvFull:
db $CE
db "Your inventory's full,",$cb
db "mate."
db $C0
}

}



; Bank $85
{
org $858188
nop : nop : nop : nop    ; Don't lock out Castoth on gold ship

org $8583c9
db $80,$0a    ; Gold Ship ladder NPC spawns away from ladder

org $8583cb
db $10   ; Gold Ship ladder NPC checks for Mystic Statue get

org $8584a9
EGoldShipPilot_OnInteract:
{
cop #$BF : dw .TextOfferTravel
cop #$BE : db $02,$01 : dw .Options
.Options:
  dw .SayNo
  dw .SayNo, .SayYes
.SayNo:
cop #$BF : dw .TextDeclineTravel
rtl
.SayYes:
cop #$26 : db !MapShipExitString
cop #$C5
.TextOfferTravel:
db $D3
db "Ready to set sail?",$CB
db "_No",$cb
db "_Yes"
db $CA
.TextDeclineTravel:
db $CE
db "Come back when",$cb
db "you're ready."
db $C0
}

org $8586a3   ; Map transition upon sleeping in Inca ship
cop #$26 : db $30 : dw $0048,$0020 : db $03,$00,$21

org $858a04
db $10,$00 ; Gold Ship queen flag

org $858a1f
db $10   ; Gold Ship queen flag

org $858a29
db $10   ; Gold Ship queen flag

org $858ac0   ; Gold Ship queen text
db $d3
db "!SpoilerTextGoldShipQueen"
db $c0

org $859643
db $10,$00    ; "Seth" actor flag

org $859652
cop #$D0 : db $e0,$01 : dw IncaSethAlreadyGivenItem
%MTryGiveItemAndFlag("IncaGoldShipItem", $e0)
rtl
IncaSethAlreadyGivenItem:
cop #$BF : dw $96c1
rtl


org $85aa74
cop #$C0 : dw TurboOnInteract

org $85ad6b
db $d3
db "!SpoilerTextDiamondCoast"
db $c0

org $85b683    ; Woman on roof who can warp you upward
cop #$BF : dw .TextAskChoice
cop #$BE : db $02,$01 : dw .ChoiceOptions
.ChoiceOptions:
  dw .ChooseDecline
  dw .ChooseDecline, .ChooseAccept
.ChooseDecline:
cop #$BF : dw ..Text
rtl
..Text:
db $ce
db $c8
db $c0
.ChooseAccept:
cop #$26 : db $32 : dw $0360, $0170 : db $00,$00,$45
rtl
.TextAskChoice:
db $cd : dl TextRoofWarpingWomanAskChoice
db $ca
warnpc $85b6c0


org $85b6d2
%MTryGiveItemAndFlag("FrejEastSlaverItem", $e1)
rtl

org $85b880
FrejSnitchSlaverInteraction:
cop #$BF : dw TextFrejSnitchGreeting
cop #$BE : db $02,$02 : dw .HaveYouSeenOptions
.HaveYouSeenOptions:
  dw ..SayNo, ..SayYes, ..SayNo
..SayNo:
cop #$BF : dw TextFrejSayNotSeen
rtl
..SayYes:
cop #$BF : dw TextFrejSaySeen
cop #$BE : db $02,$02 : dw .TellWhereOptions
.TellWhereOptions:
  dw ..SayNo, ..SayYes, ..SayNo
..SayNo:
cop #$BF : dw $b9cb
rtl
..SayYes:
cop #$D0 : db $59,$00 : dw .PlayerDoesNotKnow
%MTryGiveItemAndFlag("FrejSnitchItem", $5a)
cop #$D0 : db $5a,$00 : dw .InvFull
cop #$CC : db $5a
lda #$eff0 : tsb $065a
.InvFull:
rtl
.PlayerDoesNotKnow:
cop #$BF : dw $b9af
rtl
TextFrejSnitchGreeting:
db $d3
db "A 'FRIEND' escaped.",$cb
db "Have you seen him?",$cb
db " Yes",$cb
db " No",$ca
TextFrejSayNotSeen:
db $ce
db "Useless.",$c0
TextFrejSaySeen:
db $ce
db "I'll give you something",$cb
db "if you tell me where.",$cb
db " Yes, I'm a bad person",$cb
db " Snitches get stitches yo",$ca
warnpc $85ba0c

; Update NPC dialogue to Neomatamune's quote (congrats tourney winner 2023)
org $85bdbe
db $d3
db "French don't say Sacre",$cb
db "Bleu!"
db $c0
warnpc $85bdea


org $85bfd9
cop #$BF : dw $bfde    ; The one market slave uses the Remus text

org $85c331
; Text of the escaped slave inside the house
db "Crap, I left the door",$cb
db "unlocked again..."
db $c0

org $85cf31
EFreejiaBin2_OnInteract:
cop #$D0 : db $53,$01 : dw .GotItemAlready
%MTryGiveItemAndFlag("FrejBin2Item", $53)
.GotItemAlready:
rtl

org $85cf85
{
db $25 : dw $1000
EFreejiaBin1:
lda #$0200 : tsb $12
cop #$C0 : dw .OnInteract
cop #$0B
cop #$C1
rtl
.OnInteract:
cop #$D0 : db $54,$01 : dw .GotItemAlready
%MTryGiveItemAndFlag("FrejBin1Item", $54)
.GotItemAlready:
rtl
}

org $85d223
db $1a : dw $1000
EMineSam:
lda #$0200 : tsb $12
cop #$0B
lda.l Config_KaraLocation : cmp #$0002 : beq .ChainCut   ; Kara in mine = no chain to cut
.KaraNotInMine:
cop #$80 : db $28   ; Use slave sprite
cop #$89
cop #$9C : dl $85D49E : dw $0100   ; Spawn and await slave chain
cop #$C0 : dw $d299    ; i.e. EMineSam_DemandCutChain
cop #$C1
ldy $06
lda $0010,y : bit #$0040 : bne .ChainCut
rtl
.ChainCut:
cop #$C0 : dw .TryGiveItem
cop #$C1
rtl
.TryGiveItem:
cop #$D0 : db $5e,$01 : dw ..AlreadyGiven
%MTryGiveItemAndFlag("MineSamItem", $5e)
rtl
..AlreadyGiven:
cop #$BF : dw $d48e   ; "I'll always remember you!"
rtl
warnpc $85d299

org $85d4d0
EMorgueItemPickup_OnInteract:
cop #$D0 : db $5d,$01 : dw .GotItemAlready
%MTryGiveItemAndFlag("MineMorgueItem", $5d)
rtl
.GotItemAlready:
cop #$E0

org $85d62d
; Allow Mine DS to contain an ability.
cop #$9C : dl $88d6ac : dw $2b00
lda $0e : sta $24
lda #$2000 : sta $0e
cop #$C2
cop #$E0

org $85d736
db $00 : dw $0100
EMineBreakableWallOverSlave:
{
cop #$D0 : db $d9,$01 : dw .DoDisappear
cop #$9C : dl EMineBreakableWallSlave : dw $1000
;...
org $85d796
; Caved-in wall broken, drawing the open-wall tiles
cop #$CC : db $05   ; Use temp flag instead of item flag to trigger item event.
.DoDisappear:
cop #$4B : db $08,$11,$d5
cop #$4B : db $09,$11,$d4
cop #$4B : db $08,$12,$ec
cop #$4B : db $09,$12,$dc
cop #$0F : db $08,$12     ; More solid tiles added, and made solid earlier, to fix a bug where
cop #$4B : db $08,$13,$f4 ; Will can slide through a newly-drawn tile while other tiles are
cop #$0F : db $09,$12     ; waiting to be drawn.
cop #$4B : db $09,$13,$e4
cop #$0F : db $08,$13
cop #$4B : db $08,$14,$02 
cop #$0F : db $09,$13
cop #$4B : db $09,$14,$02
cop #$E0
EMineBreakableWallSlave:
cop #$BC : db $08,$00
lda #$2000 : tsb $10
cop #$80 : db $0c
cop #$89
cop #$D2 : db $05,$01
lda #$2000 : trb $10
lda #$eff0 : tsb $065a
cop #$DA : db $77
cop #$CE : db $00
EMineWallSlave_TryGiveItem:
%MTryGiveItemAndFlag("MineWallSlaveItem", $d9)
lda #$EFF0 : trb $065A
cop #$D0 : db $d9,$00 : dw EMineWallSlave_InvWasFull
lda #$0080 : tsb $09EC
cop #$86 : db $0D, $08, $01
cop #$8A
lda #$0080 : trb $09EC
cop #$E0
EMineWallSlave_InvWasFull:
lda #$0200 : tsb $12
cop #$C0 : dw EMineWallSlave_TryGiveItem
cop #$C1
rtl
}
warnpc $85d89a
org $85d89a
; Neil in his cottage
{
db $13 : dw $1000
ENeilInCottage:
cop #$0B
cop #$C0 : dw .OnInteract
cop #$C1
rtl
.OnInteract:
cop #$D0 : db $15,$01 : dw .OfferTravel
cop #$D0 : db $14,$01 : dw .FirstTravel
cop #$BF : dw .TextCantTravel
rtl
.FirstTravel:
cop #$CC : db $15
cop #$BF : dw .TextFirstTravel
.OfferTravel:
cop #$BF : dw .TextOfferTravel
cop #$BE : db $53,$01 : dw ..Options
..Options:
  dw .Cancel
  dw .Cancel, .ToEuro
  dw .ToDao, .ToNeils
  dw .ToBabel
.Cancel:
cop #$BF : dw .TextDeclineTravel
rtl
.ToEuro:
cop #$26 : db $95 : dw $0260,$0080 : db $03,$01,$13
rtl
.ToDao:
cop #$26 : db $C8 : dw $0078,$00C0 : db $00,$00,$11
rtl
.ToNeils:
cop #$26 : db $49 : dw $0088,$00C0 : db $00,$00,$11
rtl
.ToBabel:
cop #$26 : db $DE : dw $0078,$00C0 : db $00,$00,$11
rtl
.TextCantTravel:
db $C2,$0A
db $C2,$06
db $cd : dl TextNeilCantTravel
db $c0
.TextFirstTravel:
db $C2,$0A
db $C2,$06
db "Neil: Hey, I remember how",$cb
db "to pilot my plane! Thanks",$cb
db "a lot!"
db $C0
.TextOfferTravel:
db $D3
db $C2,$06
db $cd : dl TextNeilOfferTravel
db $CA
.TextDeclineTravel:
db $CE
db $C2,$06
db "I travel pretty regularly",$CB
db "between my place, Euro,",$CB
db "and Dao. Come visit me",$CB
db "anytime!"
db $C0
}


org $85e647
; Nazca teleporter + world map exit listener
{
db $00 : dw $3000
ENazcaTeleporterTile:
cop #$9C : dl $85e7d0 : dw $2000    ; World map exit listener 
cop #$C0 : dw .OnInteract
cop #$D2 : db $0f,$01
lda #$eff0 : tsb $065a
lda #$00e0 : sta $7f0010,x
cop #$CA : db $08
lda $7f0010,x
  sep #$20
    sta $2132
  rep #$20
  inc : sta $7f0010,x
cop #$DA : db $01
cop #$CB
cop #$9C : dl $85e7a6 : dw $0300    ; Vanishes Will's sprite 
cop #$DA : db $3b
lda #$0404 : sta $064a
cop #$26 : db !MapGardenEntranceString ; $4c : dw $0168,$0040 : db $83,$00,$22
cop #$C1
rtl
.OnInteract:
cop #$BF : dw .TextOfferWarp
cop #$BE : db $02,$01 : dw ..Options
..Options:
  dw ..ChooseNo
  dw ..ChooseYes,..ChooseNo
..ChooseNo:
cop #$BF : dw .TextRefusedWarp
rtl
..ChooseYes:
cop #$CC : db $0f
cop #$BF : dw .TextAcceptedWarp
rtl
table "table_dialogue.txt",rtl
.TextOfferWarp:
db $d3
db "Warp to Sky Garden?",$cb
db "_Yes",$cb
db "_No"
db $ca
.TextRefusedWarp:
db $ce
db "Well, okay."
db $c0
.TextAcceptedWarp:
db $ce
db $ca
}

org $85e80c
; Nazca exit to world map at edges.
cop #$66 : dw $0310,$0290 : db !OverworldShuffleNzcaMenuId
cop #$C1
rtl

; Animate a Moon Tribe sprite to show the warp point 
org $85f2ef
db $32 : dw $0300
EMoonTribeIdle:
lda #$0200 : tsb $12
-:
cop #$80 : db $32
cop #$89
bra -

org $85f356
; Sky Garden spirits and exit portal.
{
db $3c : dw $1000
ESGMoonTribe:
lda #$0200 : tsb $12
cop #$D0 : db $2a,$01 : dw .NotDead
cop #$E0
.NotDead:
cop #$C0 : dw .OnInteract
cop #$0B
cop #$C1
cop #$80 : db $3C : cop #$89
rtl
.OnInteract:
cop #$BF : dw Text_NazcaOfferTravel
cop #$BE : db $32,$01 : dw ..Options
..Options:
  dw .Cancel
  dw .Cancel, .ToSeaPalace
  dw .ToMoonTribe
.Cancel:
cop #$BF : dw Text_NazcaDeclineTravel
rtl
.ToNazca:
cop #$26 : db $4b : dw $0120,$0080 : db $00,$00,$44
stz $0ad4
rtl
.ToMoonTribe:
cop #$26 : db $1a : dw $0110,$00d0 : db $03,$00,$22
stz $0ad4
rtl
.ToSeaPalace:
cop #$26 : db $5a : dw $0090,$0070 : db $83,$00,$14
stz $0ad4
rtl

Text_NazcaDeclineTravel:
db $CE
db "Ku ku ku..."
db $C0
Text_NazcaOfferTravel:
db $D3
db "Where'd you like to go?",$cb
db "_Quit________Moon Tribe",$cb
db "_Sea Palace"
db $CA

db $00 : dw $3000
ESGExitPortal:
cop #$45 : db $15,$03,$18,$05 : dw .PlayerInArea
rtl
.PlayerInArea:
cop #$40 : dw $0800 : dw .DoPort
rtl
.DoPort:
cop #$26 : db !MapGardenExitString
cop #$C1
rtl
}
warnpc $85f45e


; Move the memory block used by the spotlight, so it doesn't interfere with other effects
if !SettingDarkRoomsLevel != 0
org $85fb4d
dl $7ef000
org $85fb54
dl $7ef100
org $85fe64
lda #$f600 : sta $0000
lda #$f000 : sta $0002
lda #$00ff : sta $7ef200
lda #$f200 : sta $04
clc
rts
;org $85fe7e
lda #$fa00 : sta $0000
lda #$f100 : sta $0002
lda #$00ff : sta $7ef200
lda #$f200 : sta $04
clc
rts
endif


org $85fed2
; Bank $85 free space begins here
TurboOnInteract:
{
cop #$CC : db $01
cop #$D0 : db $11,$01 : dw .CanTravel
.NoTravel:
cop #$BF : dw .TextNoTravel
rtl
.CanTravel:
cop #$D0 : db $12,$01 : dw .OfferTravel
..FirstTravel:
cop #$CC : db $12
cop #$BF : dw .TextFirstTravel
.OfferTravel:
jml EErikInCapeCave_AskWhere
.TextNoTravel:
db $d3
db "Woof woof!",$cb
db "(You don't happen to",$cb
db "know Morse Code, do you?)",$c0
.TextFirstTravel:
db $d3
db "Woof woof!",$cb
db "(Oh good, you know Morse",$cb
db "Code. Let's see what",$cb
db "Seth's up to!)",$c0
}

}



; Bank $86
{
org $8686fa
db $10   ; Lilly at Seaside Palace flag

org $868af5
%MTryGiveItemAndFlag("SeaPalBuffyItem", $85)
rtl


org $868feb
db $00 : dw $3002
ESeaPLillyAtRightCoffin:   ; Had to rewrite this to make the spoiler re-readable.
{
cop #$BC : db $08, $00
cop #$C0 : dw .OnInteract
cop #$D2 : db $01, $01
lda #$CFF0 : tsb $065A
lda #$2000 : trb $10
cop #$88 : dl $8EE000
lda $1014 : sta $14
lda $1016 : sec : sbc #$0010 : sta $16
cop #$85 : db $33, $04, $14
cop #$8A
cop #$84 : db $33, $04
cop #$8A
lda #$0300 : sta $7F0018,x
lda #$009C : sta $7F001A,x
cop #$22 : db $33, $01
lda #$2000 : tsb $10
cop #$DA : db $3B
cop #$32 : db $3A
cop #$33
cop #$CD : dw $013A
cop #$DA : db $3B
lda #$0300 : sta $14
lda #$00A0 : sta $16
lda #$2000 : trb $10
cop #$BF : dw .TextSpoiler
cop #$84 : db $33, $04
cop #$8A
lda $1014 : sta $7F0018,x
lda $1016 : sec : sbc #$0010 : sta $7F001A,x
cop #$22 : db $33, $01
lda #$2000 : tsb $10
lda #$CFF0 : trb $065A
cop #$CE : db $01
cop #$25 : db $2f,$0a
rtl
.OnInteract:
cop #$D1 : dw $013a : db $01 : dw ..CoffinAlreadyOpen
cop #$D0 : db $6f, $01 : dw ..WithLilly
..NoLilly:
cop #$BF : dw .TextNoLilly
rtl
..CoffinAlreadyOpen:
cop #$BF : dw .TextSpoiler
rtl
..WithLilly:
cop #$BF : dw .TextWithLilly
cop #$CC : db $01
rtl
.TextNoLilly:
db $d3
db $cd : dl TextSeaPalaceRightCoffinNoLilly
db $c0
warnpc $8690cf
org $8690cf
.TextWithLilly:
org $869167
.TextSpoiler:
db $d3
db "!SpoilerTextSeaPalCoffin"
db $c0
}
warnpc $8691ac
org $8691AC
db $00 : dw $3002
ESeaPLillyAtLeftCoffin:    ; Had to rewrite this to handle two-byte item IDs.
{
cop #$D1 : dw $013B : db $01 : dw .CoffinOpenDoDie
cop #$BC : db $08, $00
cop #$C0 : dw .OnInteract
.AwaitInteractWithLilly:
cop #$D2 : db $02, $01
lda #$CFF0 : tsb $065A
lda #$2000 : trb $10
cop #$88 : dl $8EE000
lda $1014 : sta $14
lda $1016 : sec : sbc #$0010 : sta $16
cop #$85 : db $33, $04, $14
cop #$8A
cop #$84 : db $33, $04
cop #$8A
lda #$02C0 : sta $7F0018,x
lda #$009C : sta $7F001A,x
cop #$22 : db $33, $01
lda #$2000 : tsb $10
cop #$DA : db $3B
cop #$32 : db $3B
cop #$33
cop #$CD : dw $013B
cop #$DA : db $3B
lda #$00A0 : sta $16
lda #$2000 : trb $10
%MTryGiveItemAndFlag("SeaPalCoffinItem", $13)    ; Surrogate flag $13 for this item.
cop #$D0 : db $13,$00 : dw .CancelItemGet
cop #$DA : db $03
lda #$CFF0 : tsb $065A
cop #$84 : db $33, $04
cop #$8A
lda $1014 : sta $7F0018,x
lda $1016 : sec : sbc #$0010 : sta $7F001A,x
cop #$22 : db $33, $01
lda #$2000 : tsb $10
lda #$CFF0 : trb $065A
.CoffinOpenDoDie:
cop #$E0
.CancelItemGet:
cop #$CF : dw $013B
cop #$CE : db $02
cop #$84 : db $33, $04
cop #$8A
lda $1014 : sta $7F0018,x
lda $1016 : sec : sbc #$0010 : sta $7F001A,x
cop #$22 : db $33, $01
lda #$2000 : tsb $10
lda #$CFF0 : trb $065A
cop #$25 : db $2B, $0A
jmp .AwaitInteractWithLilly
.OnInteract:
cop #$D0 : db $6f,$01 : dw ..WithLilly
cop #$BF : dw .TextOnInteract
rtl
..WithLilly:
cop #$BF : dw $930a
cop #$CC : db $02
rtl
warnpc $8692e2
padbyte $ff
pad $8692e2
.TextOnInteract:
}


org $869406
db $10    ; Lilly at Seaside Palace flag

; Speed up Fountain sequence and remove some yapping
org $869418
cop #$DA : db $01
nop : nop : nop : nop
org $869450
db $20
org $869456
db $04
org $86945d
db $01
org $86946f
db $03
org $869486
bra $10

org $869739
; Unused Lilly actor in Mu corridor is replaced with this Palace door/key listener
{
cop #$45 : db $37,$0c, $39,$0e : dw +
  rtl
+:
cop #$D1 : dw $0138 : db $01 : dw ++
cop #$D6 : db $10 : dw +
cop #$E0
+:
cop #$CD : dw $0138
cop #$D5 : db $10
++:
cop #$26 : db !Map5EExit03
cop #$C5
}
warnpc $8697a6

org $8698b2
%MTryGiveItemAndFlag("MuHopeStatue1Item", $79)
rtl

org $86995a
%MTryGiveItemAndFlag("MuHopeStatue2Item", $7f)
rtl

org $8699c7
db $0e : dw $3000
EMuHopeRoomListener:   ; Speed this along for QoL.
{
EMuHopeRoomFlame = $869c14
EMuHopeRoomWizard = $869BDA

cop #$45 : db $10, $00, $20, $10 : dw EMuHopeRoomListenerRight
EMuHopeRoomListenerLeft:
cop #$D1 : dw $02b0 : db $01 : dw .StatueAlreadyPlaced
cop #$D3 : dw $02b0 : db $01
cop #$A0 : dl EMuHopeRoomStatueSprite : dw $0080, $0058, $1000
jsl LR_LowerMuWaterOneStep
lda #$CFF0 : tsb $065A
cop #$DA : db $0F
cop #$04 : db $1B
cop #$DA : db $10
cop #$3C : dl $80B7E2
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0020, $00C0, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $00E0, $00C0, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0040, $0090, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $00C0, $0090, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0070, $0070, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0090, $0070, $1800
cop #$DA : db $3B
cop #$A0 : dl EMuHopeRoomWizard : dw $0050, $00C8, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomWizard : dw $0070, $00C8, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomWizard : dw $0090, $00C8, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomWizard : dw $00B0, $00C8, $1800
cop #$DA : db $77
cop #$BF : dw TextMuHopeRoomWizard
cop #$08 : db $25, $25
cop #$DA : db $10
cop #$CC : db $02
cop #$DA : db $10
cop #$3C : dl $80B7EC
cop #$DA : db $10
stz $0688
lda #$CFF0 : trb $065A
cop #$E0
.StatueAlreadyPlaced:
cop #$A0 : dl EMuHopeRoomStatueSprite : dw $0080, $0058, $1000
cop #$E0

EMuHopeRoomStatueSprite:
cop #$80 : db $30
cop #$89
rtl

EMuHopeRoomListenerRight:
cop #$D1 : dw $02b1 : db $01 : dw .StatueAlreadyPlaced
cop #$D3 : dw $02b1 : db $01
cop #$A0 : dl EMuHopeRoomStatueSprite : dw $0180, $0058, $1000
jsl LR_LowerMuWaterOneStep
lda #$CFF0 : tsb $065A
cop #$DA : db $0F
cop #$04 : db $1B
cop #$DA : db $10
cop #$3C : dl $80B7E2
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0120, $00C0, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $01E0, $00C0, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0140, $0090, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $01C0, $0090, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0170, $0070, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomFlame : dw $0190, $0070, $1800
cop #$DA : db $3B
cop #$A0 : dl EMuHopeRoomWizard : dw $0150, $00C8, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomWizard : dw $0170, $00C8, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomWizard : dw $0190, $00C8, $1800
cop #$DA : db $10
cop #$A0 : dl EMuHopeRoomWizard : dw $01B0, $00C8, $1800
cop #$DA : db $77
cop #$BF : dw TextMuHopeRoomWizard
cop #$08 : db $25, $25
cop #$DA : db $10
cop #$CC : db $02
cop #$DA : db $10
cop #$3C : dl $80B7EC
cop #$DA : db $10
stz $0688
lda #$CFF0 : trb $065A
cop #$E0
.StatueAlreadyPlaced:
cop #$A0 : dl EMuHopeRoomStatueSprite : dw $0180, $0058, $1000
cop #$E0

TextMuHopeRoomWizard:
db $d3 : db "Hey." : db $c0    ; Hope Room text
}
warnpc $869BDA

org $869c60
cop #$26 : db !MapVampEntranceString    ; Rama Statue placement warps you to a boss room

; Reduce Rama's yapping and don't have spirits set any flags
{
org $869e50
db $10
org $869f26
db $00
org $86a07a
nop : nop : nop
org $86a082
nop : nop : nop
org $86a08a
nop : nop : nop
org $86a092
nop : nop : nop
org $86a09a
nop : nop : nop
org $86a0a2
nop : nop : nop
}

org $86a43b
jsl LR_ForceChangeToWill    ; After vamps.
cop #$C1
lda $09AE : bit #$0800 : beq +
  rtl
+:
jmp $a466    ; the above code is shorter than what it replaces; this jmp is instead of padding with nops

org $86a4c9
cop #$26 : db $66 : dw $00f8,$01d8 : db $00,$00,$22   ; Interacting with the Vamp bomb takes you to Statue chamber
cop #$C1
rtl

org $86ba36
; Angel Village sign text
{
db $d3
db $cd : dl TextAngelVillageSign
db $c0
}

org $86bff7
; Clear monster killed flags and force change to Will in Angel's exterior.
db $00 : dw $3000
jsl LR_ClearMonsterKilledFlags
jsl LR_ForceChangeToWill
cop #$E0

org $86cede
stz $0aa6    ; Ishtar's game never closes.
rtl

org $86cef6
; Ishtar's dialogue.
db "Again!"
db $c0

org $86d14e
db $16 : dw $1000
EKarasPortrait:
lda $0644 : pha
lda.l Config_KaraLocation : dec : beq .OnlyInEdDg
  dec : beq .OnlyInMine
  dec : beq .OnlyInAngl
  dec : beq .OnlyInKres
.OnlyInAnkr:
pla : cmp #$00bf : bne .Die
bra .MapOkay
.OnlyInEdDg:
pla : cmp #$0013 : bne .Die
bra .MapOkay
.OnlyInMine:
pla : cmp #$0047 : bne .Die
bra .MapOkay
.OnlyInAngl:
pla : cmp #$0074 : bne .Die
bra .MapOkay
.OnlyInKres:
pla : cmp #$00a9 : bne .Die
;bra .MapOkay
.MapOkay:
cop #$D0 : db $8a,$01 : dw .Die
cop #$BC : db $08,$fd
cop #$B6 : db $30  ; Portrait sprite needs high priority in non-Angl, and this is harmless in Angl.
cop #$9E : dl EKaraPortraitInteractor : dw $0000, $0010, $3000
cop #$D2 : db $8a,$01
.Die:
cop #$E0
EKaraPortraitInteractor:
cop #$C0 : dw .OnInteract
cop #$C1
rtl
.OnInteract:
cop #$D0 : db $8a,$01 : dw ..KaraIsFree
..KaraNotFree:
cop #$BF : dw ...Text
rtl
...Text:
db $c2 : db $0a
db $c2 : db $00
db $d2 : db $10
db "Kara's portrait. If only",$cb
db "you had Magic Dust..."
db $c0
..KaraIsFree:
cop #$BF : dw ...Text
rtl
...Text:
db $c2 : db $0a
db $c2 : db $00
db $d2 : db $10
db "Hurry boy, she's waiting",$cb
db "there for you!"
db $c0
warnpc $86d278


org $86d792
; This line of EAVIshtarDoorManager clears the BG1 cache, to reload door graphics.
; My code relies on the tilemap not being reloaded when entering a puzzle room.
; So, I nop out this line, and have EAVIshtarPuzzleManager clear the cache if the player's in a puzzle room.
nop : nop : nop   ; replaces stz $067f

org $86D8BC
db $00 : dw $3000
EAVIshtarPuzzleManager:
; Mod this to reset Ishtar's puzzle upon re-entry.
; In the puzzle map, rooms have Y < $100 and the corridor has Y > $100.
lda $09A4 : cmp #$00F0 : bcc ++
  ; Player spawned in the corridor
  cop #$48 : dec : bne +
    stz $0aa6   ; Spawned facing north, so entered from outside -> do reset
  +:
  jsr SR_DrawIshtarMapDifferences
  cop #$E0   ; Puzzle manager isn't otherwise needed in the corridor
++:
; If we get here, the player spawned in a puzzle room. Close all the doors from the corridor.
; This line is equivalent to cop #$CF for all flags from $0149 to $0150, but more compact.
lda $0a29 : and #$fe01 : sta $0a29
stz $067f   ; Clear BG1 tilemap cache
jmp $d8ea   ; where EAVIshtarPuzzleManager picks up after our mods
warnpc $86d8ea

org $86d95e
jsr SR_SecIfIshtarCursorAtDifference : bcc +
  cop #$BF : dw $db2c    ; Puzzles 1-3 have the same success text
  inc $0aa6
  jmp $da0c
+:
cop #$BF : dw $daa0   ; And the same failure text
jmp $da07

org $86d98a
jsr SR_SecIfIshtarCursorAtDifference : bcc +
  cop #$BF : dw $db2c    ; Puzzles 1-3 have the same success text
  inc $0aa6
  jmp $da0c
+:
cop #$BF : dw $daa0   ; And the same failure text
jmp $da07

org $86d9b4
jsr SR_SecIfIshtarCursorAtDifference : bcc +
  cop #$BF : dw $db2c    ; Puzzles 1-3 have the same success text
  inc $0aa6
  jmp $da0c
+:
cop #$BF : dw $daa0   ; And the same failure text
jmp $da07

org $86d9de
jsr SR_SecIfIshtarCursorAtDifference : bcc +
  cop #$BF : dw $db9f
  cop #$CD : dw $0151
  jmp $da0c
+:
cop #$BF : dw $daa0
jmp $da07
warnpc $86da07

org $86db9f
; Skip ahead in Ishtar's room 4 puzzle text
db $c2,$0a
db "You have passed my",$cb
db "test well.",$cb
db "You may return."
db $c0

org $86dc50
; The Ishtar's-Apprentice actor also creates wind for Will's hair, if applicable
db $04 : dw $1000
EAVIshtarsApprentice:
jsr SR_SecIfThisIshtarRoomHasWind : bcs .EnableWind
bra .CheckIfFirstPhase
nop : nop : nop
.EnableWind:
cop #$CC : db $00
lda #$0011 : sta $1028   ; Changed to set Will's sprite instead of force him to run weirdly for one frame
.CheckIfFirstPhase:    ; this is $86dc66

org $86dc97
db $d3
db "!SpoilerTextIshtarsApprentice"
db $c0

org $86dcd8
; Bank $86 free space begins here.

; Item collection tracker in map room.
{
TextItemCounterDisplay:
table "table_dialogue.txt",rtl
db $D3
db "__Item Checks:_"
db $C6 : dw $0002, $00f0
db "/"
db $C6 : dw $0002, $00f2
db $CB
if !SettingOrbRando > 0
db "_Monster Orbs:_"
db $C6 : dw $0002, $00f4
db "/"
db $C6 : dw $0002, $00f6
db $CB
endif
db "__Dark Spaces:_"
db $C6 : dw $0002, $00f8
db "/"
db $C6 : dw $0002, $00fa
db $C0

; Format is:
; db <flags with high byte $00: normal items>
; db $ff
; db <flags with high byte $02: chests are $01-$2E, RJs are $80-$8f>
; db $ff
; db <monster orb numbers, $01 - $2A>
; db $ff
; db <DS indices; at time of writing these are offsets from flag $09a0>
; db $ff
Lut_TrackerItemFlagsByArea:
.Pointers:
{
dw .Cape
dw .EdDg
dw .Itry
dw .Moon
dw .Inca
dw .Coast
dw .Frej
dw .Mine
dw .Neil
dw .SkGn
dw .SeaP
dw .Mu
dw .Angl
dw .Wtma
dw .GtWl
dw .Euro
dw .Kres
dw .NtVl
dw .Ankr
dw .Dao
dw .Pymd
dw .Babl
dw .Mnsn
dw .Jwlr   ; Artificial
dw $ffff
}
{
.Cape:
db $35,$d7
db $ff
db $80,$81
db $ff
db $ff
db $00
db $ff
.EdDg:
db $23,$46,$d8
db $ff
db $01,$02,$03,$82
db $ff
db $01,$02,$03,$04,$05,$06,$07
db $ff
db $01,$02
db $ff
.Itry:
db $2d
db $ff
db $83
db $ff
db $ff
db $03
db $ff
.Moon:
db $48
db $ff
db $ff
db $ff
db $ff
.Inca:
db $32,$e0
db $ff
db $04,$05,$06,$07
db $ff
db $08,$09,$0a,$0b,$0c,$0d,$0e
db $ff
db $04,$05,$06
db $ff
.Coast:
db $ff
db $84
db $ff
db $ff
db $ff
.Frej:
db $53,$54,$5a,$e1
db $ff
db $85
db $ff
db $ff
db $07
db $ff
.Mine:
db $5d,$5e,$a2,$a3,$d9
db $ff
db $09
db $ff
db $0f,$10,$11,$12,$13,$14
db $ff
db $08,$09,$0a
db $ff
.Neil:
db $ff
db $ff
db $ff
db $ff
.SkGn:
db $ff
db $0a,$0b,$0c,$0d,$0e,$0f,$10,$11
db $ff
db $15,$16,$17,$18,$19,$1a
db $ff
db $0b,$0c,$0d,$0e
db $ff
.SeaP:
db $13,$85
db $ff
db $12,$13,$14
db $ff
db $ff
db $0f
db $ff
.Mu:
db $79,$7f
db $ff
db $15,$16,$17,$18,$2e
db $ff
db $1b,$1c,$1d,$1e,$1f,$20
db $ff
db $10,$11
db $ff
.Angl:
db $ff
db $19,$1a,$1b,$1c,$86,$87
db $ff
db $ff
db $12
db $ff
.Wtma:
db $e2,$95
db $ff
db $88,$89
db $ff
db $ff
db $13
db $ff
.GtWl:
db $98,$99
db $ff
db $1d,$1e
db $ff
db $21
db $ff
db $14,$15,$16
db $ff
.Euro:
db $9a,$a6,$e5,$f0,$f1
db $ff
db $8a,$8b
db $ff
db $ff
db $17
db $ff
.Kres:
db $ff
db $1f,$20,$21,$22,$23
db $ff
db $23
db $ff
db $18,$19,$1a
db $ff
.NtVl:
db $e6
db $ff
db $8c
db $ff
db $ff
db $1b
db $ff
.Ankr:
db $ba,$be
db $ff
db $24,$25,$26,$27,$28
db $ff
db $24,$25,$27
db $ff
db $1c,$1d,$1e
db $ff
.Dao:
db $b8,$b8,$e7
db $ff
db $8d
db $ff
db $ff
db $1f
db $ff
.Pymd:
db $bd,$c2,$c3,$c4,$c5,$c6,$c7
db $ff
db $29,$2a,$2b,$2c,$8e
db $ff
db $28
db $ff
db $20,$21
db $ff
.Babl:
db $dc
db $ff
db $8f
db $ff
db $ff
db $22,$23
db $ff
.Mnsn:
db $ff
db $2d
db $ff
db $29,$2a
db $ff
db $ff
.Jwlr:
db $e9,$ea,$eb,$ec,$ed,$ee
db $ff
db $ff
db $ff
db $ff
}

db $00 : dw $3000
EInGameCollectionTracker:
stz $26
cop #$45 : db $0C,$39,$0E,$3B : dw .InSomeArea
inc $26
cop #$45 : db $0F,$32,$11,$34 : dw .InSomeArea
inc $26
cop #$45 : db $0B,$2A,$0D,$2C : dw .InSomeArea
inc $26
cop #$45 : db $08,$26,$0B,$28 : dw .InSomeArea
inc $26
cop #$45 : db $12,$27,$14,$29 : dw .InSomeArea
inc $26
cop #$45 : db $24,$34,$26,$36 : dw .InSomeArea
inc $26
cop #$45 : db $24,$2C,$26,$2E : dw .InSomeArea
inc $26
cop #$45 : db $32,$32,$34,$34 : dw .InSomeArea
inc $26
cop #$45 : db $26,$25,$28,$27 : dw .InSomeArea
inc $26
cop #$45 : db $2F,$28,$31,$2A : dw .InSomeArea
inc $26
cop #$45 : db $37,$08,$39,$0A : dw .InSomeArea
inc $26
cop #$45 : db $32,$07,$34,$09 : dw .InSomeArea
inc $26
cop #$45 : db $37,$15,$39,$17 : dw .InSomeArea
inc $26
cop #$45 : db $2C,$19,$2E,$1B : dw .InSomeArea
inc $26
cop #$45 : db $29,$11,$2B,$13 : dw .InSomeArea
inc $26
cop #$45 : db $1C,$12,$1E,$14 : dw .InSomeArea
inc $26
cop #$45 : db $20,$0C,$22,$0E : dw .InSomeArea
inc $26
cop #$45 : db $11,$19,$13,$1B : dw .InSomeArea
inc $26
cop #$45 : db $12,$14,$14,$16 : dw .InSomeArea
inc $26
cop #$45 : db $08,$10,$0A,$12 : dw .InSomeArea
inc $26
cop #$45 : db $06,$0A,$08,$0C : dw .InSomeArea
inc $26
cop #$45 : db $1F,$1F,$21,$21 : dw .InSomeArea
inc $26
cop #$45 : db 26,4, 28,6 : dw .InSomeArea   ; Jeweler's Mansion
.OutsideAreasClearFlags:
cop #$CE : db $02
.DoNothing:
rtl
.InSomeArea:
cop #$D0 : db $02,$01 : dw .DoNothing
cop #$CC : db $02
stz $00f0   ; Collected items
stz $00f2   ; Total items
stz $00f4   ; Collected orbs
stz $00f6   ; Total orbs
stz $00f8   ; Visited Dark Spaces
stz $00fa   ; Total Dark Spaces
lda $26 : jsl LR_AddCollectionForAreaA
cop #$BF : dw TextItemCounterDisplay
rtl

LR_AddCollectionForAreaA:
phx
asl : tax
lda.l Lut_TrackerItemFlagsByArea,x : tax
.CountNextLowFlag:
lda.l Lut_TrackerItemFlagsByArea&$ff0000,x : and #$00ff : cmp #$00ff : beq ..DoneCountingLowFlags
jsl LR_SecOnAnyFlagA : bcc ..PostCollectionCheck
  jsr SR_IncrementCollectedItems
..PostCollectionCheck:
jsr SR_IncrementTotalItems
inx
bra .CountNextLowFlag
..DoneCountingLowFlags:
inx
.CountNextHighFlag:
lda.l Lut_TrackerItemFlagsByArea&$ff0000,x : and #$00ff : cmp #$00ff : beq ..DoneCountingHighFlags
jsl LR_SecOnFlag20A : bcc ..PostCollectionCheck
  jsr SR_IncrementCollectedItems
..PostCollectionCheck:
jsr SR_IncrementTotalItems
inx
bra .CountNextHighFlag
..DoneCountingHighFlags:
inx
.CountNextOrbFlag:
lda.l Lut_TrackerItemFlagsByArea&$ff0000,x : and #$00ff : cmp #$00ff : beq ..DoneCountingOrbFlags
jsl LR_SecOnMonsterItemFlagA : bcc ..PostCollectionCheck
sed
  lda $00f4 : clc : adc #$0001 : sta $00f4
cld
..PostCollectionCheck:
sed
  lda $00f6 : clc : adc #$0001 : sta $00f6
cld
inx
bra .CountNextOrbFlag
..DoneCountingOrbFlags:
inx
.CountNextDarkSpace:
lda.l Lut_TrackerItemFlagsByArea&$ff0000,x : and #$00ff : cmp #$00ff : beq ..DoneCountingDarkSpaces
clc : adc #$09a0 : jsl LR_SecOnAnyFlagA : bcc ..PostCollectionCheck
sed
  lda $00f8 : clc : adc #$0001 : sta $00f8
cld
..PostCollectionCheck:
sed
  lda $00fa : clc : adc #$0001 : sta $00fa
cld
inx
bra .CountNextDarkSpace
..DoneCountingDarkSpaces:
plx
rtl

SR_IncrementCollectedItems:
sed
  lda $00f0 : clc : adc #$0001 : sta $00f0
cld
rts
SR_IncrementTotalItems:
sed
  lda $00f2 : clc : adc #$0001 : sta $00f2
cld
rts
}

SR_SecIfIshtarChestsAreDifferent:
lda.l Config_AnglPuzzleChest1Item : cmp.l Config_AnglPuzzleChest2Item : bne .AreDifferent
.NotDifferent:
clc
rts
.AreDifferent:
sec
rts

SR_GetIshtarRoomAddrOffsetForXPos:
and #$ff00 : xba : lsr : clc : asl : asl : asl
rts

SR_SecIfThisIshtarRoomHasWind:
phx
lda $1016 : cmp #$0100 : bcs .NoWind
lda $1014 : jsr SR_GetIshtarRoomAddrOffsetForXPos : tax
lda.l 4+Config_IshtarRoomDifferencesAnchor,x : beq .MaybeHasWind
lda.l 2+Config_IshtarRoomDifferencesAnchor,x : beq .HasWind
lda.l 0+Config_IshtarRoomDifferencesAnchor,x : beq .HasWind
.NoWind:
plx
clc
rts
.MaybeHasWind:
; Room difference is wind, so right room has wind, unless it's room 3 and the chests are different
lda $1014 : and #$0100 : beq .NoWind
lda $1014 : cmp #$0400 : bcc .HasWind
  cmp #$0600 : bcs .HasWind
jsr SR_SecIfIshtarChestsAreDifferent : bcs .NoWind
.HasWind:
plx
sec
rts

SR_SecIfIshtarCursorAtDifference:
{
; Room 3 (chests) is a special case
lda $24 : cmp #$0500 : bcc .NotInChestRoom
  cmp #$0600 : bcs .NotInChestRoom
.IsInChestRoom:
jsr SR_SecIfIshtarChestsAreDifferent : bcc .ChestRoomDifferenceNotChest
lda $24 : cmp #$0570 : bcc ..WrongAnswer
  cmp #$0590 : bcs ..WrongAnswer
lda $26 : cmp #$0070 : bcc ..WrongAnswer
  cmp #$0090 : bcs ..WrongAnswer
..RightAnswer:
sec
rts
..WrongAnswer:
clc
rts
.ChestRoomDifferenceNotChest:
.NotInChestRoom:
; If there's no difference between this tilemap and the left one, then the room's difference is Will's hair
phx
lda $24 : and #$ff00 : sec : sbc #$0100 : tax
ldy #$0000
sep #$20
-:
lda $7ea000,x : cmp #$f8 : bcs +   ; --but chest open vs. closed doesn't count as a difference
  cmp $7ea100,x : bne .DifferenceNotHair
+:
inx
iny
cpy #$0100 : bcc -
.DifferenceIsHair:
rep #$20
plx
; Hair target area is [PlayerX-$10, PlayerX+$10] x [PlayerY-$20, PlayerY]
lda $1014 : sec : sbc #$0010 : cmp $24 : bcs ..WrongAnswer
  clc : adc #$0020 : cmp $24 : bcc ..WrongAnswer
lda $1016 : cmp $26 : bcc ..WrongAnswer
  sec : sbc #$0020 : cmp $26 : bcs ..WrongAnswer
..RightAnswer:
sec
rts
..WrongAnswer:
clc
rts
.DifferenceNotHair:
rep #$20
lda $24 : dec : dec : lsr : lsr : lsr : lsr : sta $0018
lda $26 : dec : dec : lsr : lsr : lsr : lsr : sta $001c
lda #$0000 : tax : tcd
jsl $82B0A3   ; = jsl LR_GetTileTableIndex82; returns index in X
txa : sec : sbc #$0100 : tax
sep #$20
  lda $7ea000,x : cmp #$f8 : bcs +    ; Chest open vs. closed doesn't count as a difference
    cmp $7ea100,x
    bra ++
+:
lda #$00
++:
rep #$20
bne ..RightAnswer
..WrongAnswer:
plx
txa : tcd
clc
rts
..RightAnswer:
plx
txa : tcd
sec
rts
}

SR_DrawIshtarMapDifferences:
; First overwrite the right-room tilemaps to be the same as the left
{
phx
ldx #$0000
ldy #$0000
sep #$20
-:
lda $7ea000,x : cmp #$f8 : bcs +   ; (but don't overwrite chest tiles)
  sta $7ea100,x
+:
inx
iny
cpy #$0100 : bcc -
ldy #$0000
rep #$20
txa : clc : adc #$0100 : tax
sep #$20
cpx #$0600 : bcc -
rep #$20
; Then draw indexed differences on the tilemaps
lda #$0000 : tcd
lda #$0002 : pha   ; $01,s = difference index less 1 (=2,1,0; 0 = DifferenceIndex1 is drawn last to ensure its effect isn't overwritten)
lda #$0000 : pha   ; $01,s = room index (0,1,2,3); $03,s = DifferenceIndex
.DrawNextRoom:
lda $01,s : asl : tax
lda.l .TablePointers,x : pha   ; $01,s = #.TableRoomN; $03,s = room index; $05,s = DifferenceIndex
lda $03,s : asl : xba : clc : adc #$0080 : jsr SR_GetIshtarRoomAddrOffsetForXPos : tax
phx   ; $01,s = base offset from DifferencesAnchor for this room; $03,s = #.TableRoomN; $05,s = room index; $07,s = DifferenceIndex
.MaybeDrawNextDifferenceIndex:   ; Here X = $01,s should be DifferenceIndexM - DifferencesAnchor; $03,s = #.TableRoomN; $05,s = room index; $07,s = DifferenceIndex.
lda $07,s : bpl +
  jmp .PrepNextRoom              ; All DifferenceIndexes have been drawn or skipped
+:
lda.l Config_IshtarRoomDifferencesAnchor,x
  bmi ..SkipDifferenceIndex      ; $FFFF is skipped
  beq ..SkipDifferenceIndex      ; Wind is skipped, being handled elsewhere because it's not a tile draw
lda $05,s : cmp #$0002 : bne ..UseDifferenceIndex    ; Room 3 (only) skips index 1 (only), if the chests are different
lda $07,s : bne ..UseDifferenceIndex
jsr SR_SecIfIshtarChestsAreDifferent : bcc ..UseDifferenceIndex
..SkipDifferenceIndex:
  jmp .PrepNextDiff
..UseDifferenceIndex:
lda.l Config_IshtarRoomDifferencesAnchor,x : asl : clc : adc $03,s : tax   ; X = #.TableRoomN + 2 * DifferenceIndex
lda.l $ff0000&SR_DrawIshtarMapDifferences,x : tax   ; X = #.TableRoomN_IndexM
..DrawNextTile:
lda.l $ff0000&SR_DrawIshtarMapDifferences,x : and #$00ff : cmp #$00ff : beq .PrepNextDiff
  sta $18
inx
lda.l $ff0000&SR_DrawIshtarMapDifferences,x : and #$00ff : sta $1c
inx
lda.l $ff0000&SR_DrawIshtarMapDifferences,x : and #$00ff : pha   ; the stack shifts for a few lines here
inx
lda $07,s : asl : xba : lsr : lsr : lsr : lsr : clc : adc $18 : sta $18
phx   ; X = addr of next line of #.TableRoomN_IndexM
ldx #$0000
jsl $82B0A3   ; = jsl LR_GetTileTableIndex82; returns index in X
ply   ; Y = addr of next line of #.TableRoomN_IndexM
pla   ; A = tile type to draw; the stack is back to normal now
sep #$20
  sta $7ea100,x   ; Update MapLayer
  phx
    tax
    lda $7f0000,x
  plx
  sta $7fc100,x   ; Update CollisionLayer
  lda $07,s : beq +
    lda $7ea100,x : sta $7ea000,x   ; DifferenceIndexes above 1 are drawn in both sides of the room
    lda $7fc100,x : sta $7fc000,x
+:
rep #$20
tyx
bra ..DrawNextTile
.PrepNextRoom:
lda #$0002 : sta $07,s   ; Next DifferenceIndex will be 3 again
pla   ; Discard the DifferenceIndexM offset for this room
pla   ; Discard #.TableRoomN
pla : inc : cmp #$0004 : bcs .Done
  pha   ; Update room index
jmp .DrawNextRoom
.PrepNextDiff:
lda $01,s : inc : inc : sta $01,s   ; Advance the difference pointer
  tax
lda $07,s : dec : sta $07,s   ; "Advance" the DifferenceIndex identifier
jmp .MaybeDrawNextDifferenceIndex
.Done:
pla   ; Discard whether M>1
plx   ; Restore ActorID
txa : tcd
rts

.TablePointers:
dw .TableRoom1
dw .TableRoom2
dw .TableRoom3
dw .TableRoom4
.TableRoom1:
{
dw ..Index0
dw ..Index1
dw ..Index2
dw ..Index3
dw ..Index4
dw ..Index5
dw ..Index6
dw ..Index7
dw ..Index8
dw ..Index9
dw ..IndexA
..Index0:
db $ff
..Index1:
db $0b,$07,$7b
db $0b,$08,$84
db $ff
..Index2:
db $05,$07,$7b
db $05,$08,$84
db $ff
..Index3:
db $04,$07,$83
db $04,$08,$87
db $ff
..Index4:
db $05,$06,$74
db $ff
..Index5:
db $05,$06,$76
db $ff
..Index6:
db $06,$06,$75
db $ff
..Index7:
db $06,$06,$74
db $ff
..Index8:
db $07,$05,$12
db $08,$05,$12
db $07,$06,$1a
db $08,$06,$1a
db $ff
..Index9:
db $0a,$05,$12
db $0b,$05,$12
db $0a,$06,$1a
db $0b,$06,$1a
db $ff
..IndexA:
db $0a,$07,$83
db $0b,$07,$22
db $0a,$08,$87
db $0b,$08,$13
db $ff
}
.TableRoom2:
{
dw ..Index0
dw ..Index1
dw ..Index2
dw ..Index3
dw ..Index4
dw ..Index5
dw ..Index6
dw ..Index7
..Index0:
db $ff
..Index1:
db $03,$0a,$7c
db $03,$0b,$84
db $ff
..Index2:
db $04,$0a,$7c
db $04,$0b,$84
db $ff
..Index3:
db $0d,$0b,$73
db $ff
..Index4:
db $05,$09,$7d
db $06,$09,$7e
db $05,$0a,$85
db $06,$0a,$86
db $05,$0b,$8d
db $06,$0b,$8e
db $ff
..Index5:
db $07,$05,$88
db $08,$05,$89
db $07,$06,$90
db $08,$06,$91
db $ff
..Index6:
db $02,$0b,$77
db $ff
..Index7:
db $0d,$0b,$8f
db $ff
}
.TableRoom3:
{
dw ..Index0
dw ..Index1
dw ..Index2
dw ..Index3
dw ..Index4
..Index0:
db $ff
..Index1:
db $0d,$0b,$73
db $ff
..Index2:
db $02,$0b,$77
db $ff
..Index3:
db $07,$05,$88
db $08,$05,$89
db $07,$06,$90
db $08,$06,$91
db $ff
..Index4:
db $0d,$0b,$8f
db $ff
}
.TableRoom4:
{
dw ..Index0
dw ..Index1
dw ..Index2
dw ..Index3
dw ..Index4
dw ..Index5
dw ..Index6
dw ..Index7
dw ..Index8
dw ..Index9
..Index0:
db $ff
..Index1:
db $0d,$0b,$73
db $ff
..Index2:
db $02,$0b,$77
db $ff
..Index3:
db $02,$0b,$8f
db $ff
..Index4:
db $03,$0a,$7c
db $03,$0b,$84
db $ff
..Index5:
db $03,$0a,$7f
db $03,$0b,$87
db $ff
..Index6:
db $0c,$0a,$7c
db $0c,$0b,$84
db $ff
..Index7:
db $0c,$0a,$7f
db $0c,$0b,$87
db $ff
..Index8:
db $04,$0b,$69
db $05,$0b,$6a
db $ff
..Index9:
db $0d,$0b,$8f
db $ff
}
}

}



; Bank $87
{

org $878542   ; Part of a cop #$D0 that branches to Watermia NPCs.
dw SethWatermiaOnInteract   ; Seth travel NPC.
dw WatermiaToEuroNpcOnInteract   ; Travel to Euro NPC.


org $878569
WatermiaToEuroNpcOnInteract:
{
cop #$BF : dw TextWatermiaOfferKruks
cop #$BE : db $21,$03 : dw .Options
.Options:
  dw .SayNo, .SayNo, .SayYes
.SayNo:
cop #$BF : dw TextWatermiaDeclineKrukTravel
rtl
.SayYes:
cop #$D6 : db $18 : dw WatermiaToEuroDoTravel
cop #$D0 : db $1f,$01 : dw WatermiaToEuroDoTravel
.CantTravel:
cop #$BF : dw TextWatermiaCantKrukTravel
rtl
}

org $8786c1
; Text and travel code for for WatermiaToEuroNpcOnInteract
{
TextWatermiaOfferKruks:
db $D3
db $cd : dl TextWatermiaOfferTravel
db $CA
TextWatermiaDeclineKrukTravel:
db $CE
db "Come back anytime!"
db $C0
TextWatermiaCantKrukTravel:
db $CE
db "You don't seem to have",$cb
db "the proper papers..."
db $C0
WatermiaToEuroDoTravel:
cop #$CC : db $1f
cop #$D5 : db $18
cop #$26 : db $91 : dw $0330,$0430 : db $03,$00,$54
cop #$C5
}

org $878d76
db $10   ; Flag for Russian Glass opponent in his house

org $878d91
db $10   ; Flag for Russian Glass opponent in his house

org $879237
; russianglass.bin
{
cop #$D0 : db $95,$00 : dw RussianGlassTryGiveItem
cop #$BF : dw TextRussianGlassGotItemAlready
rtl
RussianGlassTryGiveItem:
cop #$BF : dw TextRussianGlassGreeting
%MTryGiveItemAndFlag("WtrmRussianGlassItem", $95)
rtl
TextRussianGlassGotItemAlready:
db $D3,$D6,$53,$80,$8B,$8B,$AC,$48,$AC,$86,$8E,$A4,$2B,$AC,$81,$A5,$83,$2A,$AC,$C0
TextRussianGlassGreeting:
db $D3,$63,$8E,$8C,$84,$AC,$86,$A5,$A9,$AC,$D6,$AE,$D6,$D6,$85,$8E,$A2,$AC,$CB
db $A9,$8E,$A5,$2A,$AC,$AC,$AC,$CF,$CA
}

org $879c81
db $d3
db "!SpoilerTextKarasJournal"
db $c0

org $879fb9
jsl LR_WatermiaLeafCheckPlayerPosition

org $879fe9
jsl LR_WatermiaLeafCheckPlayerPosition

org $87a871
db $e0,$6b    ; Disable Lilly in Watermia

org $87ad1b
nop : nop : nop : nop   ; "cop #$BF : dw $...." Skip Lance's speech.
%MTryGiveItemAndFlag("WtrmLanceItem", $e2)
rtl

org $87b59e
; Necklace stones.
{
db $02 : dw $1001
ENecklaceStone1:
cop #$D0 : db $98,$01 : dw .Die
lda #$0200 : tsb $12
cop #$88 : dl $8ee000
cop #$C0 : dw .OnInteract
-:
cop #$80 : db $02 : cop #$89
cop #$DA : db $3b
bra -
.OnInteract:
%MTryGiveItemAndFlag("GtWlNecklace1Item", $98)
cop #$D0 : db $98,$01 : dw .Die
rtl
.Die:
cop #$E0

db $02 : dw $1001
ENecklaceStone2:
cop #$D0 : db $99,$01 : dw .Die
lda #$0200 : tsb $12
cop #$88 : dl $8ee000
cop #$C0 : dw .OnInteract
-:
cop #$80 : db $02 : cop #$89
cop #$DA : db $3b
bra -
.OnInteract:
%MTryGiveItemAndFlag("GtWlNecklace2Item", $99)
cop #$D0 : db $99,$01 : dw .Die
rtl
.Die:
cop #$E0
}

org $87be09
cop #$A0 : dl $88d6ac : dw $01c8,$0280 : dw $2b00
lda $0e : sta $24
lda #$2000 : sta $0e
cop #$E0    ; Unsafe?

org $87c09b
db $c4    ; "Change pointer for cannibalized event"

org $87c0a7
cop #$D0 : db $9a,$01 : dw AppleVendorGotItemAlready
%MTryGiveItemAndFlag("EuroAppleVendorItem", $9a)
rtl
AppleVendorGotItemAlready:
cop #$BF : dw $c0dd
rtl

org $87c142
db $cd : dl TextEuroNoLongerInfected
db $c0

org $87c160
db $cd : dl TextEuroHovercraft
db $c0

org $87c182
db $cd : dl TextEuroHerring
db $c0

org $87c1b6
db $cd : dl TextEuroWaferThinMint
db $c0

org $87c1dc
db $cd : dl TextEuroMillClosed
db $c0

org $87c3d4
db $cd : dl TextEuroLooney
db $c0


org $87c432
; euro1.bin
{
dw $C45D 
dw $C449 
dw $C444 
dw $C444 
dw $C44E 
dw $C453 
dw $C458 
dw $C444 
dw $C444 

cop #$BF : dw $C482 
rtl
cop #$BF : dw $C4AA 
rtl
cop #$BF : dw $C56C 
rtl
cop #$BF : dw $C5AB 
rtl
cop #$BF : dw $C60A 
rtl

cop #$BF : dw Text_EuroOfferTravel
cop #$BE : db $21,$03 : dw EuroOfferTravelOptions
EuroOfferTravelOptions:
  dw .SayNo
  dw .SayNo, .SayYes
.SayNo:
cop #$BF : dw Text_EuroDeclineTravel
rtl
.SayYes:
cop #$D6 : db $18 : dw EuroFirstTravel
cop #$D0 : db $1f,$01 : dw EuroDoTravel
cop #$BF : dw Text_EuroCantTravel
rtl
}


org $87c482
db $cd : dl TextEuroMooseOnceBit
db $c0


org $87c4d0
; euro2.bin
{
EuroFirstTravel:
cop #$CC : db $1f
cop #$D5 : db $18
EuroDoTravel:
cop #$26 : db $78 : dw $0300,$0340 : db $03,$00,$45
cop #$C5

Text_EuroOfferTravel:
db $D3,$48,$AC,$A2,$A5,$8D,$AC,$A4,$87,$84,$AC,$A3,$A4,$80,$81,$8B,$84,$A3,$2A,$AC,$48,$AC,$82,$80,$8D,$CB
db $86,$84,$A4,$AC,$D6,$FE,$4A,$A2,$A5,$8A,$A3,$AC,$88,$85,$AC,$A9,$8E,$A5,$CB
db $D6,$F1,$A4,$8E,$AC,$86,$8E,$AC,$A4,$8E,$AC,$D7,$43,$CB
db $AC,$4D,$8E,$CC,$14,$69,$84,$A3,$CA
Text_EuroCantTravel:
db $CE,$69,$8E,$A5,$AC,$D6,$82,$D7,$9E,$A4,$8E,$AC,$D6,$98,$CB
db $A4,$87,$84,$AC,$A0,$A2,$8E,$A0,$84,$A2,$AC,$A0,$80,$A0,$84,$A2,$A3,$2A,$2A,$2A,$C0
Text_EuroDeclineTravel:
db $CE,$D6,$09,$D6,$73,$80,$8D,$A9,$A4,$88,$8C,$84,$4F,$C0
}

org $87c860
db $cd : dl TextEuroNobodyExpects
db $c0

org $87c9ff
; so5z commemorative tourney winner quote
db $d3
db "I'm telling you, man,",$cb
db "one-Shroom-Drop Kress",$cb
db "always works, I swear."
db $c0
warnpc $87ca65



org $87CB95
db $04 : dw $1000
EEuroShopExitNpc:
cop #$0B
cop #$C0 : dw .OnInteract
cop #$28 : db $70,$01, $d0,$00 : dw .PlayerEnteredThroughExit
cop #$C1
rtl
.PlayerEnteredThroughExit:
lda #$CFF0 : tsb $065a
cop #$81 : db $08,$02
cop #$89
cop #$80 : db $02
cop #$89
cop #$BF : dw ..TextGreeting
if !SettingTownShuffle > 0
cop #$BE : db $02,$01 : dw ..Options
..Options:
  dw ...ChooseNo
  dw ...ChooseNo, ...ChooseYes
...ChooseYes:
stz $0ad4
jsl LR_ClearMonsterKilledFlags
jsl LR_WarpToStart
cop #$C1
rtl
...ChooseNo:
cop #$BF : dw ..TextDeclinedWarp
endif
cop #$9C : dl EEuroShopPlayerPusher : dw $2000
cop #$82 : db $06, $01
cop #$89
cop #$80 : db $02
cop #$89
cop #$C1
rtl
..TextGreeting:
if !SettingTownShuffle == 0
db $cd : dl TextEuroPlayerEnteredShopExitNormal
db $c0
else
db $cd : dl TextEuroPlayerEnteredShopExitOfferWarp
db $ca
..TextDeclinedWarp:
db $cd : dl TextEuroPlayerEnteredShopExitAndDeclinedWarp
db $c0
endif

.OnInteract:
cop #$BF : dw ..Text
rtl
..Text:
db $cd : dl TextEuroShopExitNpcOnInteract
db $c0

EEuroShopPlayerPusher:
ldy $09aa
lda $0016,y : inc : sta $0016,y
rtl

warnpc $87CC39



org $87cd03
cop #$D0 : db $f0,$01 : dw ShopItem1Die
cop #$C0 : dw ShopItem1OnInteract
cop #$C1
rtl
ShopItem1OnInteract:
%MTryGiveItemAndFlag("EuroShop1Item", $f0)
cop #$D0 : db $f0,$01 : dw ShopItem1Die
rtl
ShopItem1Die:
cop #$E0

org $87cdf7
%MTryGiveItemAndFlag("EuroShop2Item", $f1)
cop #$D0 : db $f1,$01 : dw ShopItem2Die
rtl
ShopItem2Die:
cop #$E0

org $87d5e1
dw $0100   ; Euro shop line delay, reduced from vanilla.

org $87d60a
dw $d614   ; "Old men text no longer checks for Teapot"

org $87d622
db $cd : dl TextEuroOldManConversation2
db $c0

org $87d6db
db $cd : dl TextEuroOldManConversation1
db $c0

org $87d7a5
dw $d7bd   ; "Old men text no longer checks for Teapot"

org $87d7b1
db $10    ; Reveal Mt. Kress on map

org $87d892
db $d3
db "!SpoilerTextEuroOldMan"
db $c0

org $87df43
cop #$D5 : db $28
%MTryGiveItemAndFlag("EuroAnnItem", $e5)
rtl

org $87e37a
; Neil in Euro
db $1e : dw $1000
ENeilInEuro:
{
cop #$D0 : db $14,$01 : dw EuroNeilCanTravel
cop #$E0
EuroNeilCanTravel:
cop #$BC : db $00,$fe
cop #$C7 : dl ENeilInCottage
}

org $87e517
; Euro secret house
{
cop #$D0 : db $a6,$01 : dw EuroSecretGotItemAlready
%MTryGiveItemAndFlag("EuroHiddenHouseItem", $a6)
rtl
EuroSecretGotItemAlready:
cop #$BF : dw Text_EuroSecretGotItemAlready
rtl
Text_EuroSecretGotItemAlready:
db $d3,$d6,$63,$86,$8e,$2a,$c0
}

; Refactored to be permanent. Otherwise, in IOGR,
; the statue reappears if you open the inventory, because Euro's overlapping
; VRAM asset cards (required by ER) force a reload of the tilemap.
org $87e570
EEuroChurchStatue:
cop #$C0 : dw .OnInteract
cop #$C1
cop #$D0 : db $01, $01 : dw .DoOpenWall
cop #$45 : db $0f,$07, $10,$09 : dw .WithWind
.NoWind:
cop #$CE : db $00
rtl
.WithWind:
cop #$CC : db $00
rtl
.OnInteract:
cop #$D3 : dw $0169 : db $00   ; No interaction if the statue's open.
cop #$BF : dw $e5be
cop #$BE : db 2,1 : dw ..Options
..Options:
dw ..ChooseNo
dw ..ChooseYes, ..ChooseNo
..ChooseYes:
cop #$CC : db $01
..ChooseNo:
cop #$BF : dw $e602
rtl
.DoOpenWall:
cop #$08 : db $01,$01
cop #$32 : db $69
cop #$33
cop #$CD : dw $0169
cop #$CE : db $01
rtl
warnpc $87e5be   ; Start of text.

org $87e927
; Bank $87 free space begins here.

SethWatermiaOnInteract:
cop #$D0 : db $11,$01 : dw .CanTravel
.NoTravel:
cop #$BF : dw .TextNoTravel
rtl
.CanTravel:
cop #$D0 : db $12,$01 : dw .OfferTravel
..FirstTravel:
cop #$CC : db $12
cop #$BF : dw .TextFirstTravel
.OfferTravel:
jml EErikInCapeCave_AskWhere
.TextNoTravel:
db $d3
db "Only town folk may cross",$cb
db "this river!",$cb
db "(Or if you can talk to",$cb
db "fish, I guess.)",$c0
.TextFirstTravel:
db $d3
db "Oh, you know Bagu? Then",$cb
db "I can help you cross.",$cb
db "(And by Bagu I mean",$cb
db "Morse Code.)",$c0


; Replaces the routine at $87a018. Forces the leaf to always wait for the player.
LR_WatermiaLeafCheckPlayerPosition:
stz $0000
lda $1016 : cmp #$0100 : rol $0000   ; Now $0000 is 1 if player is in the south part of the map.
lda $16 : cmp #$0100 : rol : and #$0001 : cmp $0000 : bne .DoMoveNow
.AwaitPlayer:
lda $26 : cmp #$0002 : beq .DoMoveNow
phb
pla
pla
rtl
.DoMoveNow:
lda $26
jmp $a020


}



; Bank $88
{

org $888fc4
; Natives' Village warp to Dao; actor setup not included
{
ENativesVillageWarperPostSetup:
.OnInteract:
cop #$D0 : db $41,$01 : dw .OfferGoToDao
cop #$D6 : db $0a : dw .RequestFood
cop #$BF : dw .TextNoFood
rtl
.RequestFood:
cop #$BF : dw .TextRequestFood
cop #$BE : db $02,$01 : dw ..Choices
..Choices:
  dw ..SayNo, ..SayNo, ..SayYes
..SayNo:
cop #$BF : dw .TextRefuseGiveFood
rtl
..SayYes:
cop #$CC : db $41
cop #$D5 : db $0a
cop #$BF : dw .TextGaveFood
.OfferGoToDao:
cop #$BF : dw .TextOfferDaoWarp
cop #$BE : db $02,$01 : dw ..Choices
..Choices:
  dw ..SayNo, ..SayNo, ..SayYes
..SayNo:
cop #$BF : dw .TextDeclinedWarp
rtl
..SayYes:
cop #$26 : db $c3 : dw $0010,$00e0 : db $07,$00,$23
cop #$C5
.TextNoFood:
db $D3
db $cd : dl TextNativesHaveNoFood
db $C0
.TextRequestFood:
db $D3
db $cd : dl TextNativesRequestFood
db $ca
.TextRefuseGiveFood:
db $CE
db "Dude, that's cold."
db $C0
.TextGaveFood:
db $CE
db "He points to Dao on",$cb
db "your map."
db $C0
.TextOfferDaoWarp:
db $D3
db $cd : dl TextNativesOfferWarp
db $CA
.TextDeclinedWarp:
db $CE
db "He flashes you a",$cb
db "thumbs-up."
db $C0
}
warnpc $889078

org $8893a9
nop : nop : nop : nop   ; "cop #$BF : dw $...." Skip girl's speech.
%MTryGiveItemAndFlag("NativesGirlItem", $e6)
rtl


org $8898da
; This behaves oddly if approached from the left (in dungeon shuffle), so needs to be fixed.
db $00 : dw $3000
EAWOuterDropFloorOpener:
cop #$D1 : dw $016e : db $01 : dw .ListenForPlayer
cop #$45 : db $6a,$0b, $6f,$0c : dw .DoOpen
rtl
.DoOpen:
cop #$CA : db $14
  lda #$cff0 : tsb $065a
cop #$CB
cop #$08 : db $0f,$0f
cop #$32 : db $6e
cop #$33
cop #$CD : dw $016e
lda #$0082 : sta $1002    ; i.e. BankOf(EPlayer_StartFall)
lda #$c61e : sta $1000    ; i.e. EPlayer_StartFall
stz $1008
stz $102a
lda #$0800 : tsb $09ae
.ListenForPlayer:
cop #$C7 : dl EAWOuterDropFloorOpener_WhileOpen
warnpc $88992a


org $889a1c
; Use flag $F5 for Dark Glasses in bright room, instead of having them "equipped"
db $00 : dw $3000
EAWBrightRoomManager:
{
cop #$D0 : db $B7, $01 : dw .SeenIntro
cop #$CC : db $B7
lda #$CFF0 : tsb $065A
cop #$DA : db $1D
cop #$BF : dw .TextIntro
lda #$cff0 : trb $065a
.SeenIntro:
cop #$D0 : db $f5,$01 : dw .Die
cop #$DA : db $13
cop #$3C : dl $80b7ce    ; i.e. TAWBrightRoomFadeToWhite
cop #$DA : db $b3    ; this delay prevents spawning *FadeToNormal while *FadeToWhite is still running
cop #$C1
cop #$D0 : db $f5,$01 : dw .DonnedGlasses
rtl
.DonnedGlasses:
cop #$3C : dl $80b7d8    ; i.e. TAWBrightRoomFadeToNormal
.Die:
cop #$E0
.TextIntro:
db $d3
db $cd : dl TextWatBrightRoomIntro
db $c0
}

org $889abf
; Angkor Wat spirit item; actor setup not included
{
WatSpiritPostSetup:
cop #$C0 : dw .OnInteract
cop #$BC : db $08,$00
cop #$C1
cop #$89
rtl
.OnInteract:
cop #$D0 : db $be,$01 : dw .GotItemAlready
%MTryGiveItemAndFlag("WatSpiritItem", $be)
rtl
.GotItemAlready:
cop #$BF : dw .TextSpoiler
rtl
.TextSpoiler:
db $d3
db "!SpoilerTextAngkorWatSpirit"
db $c0
}


org $889f7c
db $02 : dw $1001
EWatBushSparkleItem:
cop #$D0 : db $ba,$01 : dw .Die
lda #$0200 : tsb $12
cop #$88 : dl $8ee000
cop #$C0 : dw .OnInteract
-:
cop #$80 : db $02
cop #$89
cop #$DA : db $3b
bra -
.OnInteract:
%MTryGiveItemAndFlag("WatGlassesItem", $ba)
cop #$D0 : db $ba,$01 : dw .Die
rtl
.Die:
cop #$E0

org $88a5b3
db $14,$00   ; Neil Dao flag

org $88a5bf
db $10       ; Other Neil Dao flag

org $88a5bd
; Neil in Dao
{
cop #$D0 : db $14,$01 : dw DaoNeilCanTravel
cop #$E0
DaoNeilCanTravel:
cop #$C7 : dl ENeilInCottage
}

org $88ad0c
db $d3
db "!SpoilerTextDaoGirl"
db $c0

org $88aeb9
cop #$C8 : dw EDaoSnakeGameNpc_ShowDifficultyText    ; Replaces cop #$BF : dw $af16.

org $88af16
; The base game has "rules" text here, so we replace it with difficulty-specific code.
EDaoSnakeGameNpc_ShowDifficultyText:
lda $0B24 : beq +++
  dec : beq ++
  dec : beq +
    cop #$BF : dw TextSnakeGameIntroExpert
    bra ++++
+:
cop #$BF : dw TextSnakeGameIntroAdvanced
bra ++++
++:
cop #$BF : dw TextSnakeGameIntroIntermediate
bra ++++
+++:
cop #$BF : dw TextSnakeGameIntroEasy
++++:
cop #$C5

org $88afe6
dw 60*!SnakeGameTimeLimitSeconds

org $88aff3
nop : nop : nop : jsr SR_SecIfWonSnakeGame : bcs EDaoSnakeGameManager_YouWinAndGetPrize    ; Replaces lda $0aac : cmp #$0051 : bcs EDaoSnakeGameManager_YouWinAndGetPrize
cop #$BF : dw Text_SnakeGameLost


org $88b010
EDaoSnakeGameManager_YouWinAndGetPrize:
{
cop #$BF : dw Text_SnakeGameWon
%MTryGiveItemAndFlag("DaoSnakeGameItem", $e7)
cop #$E0
Text_SnakeGameLost:
db $d3
db $D5,$02
db "OK! Stop!",$CB
db "You've hit " : db $C6 : dw $0003, $0aac : db " snakes.",$CB
db "Try again!"
db $C0
Text_SnakeGameWon:
db $d3
db $D5,$00
db "Wow " : db $C6 : dw $0003, $0aac : db " snakes. Very",$CB
db "good!"
db $C0
}

org $88b16d
jmp DaoOfferTravelToNatives


; Item-give code for the Dao entrance NPC. Has a unique inventory space check because it
; gives two items, and the check code is refactored here due to limited code space.
org $88b18b
if !SettingInfiniteInventory == 0
stz $0000
sep #$20
ldy #$0000
-:
lda $0ab4,y : bne +
  inc $0000
+:
iny : cpy #$0010 : bne -
rep #$20
lda $0000 : cmp #$0002 : bcc ++
endif
%MTryGiveItemAndFlag("DaoEntrance1Item", $b8)
%MTryGiveItemAndFlag("DaoEntrance2Item", $b8)
cop #$BF : dw DaoOfferTravelToNatives_TextPostGiveItem
rtl
warnpc $88b1c8
org $88b1c8
++:
; The base game "your inv full" code and all of the NPC's text follow from here.


org $88b592
db $00 : dw $2000
EPymdFloorBreakListener:
{
; IOGR fixes bugs here.
lda #$0000 : sta $24
lda $0E : sta $26
  beq .CheckRoom0Done
.CheckRoom1Done:
cop #$D1 : dw $0171 : db $01 : dw .Die
bra .DoListen
.CheckRoom0Done:
cop #$D1 : dw $0170 : db $01 : dw .Die
.DoListen:
cop #$C1
lda $1010 : bit #$0040 : beq ..PlayerAlive
  rtl   ; Added this, so dead player doesn't trigger the floor and get stuck.
..PlayerAlive:
lda $7F1008 : and #$00FF
  cmp #$0095 : beq ..PlayerWill
  cmp #$008E : bne ..PlayerShadow
..PlayerFreedan:
..PlayerWill:
lda $1028 : cmp #$001C : beq ..PlayerLanded
..PlayerShadow:
rtl
..PlayerLanded:    ; Removed a cop #$C1, so the floor doesn't trigger if player jumps off other ledge.
cop #$21 : db $01 : dw .OkayPlayerLandedHere
rtl
.OkayPlayerLandedHere:
lda $24 : bne .SecondSmash
.FirstSmash:
inc $24
lda $14 : sta $7F0010,x
  lsr : lsr : lsr : lsr : sta $14
lda $16 : sta $7F0012,x
  lsr : lsr : lsr : lsr : dec : sta $16
cop #$4C : db $E8
inc $14
cop #$4C : db $E9
lda $7F0010,x : sta $14
lda $7F0012,x : sta $16
cop #$C1
cop #$21 : db $01 : dw ..AwaitPlayerLeave
bra .DoListen
..AwaitPlayerLeave:
rtl
.SecondSmash:
cop #$07 : db $15
lda $26 : bne .Room1SuccessFall
.Room0SuccessFall:
cop #$32 : db $70
cop #$33
cop #$CD : dw $0170
bra .MakePlayerFall
.Room1SuccessFall:
cop #$32 : db $71
cop #$33
cop #$CD : dw $0171
bra .MakePlayerFall
.MakePlayerFall:
lda $1010 : and #$FFF7 : ora #$0200 : sta $1010
lda #$0082 : sta $1002    ; i.e. BankOf(EPlayer_StartFall)
lda #$C61E : sta $1000    ; i.e. #EPlayer_StartFall
lda #$0000 : sta $1008
  sta $102a
.Die:
cop #$E0
}
warnpc $88b668


org $88B6A2
if !SettingDungeonShuffle > 0
db $1c : dw $1001
EPymdPortalToFoyer:
lda #$0200 : tsb $12
cop #$C0 : dw .OnInteract
cop #$C1
rtl
.OnInteract:
cop #$D0 : db $d1,$01 : dw .DoOfferWarp   ; Hieroglyph puzzle solved
cop #$D0 : db $b4,$01 : dw .DoOfferWarp   ; Has/Used Aura
cop #$BF : dw .TextDenyWarp
rtl
.DoOfferWarp:
cop #$BF : dw .TextOfferWarp
cop #$BE : db $02,$02 : dw ..Options
..Options:
  dw ..ChooseNo
  dw ..ChooseNo, ..ChooseYes
..ChooseNo:
cop #$BF : dw .TextClear
rtl
..ChooseYes:
cop #$BF : dw .TextClear
lda $1010 : ora #$2000 : sta $1010
cop #$9C : dl .EVanishingPlayerSprite : dw $1800
lda #$0303 : sta $0648
lda #$0303 : sta $064a
cop #$26 : db $CC : dw $01f8, $0130 : db $03,$00,$44
rtl
.TextDenyWarp:
db $cd : dl TextPyramidWarpNotUnlocked
db $c0
.TextOfferWarp:
db $cd : dl TextPyramidOfferWarp
db $ca
.TextClear:
db $C8,$CA
.EVanishingPlayerSprite:
lda $1014 : sta $14
lda $1016 : sta $16
cop #$88 : dl $8ee000
cop #$80 : db $1c
cop #$89
cop #$E0
endif
warnpc $88b74d


org $88c1fd
db $1f : dw $1000
EPyramidGuy:
lda #$0200 : tsb $12
cop #$C0 : dw .OnInteract
cop #$0B
cop #$C1
rtl
.OnInteract:
cop #$D0 : db $ef, $01 : dw .AlreadyGivenBook
cop #$D6 : db $26 : dw .GiveBook
cop #$BF : dw .TextOfferTakeBook
rtl
.AlreadyGivenBook:
jsl LR_DisplayFathersJournalText
;cop #$BF : dw .TextReadGivenBook
rtl
.GiveBook:
cop #$CC : db $ef
cop #$D5 : db $26
cop #$BF : dw .TextDoTakeBook
rtl
.TextOfferTakeBook:
db $cd : dl TextPyramidGuyOfferTakeBook
db $c0
.TextDoTakeBook:
db $cd : dl TextPyramidGuyDoTakeBook
db $c0
;.TextReadGivenBook:
;db $cd : dl TextUseFathersJournal
;db $c0
warnpc $88c2da


; Speed up Pyramid elevators
org $88c3b9
jsr SR_RaisePymdElevator3a
nop
org $88c4a6
jsr SR_LowerPymdElevator3a
nop
org $88c55b
jsr SR_LowerPymdElevator3b
nop : nop : nop
org $88c56c
jsr SR_RaisePymdElevator3b
nop : nop : nop


; Hieroglyph locations.
org $88c7ac
%MTryGiveItemAndFlag("PyramidHiero1Item", $c2)
rtl
org $88c873
%MTryGiveItemAndFlag("PyramidHiero2Item", $c3)
rtl
org $88c91b
%MTryGiveItemAndFlag("PyramidHiero3Item", $c4)
rtl
org $88c9c3
%MTryGiveItemAndFlag("PyramidHiero4Item", $c5)
rtl
org $88ca6b
%MTryGiveItemAndFlag("PyramidHiero5Item", $c6)
rtl
org $88cb13
%MTryGiveItemAndFlag("PyramidHiero6Item", $c7)
rtl
; The hiero text that was here is now unused, so we re-purpose the space for code.
SR_SecIfHieroPlacementIsCorrect:
phx
ldx #$0000
.CheckNextTile:
lda.l Config_HieroOrderAnchor,x : dec : cmp $0B28,x : bne .ClcAndReturn
inx : inx : cpx #$000C : bcc .CheckNextTile
.SecAndReturn:
plx
sec
rts
.ClcAndReturn:
plx
clc
rts
warnpc $88cb94

;org $88cb94
;; "which tiles are called from placement flags"
;db !HieroItemTile1
;db !HieroItemTile2
;db !HieroItemTile3
;db !HieroItemTile4
;db !HieroItemTile5
;db !HieroItemTile6

org $88cbdc
; Replaces base game's check that placed hieroglyphs are in the order 1-2-3-4-5-6.
jsr SR_SecIfHieroPlacementIsCorrect : bcs +
  jmp $cc0b   ; Tiles in wrong order
+:
jmp $cbef   ; Skip ahead to the correct-order handler

org $88cd6c
; Formerly, defeated MQ and Solid Arm disappeared if they were the Pyramid boss.
; Later bug fixes made this unnecessary.
db $1c : dw $2001
EPyramidBossPortal:
; cop #$D0 : db $fc,$01 : dw .Die   ; or flag $f6 for Solid Arm
cop #$BC : db $08,$0c
cop #$D2 : db $d1,$01   ; = flag for hiero puzzle complete
lda #$1000 : tsb $10
lda #$2000 : trb $10
lda #$0200 : tsb $12
cop #$C0 : dw .OnInteract
cop #$C1
rtl
.Die:
cop #$E0
.OnInteract:
lda.l Config_Boss5Id : dec : sta $0bfa
cop #$BF : dw .TextInteract
cop #$BE : db $02,$02 : dw ..Options
..Options:
  dw ..ChooseNo
  dw ..ChooseNo, ..ChooseYes
..ChooseNo:
cop #$BF : dw .TextClear
rtl
..ChooseYes:
cop #$BF : dw .TextClear
lda #$2000 : tsb $1010
if !SettingDungeonShuffle > 0
cop #$9C : dl EPymdPortalToFoyer_EVanishingPlayerSprite : dw $1800
else
cop #$9C : dl $88B6F4 : dw $1800   ; This is the normal address for this object. Dungeon Shuffle moves it.
endif
lda #$0303 : sta $0648
lda #$0303 : sta $064a
cop #$26 : db !MapMQEntranceString
cop #$C1
rtl
.TextInteract:
db $d3
db $cd : dl TextPyramidBossPortal
db $ca
.TextClear:
db $c8
db $ca
warnpc $88ce12

org $88cea5
db $10,$00   ; Jeweler doesn't disappear when defeated.

org $88cec9
EJeweler_OnChat:
{
cop #$BF : dw EJeweler_Text_Greeting
lda $0ab0 : beq .TryGiveRewards
  cop #$BF : dw EJeweler_Text_ImHolding
.TryGiveRewards:
stz $26    ; $26 = Red Jewel count as not-BCD
sed
lda $0ab0
-:
cmp #$0000 : beq +
  sec : sbc #$0001
  inc $26
  bra -
+:
cld
cop #$D0 : db $E9, $01 : dw .PostReward1Check
lda $26 : cmp.l Config_Jeweler1Cost : bcc .PostReward1Check
jmp .TryGiveReward1
.PostReward1Check:
cop #$D0 : db $EA, $01 : dw .PostReward2Check
lda $26 : cmp.l Config_Jeweler2Cost : bcc .PostReward2Check
jmp .TryGiveReward2
.PostReward2Check:
cop #$D0 : db $EB, $01 : dw .PostReward3Check
lda $26 : cmp.l Config_Jeweler3Cost : bcc .PostReward3Check
jmp .TryGiveReward3
.PostReward3Check:
cop #$D0 : db $EC, $01 : dw .PostReward4Check
lda $26 : cmp.l Config_Jeweler4Cost : bcc .PostReward4Check
jmp .TryGiveReward4
.PostReward4Check:
cop #$D0 : db $ED, $01 : dw .PostReward5Check
lda $26 : cmp.l Config_Jeweler5Cost : bcc .PostReward5Check
jmp .TryGiveReward5
.PostReward5Check:
cop #$D0 : db $EE, $01 : dw .PostReward6Check
lda $26 : cmp.l Config_Jeweler6Cost : bcc .PostReward6Check
jmp .TryGiveReward6
.PostReward6Check: 
lda $26 : cmp.l Config_Jeweler7Cost : bcc .PostReward7Check
jmp .TryGiveReward7
.PostReward7Check:
cop #$BF : dw EJeweler_Text_MenuWithConfig
.MainMenu:
cop #$BE : db $03,$01 : dw ..Options
..Options:
  dw ..ChoseGoodbye
  dw ..ChoseGoodbye, ..ChoseGiveJewels, ..ChoseSeeRewards
..ChoseGoodbye:
cop #$BF : dw EJeweler_Text_Goodbye
rtl
..ChoseGiveJewels:
cop #$D6 : db $01 : dw ...DoGiveJewels
cop #$D6 : db $2e : dw ...DoGiveJewels
cop #$D6 : db $2f : dw ...DoGiveJewels
cop #$BF : dw EJeweler_Text_GiveZeroJewels
rtl
...DoGiveJewels:
sed
if !SettingInfiniteInventory == 1
lda $0bf4 : clc : adc $0ab0 : sta $0ab0
stz $0bf4
cop #$D5 : db $01
;bra ...DoneGiving
else
sep #$20
ldy #$0000
-:
lda $0ab4,y
  cmp #$01 : beq ....IsOne
  cmp #$2e : beq ....IsTwo
  cmp #$2f : beq ....IsThree
--:
iny : cpy #$0010 : bne -
bra ...DoneGiving
....IsThree:
jsr SR_JewelerMaybeDecHP
jsr SR_JewelerMaybeDecHP
lda #$03 : bra +
....IsTwo:
jsr SR_JewelerMaybeDecHP
lda #$02 : bra +
....IsOne:
lda #$01 ;: bra +
+:
clc : adc $0ab0 : sta $0ab0
jsr SR_JewelerMaybeDecHP
lda #$00 : sta $0ab4,y
bra --
endif
...DoneGiving:
rep #$20
cld
cop #$BF : dw EJeweler_Text_GiveJewels
jmp .TryGiveRewards
..ChoseSeeRewards:
cop #$BF : dw EJeweler_Text_SeeInventory
cop #$BF : dw EJeweler_Text_DrawInventoryBox
lda #$0001 : jsl LR_SetupAndDrawJewelerInvLineA
lda #$0002 : jsl LR_SetupAndDrawJewelerInvLineA
lda #$0003 : jsl LR_SetupAndDrawJewelerInvLineA
lda #$0004 : jsl LR_SetupAndDrawJewelerInvLineA
lda #$0005 : jsl LR_SetupAndDrawJewelerInvLineA
lda #$0006 : jsl LR_SetupAndDrawJewelerInvLineA
lda #$0007 : jsl LR_SetupAndDrawJewelerInvLineA
cop #$BF : dw EJeweler_Text_MenuWithConfig
jmp .MainMenu
.NoRewardYourInvFull:
cop #$BF : dw EJeweler_Text_YourInventoryFull
rtl
.TryGiveReward1:
%MTryGiveItemAndFlag("Jeweler1Item", $e9)
cop #$D0 : db $e9,$00 : dw .NoRewardYourInvFull
jmp .PostReward1Check
.TryGiveReward2:
%MTryGiveItemAndFlag("Jeweler2Item", $ea)
cop #$D0 : db $ea,$00 : dw .NoRewardYourInvFull
jmp .PostReward2Check
.TryGiveReward3:
%MTryGiveItemAndFlag("Jeweler3Item", $eb)
cop #$D0 : db $eb,$00 : dw .NoRewardYourInvFull
jmp .PostReward3Check
.TryGiveReward4:
%MTryGiveItemAndFlag("Jeweler4Item", $ec)
cop #$D0 : db $ec,$00 : dw .NoRewardYourInvFull
jmp .PostReward4Check
.TryGiveReward5:
%MTryGiveItemAndFlag("Jeweler5Item", $ed)
cop #$D0 : db $ed,$00 : dw .NoRewardYourInvFull
jmp .PostReward5Check
.TryGiveReward6:
%MTryGiveItemAndFlag("Jeweler6Item", $ee)
cop #$D0 : db $ee,$00 : dw .NoRewardYourInvFull
jmp .PostReward6Check
.TryGiveReward7:
cop #$BF : dw EJeweler_Text_GetSecrets
lda #$0202 : sta $0648
lda #$0404 : sta $064A
stz $0ad4
if !SettingRedJewelHunt == 1
cop #$26 : db $E5 : dw $0000,$0000 : db $00,$00,$11
else
cop #$26 : db !MapMansionEntranceString
endif
rtl
EJeweler_Die:
cop #$E0

EJeweler_Text_Greeting:
db $d3
db "I'm your huckleberry."
db $cf
db $ca
EJeweler_Text_ImHolding:
EJeweler_Text_GiveJewels:
db $ce
db $cd : dl TextJewelerImHolding
db $cf
db $ca
EJeweler_Text_MenuWithConfig:
db $d3
db $c3,$00
EJeweler_Text_Menu:
db $ce
db $cd : dl TextJewelerMainMenu
db $ca
EJeweler_Text_Goodbye:
db $ce
db $cd : dl TextJewelerGoodbye
db $c0
EJeweler_Text_GiveZeroJewels:
db $ce
db $cd : dl TextJewelerGiveZeroJewels
db $c0
EJeweler_Text_YourInventoryFull:
db $d3
db $cd : dl TextJewelerYourInvFull
db $c0
EJeweler_Text_GetSecrets:
db $d3
db $cd : dl TextJewelerGetSecrets
db $c0
EJeweler_Text_SetRedPalette:
db $c3 : db $04
db $ca
EJeweler_Text_SetBluePalette:
db $c3 : db $00
db $ca
EJeweler_Text_DrawInventoryBox:
db $c1 : db $03,$0b
db $c7 : db $08,$07
db $ce
db $d2 : db $00
db $ce
db $ca
EJeweler_Text_SeeInventory:
db $ce
db $cd : dl TextJewelerSeeInventory
db $c0

SR_JewelerMaybeDecHP:
if !SettingRedJewelMadness == 1
php
rep #$20
jsl LR_DecHP
plp
endif
rts
warnpc $88d6a9
}


org $88d7a8
; Small space optimizations to fit in a call to LR_SetThisDsVisitedAndActive.
db $00 : dw $2300
EGaia:
cop #$9C : dl $88f687 : dw $2800    ; = EDarkSpaceBgSparkleFactory
cop #$A0 : dl $89A090 : dw $0080, $0040, $1800    ; = EDarkSpaceGaiaEyes
cop #$A0 : dl $89A096 : dw $0080, $0058, $1800    ; = EDarkSpaceGaiaMouth
jsl LR_SetThisDsVisitedAndActive
jsr SR_FixThisDsType : and #$0003 : sta $0AB2
stz $0AAC
sta $0000
cop #$D9 : dw $0000, .DarkSpaceTypeBranch
.DarkSpaceTypeBranch:    ; Handlers for DS types 0, 1, 2, and 3
  dw $d856, $d87c, .DSType02, $da7d
warnpc $88d7ea

org $88d9cc
.DSType02:
; Put the statue base and correct statue on the BG layer
cop #$32 : db $8a
cop #$33
jsr SR_SecIfDsItemStatueShouldBeFreedan : bcs +
  jmp $d9f4   ; Skip ahead to creating the Will statue
+:
jmp $da1c   ; Skip ahead to creating the Freedan statue

org $88daf0
; Skip a lot of Gaia chatter.
{
EGaia_TryChat:
lda #$fff0 : tsb $065a
cop #$DA : db $05
lda #$fff0 : trb $065a
ldy $06
lda #$FFFF : sta $0024,y
lda $0ace : cmp $0aca : beq +
EGaia_TryChat_DoHeal:
  cop #$BF : dw EGaia_TextGiveHealing
  lda #$FFF0 : tsb $065a
  lda #$0028 : sta $0b22
  cop #$C1
  lda $0ace : cmp $0aca : beq +
  rtl
+:
EGaia_FindChatMapping:
; IOGR only has one special chat mapping.
lda #$FFF0 : trb $065A
lda $0b12 : cmp #$00cc : bne EGaia_MaybeOfferDarkGaia
lda $0aac : beq EGaia_MaybeOfferDarkGaia   ; Bottom DS has $0aac = 0, top has it = 1.
cop #$D0 : db $bd,$01 : dw EGaia_MaybeOfferDarkGaia
%MTryGiveItemAndFlag("PyramidGaiaItem", $bd)
EGaia_MaybeOfferDarkGaia:
if !SettingRedJewelHunt == 0
cop #$D0 : db $8a,$00 : dw EGaia_OfferSave    ; Rescued Kara
cop #$D0 : db $b4,$00 : dw EGaia_OfferSave    ; Used Aura
lda.l Config_SettingStatuesPlayerChoice : beq EGaia_CheckSpecificStatuesForDarkGaia
EGaia_CheckStatueCountForDarkGaia:
lda $0a1f : sta $0000
lda #$0000
clc
sep #$20
lsr $0000 : adc #$00
lsr $0000 : adc #$00
lsr $0000 : adc #$00
lsr $0000 : adc #$00
lsr $0000 : adc #$00
lsr $0000 : adc #$00
rep #$20
cmp.l Config_StatuesRequiredCount : bcs EGaia_OfferDarkGaia
  jmp EGaia_OfferSave
EGaia_CheckSpecificStatuesForDarkGaia:
lda.l Config_Statue1Required : beq +
  cop #$D0 : db $f8,$00 : dw EGaia_OfferSave
+:
lda.l Config_Statue2Required : beq +
  cop #$D0 : db $f9,$00 : dw EGaia_OfferSave
+:
lda.l Config_Statue3Required : beq +
  cop #$D0 : db $fa,$00 : dw EGaia_OfferSave
+:
lda.l Config_Statue4Required : beq +
  cop #$D0 : db $fb,$00 : dw EGaia_OfferSave
+:
lda.l Config_Statue5Required : beq +
  cop #$D0 : db $fc,$00 : dw EGaia_OfferSave
+:
lda.l Config_Statue6Required : beq +
  cop #$D0 : db $fd,$00 : dw EGaia_OfferSave
+:
EGaia_OfferDarkGaia:
cop #$BF : dw EGaia_TextOfferDarkGaia
cop #$BE : db $02,$01 : dw .Options
.Options:
  dw .SayNo, .SayNo, .SayYes
.SayYes:
cop #$26 : db $e4 : dw $00f0,$0140 : db $80,$00,$22
cop #$C1
rtl
.SayNo:
endif
EGaia_OfferSave:
cop #$BF : dw EGaia_TextOfferSave
cop #$BE : db $02,$02 : dw .Options
.Options:
  dw EGaia_OfferWarp
  dw .SayYes, EGaia_OfferWarp
.SayYes:
lda $0D8C    ; Save file index.
jsl $83D916  ; Save game routine.
if !SettingInfiniteInventory == 1
jsl LR_HardenSram
endif
cop #$07 : db $29
lda #$FFF0 : tsb $065A
cop #$DA : db $3B
lda #$FFF0 : trb $065A
stz $0bfc   ; Restore default fast item-get text speed after the save routine uses this.
cop #$BF : dw EGaia_TextFinishedRecording
EGaia_OfferWarp:
lda.w #!StartDsIndex : sta $0bfa
cop #$BF : dw EGaia_TextOfferWarp
cop #$BE : db $02,$01 : dw .Options
.Options:
  dw .SayNo, .SayNo, .SayYes
.SayYes:
if !SettingDsWarp == 1
jml EGaia_DsWarpMainMenu
else
jsl LR_WarpToStart
cop #$C5
endif
.SayNo:
EGaia_ThenGo:
cop #$BF : dw EGaia_TextThenGo
ldy $06
lda #$0000 : sta $0024,y
cop #$C5

EGaia_TextOfferDarkGaia:
db $d3
db "Face Dark Gaia?",$cb
db "_No",$cb
db "_Yes"
db $CA
EGaia_TextOfferSave:
db $D3
db $CE
db "Record what's happened",$CB
db "so far?",$CB
db "_Record",$CB
db "_Don't record"
db $CA
EGaia_TextFinishedRecording:
db $CE
db "Finished recording..."
db $CF
db $CA
EGaia_TextOfferWarp:
db $CE
if !SettingDsWarp == 1
db "Warp to a Dark Space"
else
db "Return to "
db $CD : dl TextStartDsNameInclude
endif
db "?",$CB
db "_No",$CB
db "_Yes"
db $CA
EGaia_TextThenGo:
db $CE
db "Then go."
db $C0
EGaia_TextGiveHealing:
db $D3
db $CE
db "It looks like you're",$CB
db "hurt. Close your eyes."
db $CF
db $CA
}
warnpc $88de72

org $88e9d4
EDarkSpaceItemStatueZone:
jsl LR_GetDsItemFlagForOuterMapOrSec : bcs .Die   ; we're not an item DS, somehow
jsl LR_SecOnAnyFlagA : bcc +
.Die:
cop #$E0
+:
cop #$8D : db $0A
lda #$2000 : trb $10
cop #$C1
cop #$8B
cop #$45 : db $03, $0A, $05, $0B : dw .PlayerInArea
  rtl
.PlayerInArea:
lda #$FFF0 : tsb $065A
cop #$DA : db $05
jsr SR_SecIfDsItemStatueShouldBeFreedan : bcs .TransformToFreedan
.TransformToWill:
lda $0ad4 : beq .GiveItemAfterFormChange
jsl LR_ForceChangeToWill
lda #$0800 : tsb $09AE
bra .GiveItemAfterFormChange
.TransformToFreedan:
lda $0ad4 : beq ..FromWill
dec : beq .GiveItemAfterFormChange
..FromShadow:
lda #$0088 : sta $1002
lda #$F2A3 : sta $1000
lda #$0000 : sta $1008
lda #$0800 : tsb $09AE
bra .GiveItemAfterFormChange
..FromWill:
lda #$0088 : sta $1002
lda #$F26E : sta $1000
lda #$0000 : sta $1008
lda #$0800 : tsb $09AE
;bra .GiveItemAfterFormChange
.GiveItemAfterFormChange:
cop #$C1
cop #$8B
lda $09AE : bit #$0800 : beq .DoGiveItemAndAnimateOrb
  rtl
.DoGiveItemAndAnimateOrb:
cop #$CA : db $08
  lda #$FFF0 : tsb $065A
  cop #$C1
  cop #$8B
cop #$CB
cop #$86 : db $0A, $03, $14
cop #$8A
cop #$84 : db $0A, $03
cop #$8A
lda $1014 : sta $7F0018,x
lda $1016 : sec : sbc #$0010 : sta $7F001A,x
cop #$22 : db $0A, $01
lda #$2000 : tsb $10
lda #$0800 : trb $10
cop #$04 : db $18
cop #$DA : db $59
lda #$0002 : sta $0bfc   ; Slow item-get text
jsl LR_GetDsItemForOuterMapOrSec : jsl LR_GiveAnyItemA16OrSec : bcs +
  jsl LR_GetDsItemFlagForOuterMapOrSec : jsl LR_SetAnyFlagA
+:
cop #$C1
sep #$20
lda $2141
rep #$20
and #$00FF : cmp #$00FF : beq .FanfareFinished
  rtl
.FanfareFinished:
stz $0bfc
cop #$04 : db $16
cop #$DA : db $3B
lda #$FFF0 : trb $065A
cop #$E0


; Abilities are 0-2=W, 3-5=F, so inc & 4 distinguishes them.
; As an added bonus, non-abilities split between the two statues deterministically and roughly evenly.
SR_SecIfDsItemStatueShouldBeFreedan:
jsl LR_GetDsItemForOuterMapOrSec : inc : and #$0004 : bne .SecAndReturn
.ClcAndReturn:
clc
rts
.SecAndReturn:
sec
rts
warnpc $88EB68

org $88eb81
db $c0   ; Remove the 2-second delay after "used!" in ability-get text

org $88ebd3
; Ability descriptions aren't used, so this space is free
TextItemGetAbilityCanBeUsedIncl:
db $c5 : dw $eb8f, $0db8   ; $eb8f = Lut_MoveNames_Pointers
db $cd : dl $88eb70    ; = "\ncan now be used!"
db $ca


org $88f0a1
db $10   ; Don't check for having-met-Freedan

; Mansion: don't tamper with BG registers if room is dark
if !IsMapEADark == 1 || !SettingDarkRoomsLevel == 4
org $88f9f6
nop : nop : nop
org $88f9fb
nop : nop : nop
endif

org $88fa25
jmp SolidArmDeathOverride

org $88fa32
; Solid Arm intro text.
db "Weave a circle",$cb
db "__round him thrice,",$cb
db "And close your eyes",$cb
db "__with holy dread,"
db $cf
db "For he on honey-dew",$cb
db "__hath fed,",$cb
db "And drunk the milk",$cb
db "__of Paradise."
db $c0

org $88fbc9
; Solid Arm death text.
db $d5,$02
db "Ed, what an ugly thing",$cb
db "to say... does this",$cb
db "mean we're not friends",$cb
db "anymore?"
db $cf
db "You know, Ed, if I thought",$cb
db "you weren't my friend,",$cb
db "I just don't think",$cb
db "I could bear it."
db $c0

; Mansion: don't tamper with BG registers if room is dark
if !IsMapE9Dark == 1 || !SettingDarkRoomsLevel == 4
org $88fc77
nop : nop : nop
org $88fca0
nop : nop : nop
endif

org $88fcb2
; Exit from Mansion
cop #$26 : db !MapMansionExitString

org $88fd16
; Bank $88 free space begins here.
LR_ForceChangeToWill:
{
; The base game has form-specific transformation routines. We need a generic one
; because there are many places where we force a transformation from either other form.
lda $0AD4 : beq .Done
cop #$9C : dl EForceChangeToWill : dw $2000
.Done:
rtl
EForceChangeToWill:
cop #$C8 : dw $f309   ; Effect of saying Yes at Will transform statue.
cop #$E0
}

DaoOfferTravelToNatives:
{
cop #$BF : dw .TextOfferTravel
cop #$BE : db $02,$01 : dw .Options
.Options:
  dw .SayNo, .SayNo, .SayYes
.SayNo:
cop #$BF : dw .TextDeclinedTravel
rtl
.SayYes:
cop #$26 : db $ac : dw $01c0,$01d0 : db $06,$00,$22
cop #$C1
rtl
.TextOfferTravel:
db $d3
db "Go to Natives' Village?",$cb
db "_No",$cb
db "_Yes",$ca
.TextDeclinedTravel:
db $ce
db "Come back any time!",$c0
.TextPostGiveItem:
db $d3
db "If you want a guide to",$cb
db "take you to the Natives'",$cb
db "Village, I can get one",$cb
db "for you.",$c0
}

SolidArmDeathOverride:
cop #$CC : db $f6
cop #$26 : db $e3 : dw $0280,$01a0 : db $80,$10,$23    ; Always goes to Babel and gives statue 6
cop #$E0

SR_RaisePymdElevator3a:
inc : inc : inc : inc : sta $0026,y
rts
SR_LowerPymdElevator3a:
dec : dec : dec : dec : sta $0026,y
rts

SR_LowerPymdElevator3b:
dec : dec : dec : dec
bra +
SR_RaisePymdElevator3b:
inc : inc : inc : inc
+:
sta $0026,y
dec $26 : dec $26 : dec $26 : dec $26
rts

TextSnakeGameSnakesInSecondsGo:
db "_snakes in","!SnakeGameTimeLimitSecondsString",$cb
db "seconds. Go!"
db $ca
TextSnakeGameIntroEasy:
db $ce
db "Hit","!SnakeGameTargetEasyString"
db $cd : dl TextSnakeGameSnakesInSecondsGo
db $c0
TextSnakeGameIntroIntermediate:
db $ce
db "Hit","!SnakeGameTargetIntermediateString"
db $cd : dl TextSnakeGameSnakesInSecondsGo
db $c0
TextSnakeGameIntroAdvanced:
db $ce
db "Hit","!SnakeGameTargetAdvancedString"
db $cd : dl TextSnakeGameSnakesInSecondsGo
db $c0
TextSnakeGameIntroExpert:
db $ce
db "Hit","!SnakeGameTargetExpertString"
db $cd : dl TextSnakeGameSnakesInSecondsGo
db $c0

SR_SecIfWonSnakeGame:
phx
  lda $0B24 : asl : tax
  lda $0AAC : cmp.l .RequiredSnakeCountsByDifficulty,x
plx
rts
.RequiredSnakeCountsByDifficulty:
dw !SnakeGameTargetEasy
dw !SnakeGameTargetIntermediate
dw !SnakeGameTargetAdvanced
dw !SnakeGameTargetExpert

; "Ability DS" (type 2) is redundant. This converts type-0/1 to type-2 if the DS has an item.
SR_FixThisDsType:
lda $0aac : cmp #$0003 : beq .NoDsItem   ; Used by upper Pyramid to force txform, in case lower Pyramid has an item
jsl LR_GetDsItemForOuterMapOrSec : bcs .NoDsItem
.HasDsItem:
lda #$0002
rts
.NoDsItem:
lda $0aac
rts

}



; Bank $89
{

org $898045
jsr SR_BabelSpiritTransformAndRespawnEnemies

org $89804a
db !MapBabelDaoWarpString

org $898055
db $cd : dl TextBabelBabylonJoke
db $cb
db "_Quit",$cb
db "_Go to_"
if !Boss1Id == 6
db "Diamond Coast"
elseif !Boss2Id == 6
db "Seaside Palace"
elseif !Boss3Id == 6
db "Mu"
elseif !Boss4Id == 6
db "Great Wall"
elseif !Boss5Id == 6
db "Pyramid"
else
db "Dao"
endif
db $ca

org $8980cb
jmp DaoSpiritLogicOverride

org $89884c
db $01,$00   ; Shorten Olman text boxes

org $898891
cop #$0B
rtl      ; Stop Olman's dialogue early

org $8988d2
jmp BabelStatueLogicOverride    ; Extra code to require beating a boss before getting Statue 6

org $898903
db $d3 : db "heya.",$c0

org $8989a2
db $d3 : db "you've been busy, huh?",$c0

org $898ebe
db "!TextShadowSuperhero"
db $c3,$00
db $c0

org $898fad
; Speed up Babel rooftop sequence
cop #$CC : db $0e
cop #$CC : db $0f
cop #$CE : db $F4
rtl

; Speed up Babel warp/elevator sequences
org $8995a7
cop #$DB : dw $0002
cop #$CC : db $00
cop #$DB : dw $0002
cop #$CC : db $01
if !SettingDungeonShuffle > 0
cop #$9C : dl EPymdPortalToFoyer_EVanishingPlayerSprite : dw $1002
else
cop #$9C : dl $88B6F4 : dw $1002   ; This is the normal address for this object. Dungeon Shuffle moves it.
endif

org $8995f6
if !SettingDungeonShuffle > 0
cop #$9C : dl EPymdPortalToFoyer_EVanishingPlayerSprite : dw $1002
else
cop #$9C : dl $88B6F4 : dw $1002   ; This is the normal address for this object. Dungeon Shuffle moves it.
endif

org $8996ab
db $03
org $8996fd
db $10
org $89982a
db $10
org $899848
db $04

org $899866
db $cd : dl TextBabelTalonJoke
db $c0
org $89974e
db $cd : dl TextBabelVampireJoke
db $c0

org $89999b
jmp CrystalRingBarrierLogicOverride

org $8999aa
jmp CrystalRingBarrierLogicOverride2

org $899a49
%MTryGiveItemAndFlag("BabelForceFieldItem", $dc)
cop #$D0 : db $dc,$01 : dw BabelForceFieldGotItem
rtl
BabelForceFieldGotItem:
cop #$E0

org $899a70
db $d3,"Well, lookie there.",$c0   ; Crystal Ring popped off text.


; Babel spirits can return you to the basement + Dark Space
org $899b5f
BabelSpiritWarpLabelPlaceholder:
cop #$D9 : dw $0000 : dw .TypePointers
.TypePointers:
  dw .Type0, .Type1, .Type1, .Type1, .Type1, .Type1
.Type0:
cop #$BF : dw ..Text
rtl
..Text:
db $d3
db "!SpoilerTextBabelSpirit"
db $c0
.Type1:
cop #$BF : dw ..TextDialogue
cop #$BE : db $02,$01 : dw ..DialogueOptions
..DialogueOptions:
  dw ..ChooseDecline
  dw ..ChooseDecline, ..ChooseAccept
..TextDialogue:
db $cd : dl BabelWarperSpiritDialogueOptions
db $ca
..ChooseDecline:
cop #$BF : dw ...Text
rtl
...Text:
db $ce
db "Darn straight."
db $c0
..ChooseAccept:
cop #$26 : db $de : dw $0078, $00c0 : db $00,$00,$11
cop #$C5
rtl


; Lilly button is available if Lilly is with you due to Necklace.
org $89aa40
db $15 : dw $1000
ECDandelionFinal:
cop #$D0 : db $6f,$00 : dw $aa6c   ; i.e. die if don't have Lilly
cop #$CC : db $02
org $89be74
db $d7,$18    ; Dialogue to say "Lilly's" instead of Strange.


; "Reconstructed" Apocalypse Gaia code.
org $89aae3
if !ApocalypseGaia == 1
incsrc "apocalypse_gaia_1.asr"
endif
warnpc $89ba80

org $89bf7d
; Allow Edward's to spawn a DS containing an ability.
cop #$A0 : dl $88d6ac : dw $00a8,$04c0 : dw $0b00
jmp EDarkSpaceSpawnerMemoryShuffler

org $89bf95
db $10   ; Skip Lilly meeting in Edward's

org $89c037
jsl LR_ForceChangeToWill   ; At Edward's dungeon exit.
cop #$E0

if !SettingEnemizer >= 2
; Allow falling blocks in Inca with enemizer active
org $89C2D0
; this section currently unused
warnpc $89c2db
org $89c2db
EMPFallingBlockWall:
lda #$0000 : sta $7F0010,x
bra +
EMPFallingBlockFloor:
lda #$0001 : sta $7F0010,x
+:
cop #$88 : dl $8ee000
cop #$BC : db $08, $00
cop #$9C : dl EMPFallingBlockShadow : dw $0301
dec $17    ; witchcraft (eq. lda $16 : sec : sbc #$0100 : sta $16, provided $16 >= #$0100)
lda #$2000 : trb $10
cop #$B2
cop #$86 : db $1b, $02, $0F
cop #$8A
cop #$08 : db $15, $15
cop #$B4
lda #$0100 : trb $10
cop #$82 : db $1b, $35
cop #$89
lda #$0100 : tsb $10
cop #$B3
lda $7F0010,x : bne +   ; Is 1 if new floor, 0 if new wall.
cop #$0B
bra ++
+:
cop #$11
++:
cop #$C1
rtl
EMPFallingBlockShadow:
cop #$84 : db $31, $03
cop #$8A
cop #$E0

warnpc $89c33b
org $89c33b
db $1b : dw $2300
EMPFallingBlockInDiamondBlockRoom:
cop #$88 : dl $8ee000
cop #$8D : db $1b
cop #$BC : db $08, $00
cop #$D0 : db $2F, $01 : dw .DoneFalling
cop #$D2 : db $2F, $01
lda #$CFF0 : tsb $065A
cop #$DA : db $3B
cop #$08 : db $15, $15
cop #$9C : dl $80cf8e : dw $2000    ; i.e. ESimpleScreenShake
cop #$DA : db $B3
cop #$23 : sta $08
cop #$C2
dec $17    ; witchcraft (eq. lda $16 : sec : sbc #$0100 : sta $16, provided $16 >= #$0100)
lda #$2000 : trb $10
cop #$B2
cop #$86 : db $1b, $02, $0F
cop #$8A
cop #$08 : db $15, $15
cop #$B4
cop #$82 : db $1b, $35
cop #$89
.DoneFalling:
lda #$2000 : trb $10
cop #$B3
cop #$11
lda #$CFF0 : trb $065A
cop #$C1
rtl
warnpc $89c39f
endif

org $89c5bb
; Singing Statue
%MTryGiveItemAndFlag("IncaCliffItem", $32)
lda #$eff0 : trb $065a
cop #$E0


org $89c614
; Golden Tile room changes, overwriting unused singing-statue text.
; Can't use cop #$4B for these tile draws, because that doesn't run on the effect layer.
db $00,$00,$23
EGoldenTileListener:
lda #$0000 : sta $7ec384   ; Remove the Golden Tile from the EffectLayer tilemap
  sta $7ec394
phx
; Drawing the tile in 1 pass is safe only because no possible position crosses a screen boundary
lda.l Config_IncaTileX : asl : clc : adc #$0004 : sta $0018
  sta $14   ; Not our final X, but we need the initial calculation later, anyway
lda.l Config_IncaTileY : asl : clc : adc #$0010 : sta $001c
  sta $16   ; Not our final Y, but we need the initial calculation later, anyway
lda #$0000 : tcd
ldx #$0000
jsl $82B0A3   ; = jsl LR_GetTileTableIndex82; returns index in X
lda #$4140 : sta $7ec000,x
lda #$4342 : sta $7ec010,x
plx
txa : tcd
; Put this actor on the tile so we can use cop #$21 instead of cop #$45
lda $14 : inc : asl : asl : asl : asl : sta $14
lda $16 : inc : asl : asl : asl : asl : inc : inc : inc : inc : sta $16
; Mostly-normal code resumes here
cop #$D1 : dw $0112 : db $01 : dw .Die
.WaitLoop:
lda #$0258 : sta $7f0010,x
cop #$C1
cop #$21 : db $01 : dw .DecCounter
cop #$C4 : dl .WaitLoop
.DecCounter:
lda $7f0010,x : dec : beq .OpenDoor
  sta $7f0010,x
  rtl
.OpenDoor:
cop #$08 : db $0f,$0f
cop #$32 : db $12
cop #$33
cop #$CD : dw $0112
.Die:
cop #$D5 : db $08   ; Remove Wind Melody when door opens (or if it's already open)
cop #$E0
warnpc $89c6a9


org $89cfaa
jsl LR_ForceChangeToWill   ; After Castoth.
lda #$EFF0 : trb $065a
cop #$E0

org $89d0f5
{
db $00 : dw $3000
EMoonTribeSpirit:
lda #$0200 : tsb $12
cop #$D0 : db $2a,$01 : dw .TeapotApplied
cop #$D0 : db $08,$01 : dw .SeenTeapotMessage
cop #$21 : db $03 : dw .ShowTeapotMessage
rtl
.ShowTeapotMessage:
cop #$BF : dw .TextHealUs
cop #$CC : db $08
.SeenTeapotMessage:
rtl
.TeapotApplied:
cop #$CC : db $10
cop #$3C : dl $80b800
cop #$C2
lda #$2000 : trb $10
cop #$0B
cop #$C0 : dw .OnInteract
cop #$C1
cop #$82 : db $27,$3b
cop #$89
rtl
.OnInteract:
cop #$BF : dw .TextOffer
cop #$BE : db $02,$01 : dw ..Options
..Options:
  dw ..SayNo,..SayNo,..SayYes
..SayNo:
cop #$BF : dw .TextLaugh
rtl
..SayYes:
cop #$26 : db !MapMoonWarpString
cop #$C1
rtl
.TextHealUs:
db $D3
db $cd : dl TextMoonTribeHealUs
db $C0
.TextOffer:
db $D3
db "Moon Tribe: Want a lift?",$cb
db "_No",$cb
db "_Yes"
db $CA
.TextLaugh:
db $CE
db "Ku ku ku..."
db $C0
}

org $89f710
EDarkSpaceSpawnerMemoryShuffler:
lda $0e : sta $24
lda #$2000 : sta $0e
cop #$C2    ; Stay alive for 1 frame so spawned DS can access us.
cop #$E0

DaoSpiritLogicOverride:   ; Appears if either BabelMQ or Solid Arm is beaten.
cop #$D0 : db $f6,$01 : dw $80d1
cop #$D1 : dw $0179 : db $01 : dw $80d1
cop #$E0

CrystalRingBarrierLogicOverride:
cop #$D0 : db $dc,$00 : dw $99a0
cop #$D0 : db $3e,$00 : dw $99a0
cop #$D0 : db $b4,$01 : dw $999a
jmp $99a0
CrystalRingBarrierLogicOverride2:
cop #$D0 : db $dc,$01 : dw $999a
jmp $99af

BabelStatueLogicOverride:
cop #$D1 : dw $0179 : db $01 : dw .DoGiveStatue
cop #$D0 : db $f6, $01 : dw .DoGiveStatue
.NoGiveStatue:
cop #$BF : dw .TextNoGiveStatue
rtl
.DoGiveStatue:
cop #$BF : dw $8903
cop #$CC : db $01
rtl
.TextNoGiveStatue:
db $d3
db "heya."
db $cf
db "you look frustrated",$cb
db "about something."
db $cf
db "guess i'm pretty good",$cb
db "at my job, huh?"
db $c0

SR_BabelSpiritTransformAndRespawnEnemies:
sta $0648
jsl LR_ClearMonsterKilledFlags
jsl LR_ForceChangeToWill
rts

}



; Bank $8A
{

org $8A8835
; Make the pullable statues destructible in EdDg
db $36 : dw $0100
cop #$C7 : dl $85f8c3


org $8a8b1e
EMPMudGolem:
if !SettingEnemizer >= 2
jmp EMPMudGolem_SetUpEnemizerPalette   ; I'd rather a SR, but there are many jumps to $8b21
endif

; Boss monster death copies some of EBasicMonsterDeath.
org $8aa4a6
if !SettingOrbRando > 0
nop : nop    ; Don't flag self killed yet, in case player's inventory is full.
endif

org $8aa4b8
lda $7F0024,x : beq ++
jsl LR_SecOnMonsterItemFlagA : bcs ++
  cop #$A5 : dl EMonsterDeathDoorOrItem : db $00,$00 : dw $0342
  jsl LR_PrepareMonsterDeathDoorOrb
  bra +++
++:
cop #$D8
+++:
jmp $a4e0    ; easier than padding with nops






; Speed up the Mine elevator
org $8aa5d6
cop #$83 : db $34,$0f,$07

org $8aa615
cop #$83 : db $34,$10,$08

org $8aa6b6
db $0c : dw $1000
EMineSlave:

org $8aa751
%MTryGiveItemAndFlag("MineCombatSlaveItem", $a2)
cop #$D0 : db $a2,$00 : dw MineSlaveInvFullResponse
rtl
MineSlaveInvFullResponse:
lda #$a6f9 : sta $00
rtl

org $8aa771
%MTryGiveItemAndFlag("MineRampSlaveItem", $a3)
cop #$D0 : db $a3,$00 : dw MineSlaveInvFullResponse
rtl

; Exploding worms' death code includes "ldy $06 : cop #$23", which is a bug because COP clobbers Y.
; Vanilla cop #$23 happens to give Y a value that the code can use anyway, but my cop #$23 does not.
org $8ACBF2
cop #$23
ldy $06

org $8ace9b
; Expedite transform and map change after Viper (though I think this isn't needed anymore).
jsl LR_ForceChangeToWill
cop #$C2
lda $09AE : bit #$0800 : beq +
  rtl
+:
cop #$26 : db !MapViperExitString ; $5a : dw $0090,$0070 : db $83,$00,$14
cop #$C1
rtl

org $8afa51
; Dying to Vamps respawns you in their entrance corridor
db $67 : dw $0178, $01d0 : db $80,$01,$22


org $8afd87
; Bank $8A free space begins here.

EMPMudGolem_SetUpEnemizerPalette:
cop #$D0 : db $0f,$01 : dw .PaletteSetupDone
cop #$CC : db $0f
cop #$3B : db $13 : dl $80B522
.PaletteSetupDone:
cop #$C2
cop #$CE : db $0f
cop #$27 : db $10
jmp $8b21

}



; Bank $8B
{
org $8b8060
; Fix an issue where the statue is lost if you warp away while Fanger is dying.
EFangerStatueAwardListener:
cop #$C2   ; -- so the Fanger actor has a frame to die, if applicable
lda $0aec : bne .FangerNotDead
.FangerAlreadyDead:
cop #$D0 : db $fb,$00 : dw .GiveStatue
cop #$E0
.FangerNotDead:
lda $09ae : bit #$0020 : bne +
  rtl
+:
bit #$0200 : beq +
  cop #$C1
  rtl
+:
cop #$D3 : dw $016a : db $01
.GiveStatue:
lda #$fff0 : tsb $065a
cop #$DA : db $3b
cop #$BF : dw $80b5
lda #$0003 : sta $0aac
cop #$26 : db $fd : dw $0000,$0000 : db $00,$00,$11
cop #$E0
warnpc $8b80b5

org $8b815c
; Make Fanger spawn the fixed statue listener before it checks whether it's defeated
db $00 : dw $0100
EFanger:
cop #$A5 : dl $8b813a : dw $0000, $2000   ; = EFangerPlayerLayerManager
cop #$A5 : dl EFangerStatueAwardListener : dw $0000, $2000
lda #$0003 : jsl $80b05e : bcc +   ; = LR_SecOnDefeatedBossA
  stz $0aec
  stz $0aee
  cop #$E0
+:
lda #$8019 : tsb $12
; --and continue on as usual

; Make Fanger's detection areas cover the arena, in case player moves during quake
org $8b81a0
db $01,$19,$3f,$3f
org $8b81b7
db $01,$2c,$3f,$3f


; Work around the bug where Wat fly code hangs if they spawn with X or Y less than #$0040.
org $8baf4f
db $00 : dw $0000
EAWZipFly:
lda $14 : sta $7F100C,x
lda $16 : sta $7F100E,x
jsr SR_FixWatFlyHomeAndLayer
stz $24


; Wat golems don't fall from the ceiling in pieces in Enemizer
if !SettingEnemizer > 0
org $8bb825
db $00 : dw $0000
cop #$27 : db $0f
cop #$C1
jmp $b8a0
rtl
endif


; Wat scarab death copies some of EBasicMonsterDeath.
org $8BC14d
if !SettingOrbRando > 0
nop : nop    ; Don't flag self killed yet, in case player's inventory is full.
endif

org $8BC15A
lda $7F0024,x : beq ++
jsl LR_SecOnMonsterItemFlagA : bcs ++
  cop #$A5 : dl EMonsterDeathDoorOrItem : db $00,$00 : dw $0342
  jsl LR_PrepareMonsterDeathDoorOrb
  bra +++
++:
cop #$D8
+++:
jmp $c182


; Pyramid orb death copies some of EBasicMonsterDeath.
org $8BC761
if !SettingOrbRando > 0
nop : nop    ; Don't flag self killed yet, in case player's inventory is full.
endif

org $8bc76e
lda $7F0024,x : beq ++
jsl LR_SecOnMonsterItemFlagA : bcs ++
  cop #$A5 : dl EMonsterDeathDoorOrItem : db $00,$00 : dw $0342
  jsl LR_PrepareMonsterDeathDoorOrb
  bra +++
++:
cop #$D8
+++:
jmp $c796


org $8bc8de
if !SettingDebug == 1
; Skip logo/title screens
cop #$26 : db $fa : dw $0000,$0000 : db $00,$00,$11
cop #$E0
endif


org $8bd32b
nop : jsr SR_OverrideEndgameWithZeroHp   ; replacing cop #$BF : $d558

; Extensive text modifications to credits.
{
org $8bd558
; Part 1 box 1 (player thanks)
db $c1 : db 3,7
db $c7 : db 13,2
db $c2 : db $13
db $d2 : db $00
db $d5 : db 6
db $AC,$AC,$AC,$AC,$64,$87,$80,$8D,$8A,$A3,$AC,$80,$AC,$8C,$88,$8B,$8B,$88,$8E,$8D,$2A,$C9,$B4,$C8,$CA
warnpc $8bd5a0
org $8bd5a0
; Part 1 box 2 (GTC)
db $c1 : db 3,7
db $c7 : db 13,2
db $c2 : db $15
db $d2 : db $00
db $d5 : db 6
db $AC,$44,$A8,$A4,$A2,$80,$AC,$A3,$A0,$84,$82,$88,$80,$8B,$AC,$A4,$87,$80,$8D,$8A,$A3,$AC,$A4,$8E,$CB
db $AC,$AC,$AC,$AC,$AC,$AC,$AC,$8C,$80,$8D,$80,$85,$A2,$84,$80,$8A,$C9,$78
db $CE
db $AC,$D6,$4E,$A0,$A2,$8E,$89,$84,$82,$A4,$AC,$D6,$F3,$8D,$8E,$A4,$CB
db $AC,$AC,$84,$A8,$88,$A3,$A4,$AC,$D6,$F8,$87,$88,$A3,$AC,$A7,$8E,$A2,$8A,$2A,$C9,$78
db $CE
db $AC,$AC,$AC,$AC,$AC,$86,$80,$88,$80,$A4,$87,$84,$82,$A2,$84,$80,$A4,$8E,$A2,$CB
db $AC,$AC,$AC,$AC,$AC,$AC,$2A,$81,$8B,$8E,$86,$A3,$A0,$8E,$A4,$2A,$82,$8E,$8C
db $C9,$B4
db $C8
db $CA
warnpc $8bd70e
org $8bd70e
; Part 1 box 3 (created by)
db $c1 : db 3,7
db $c7 : db 13,2
db $c2 : db $14
db $d2 : db $00
db $d5 : db 6
db $AC,$AC,$AC,$AC,$42,$A2,$84,$80,$A4,$84,$83,$AC,$81,$A9,$CB
db $AC,$AC,$AC,$AC,$AC,$AC,$AC,$43,$8E,$8D,$A4,$41,$80,$86,$A5,$4C,$84
db $C9,$B4
db $C8
db $CA
warnpc $8bd740
org $8bd740
; Part 1 box 4 (devs + thanks playtesters)
db $c1 : db 3,7
db $c7 : db 13,3
db $c2 : db $12
db $ce
db $d2 : db $00
db $d5 : db 6
db $AC,$43,$84,$A6,$A3,$2F,$AC,$62,$80,$84,$A6,$84,$8D,$20,$AB,$AC,$41,$A2,$A9,$8E,$8D,$AC,$67,$CB,$AC,$AC,$AC,$AC,$80,$8D,$83,$AC,$4D,$84,$8E,$8C,$80,$A4,$80,$8C,$A5,$8D,$84,$CB,$AC,$44,$8C,$8E,$64,$A2,$80,$82,$8A,$84,$A2,$AC,$81,$A9,$AC,$40,$A0,$8E,$8A,$80,$8B,$A9,$A3,$8C,$84,$C9,$78,$CE,$CB,$AC,$AC,$AC,$64,$87,$80,$8D,$8A,$A3,$AC,$A4,$8E,$AC,$80,$8B,$8B,$AC,$A4,$87,$84,$CB,$AC,$AC,$80,$8C,$80,$AA,$88,$8D,$86,$AC,$A0,$8B,$80,$A9,$A4,$84,$A3,$A4,$84,$A2,$A3,$4F,$C9,$B4,$C8,$CA

org $8bd9fa
; Part 2 box 1 (player thanks)
db $c1 : db 3,7
db $c7 : db 13,1
db $ce
db $c2 : db $12
db $d2 : db $00
db $d5 : db 6
db $AC,$AC,$AC,$64,$87,$80,$8D,$8A,$A3,$AC,$85,$8E,$A2,$AC,$A0,$8B,$80,$A9,$88,$8D,$86,$4F,$C9,$B4,$C8,$CA

org $8bdc95
; Part 2 box 2 (hamlet)
db $c1 : db 3,7
db $c7 : db 13,3
db $c2 : db $13
db $d2 : db $00
db $d5 : db 6
db $d6 : db $25    ; "Kara: "
db $D7,$42,$80,$AC,$8C,$88,$8D,$A5,$A4,$84,$2A,$2A,$2A,$CB,$D6,$F7,$D6,$9D,$A4,$8E,$AC,$47,$80,$8C,$8B,$84,$A4,$0D,$C9,$B4,$C8,$CA
warnpc $8bdd34
org $8bdd34
; Part 2 box 3 (hamlet response)
db $c1 : db 3,7
db $c7 : db 13,3
db $c2 : db $12
db $d2 : db $00
db $d5 : db 6
db "Will: "
db $65,$8C,$2A,$2A,$2A,$CB,$48,$AC,$D6,$FB,$A7,$8E,$A2,$A2,$A9,$AC,$80,$81,$8E,$A5,$A4,$CB,$D6,$D7,$A4,$8E,$8E,$AC,$8C,$A5,$82,$87,$2A,$2A,$2A,$C9,$B4,$C8,$CA
warnpc $8bdde5
org $8bdde5
; Part 2 box 4 (hamlet 3)
db $c1 : db 3,7
db $c7 : db 13,3
db $c2 : db $13
db $d2 : db $00
db $d5 : db 6
db $d6 : db $25    ; "Kara: "
db $cb
db $D6,$63,$81,$A5,$A4,$2A,$2A,$2A,$C9,$B4,$C8,$CA
warnpc $8bde02
org $8bde02
; Part 2 box 5 (bacon)
db $c1 : db 3,7
db $c7 : db 13,2
db $c2 : db $12
db $d2 : db $00
db $d5 : db 6
db "Will: "
db $63,$87,$87,$2A,$2A,$2A,$AC,$87,$84,$A2,$84,$AB,$CB
db $D6,$98,$D6,$D0,$81,$80,$82,$8E,$8D,$2A
db $C9,$B4
db $C8
db $CA

org $8bdee2
; changing-world screen dialogue
db $CB,$AC,$D6,$53,$88,$A4,$AB,$AC,$A3,$87,$8E,$A7,$0E,$A3,$AC,$8E,$A6,$84,$A2,$2A,$C9,$B4,$C8,$CA

org $8be075
db $cd : dl TextCreditsPlaytesterListOverflow
db $c9, $f0
db $c8
db $ca
}


; Main menu has 3 options (no Copy)
org $8be2ff
lda #$0002
org $8be316
cmp #$0003
org $8be34c
dw $e354, $ea55, $e6ba   ; Start, Erase, Options

; Start-game menu: enforce all actions on the one save file
org $8be364
stz $0d8c
nop : nop : nop
stz $0d92
org $8be398   ; Ignore up input
rtl
org $8be3b1   ; Ignore down input
rtl

if !SettingInfiniteInventory == 1
org $8be3fe
jsl LR_RestoreSaveFileWithInfiniteInventoryOrSec   ; replaces jsl $83d954
endif

org $8be42b
; Replacing lda #$2800 : trb $09ae when resuming a saved game
jsr SR_SetGameStartCliAndEngineFlags : nop : nop : nop

; Replace sound type selection with difficulty selection.
org $8be43f
lda #$0001 : sta $0d90    ; Default is Intermediate
org $8be4ae
db $03    ; 4 difficulty levels available

; Upon starting a new game, set IOGR flags.
org $8be515
if !StartAtWarpLocation == 1
jsl LR_WarpToStart
else
jsl LR_WarpToSchool
endif
jmp EIogrGameInitFlagSetter

; To support button mappings, IOG stores a dynamic bitmask for each SNES button, and the mask determines functionality;
; so e.g. mask #$8000 represents the Attack button, and whichever SNES button sets that mask is thus the Attack button.
; The "default" (actually Style 2) mappings are the same as the SNES hardware bitmasks, except that X is ignored.
; Oddly, in Style 1 the "unused" button (A or Y) has the same bitmask as the hardware X button.
; Here we remove the code that disables the X button, and fix the "unused" button mapping in Style 1.
org $8be695
#SR_SetControlStyle:
lda $0B26 : bne .Style2
.Style1:
  lda #$8000 : sta $0DAC    ; Remap A ($0dac) to action of #$8000 = Attack
  lda #$4000 : sta $0DAA    ; Remap B ($0daa) to action of #$4000 = Cancel
  lda #$0080 : sta $0DAE    ; Remap Y ($0dae) to action of #$0080 = unused
rts
.Style2:
rts

; 4 difficulty levels available on the other menu too
org $8be7b5
db $03
org $8be855
db $04

org $8be905   ; Ignore up input on erase/option/copy file selects
rtl
org $8be91e   ; Ignore down input on erase/option/copy file selects
rtl
org $8bea86   ; Ignore up input on erase/option/copy file selects
rtl
org $8bea9f   ; Ignore down input on erase/option/copy file selects
rtl


org $8bee20
EDebugWarper:
{
.Menu1:
cop #$BF : dw .TextDebugMapListPageOne
cop #$BE : db $0a, $00 : dw ..Options
..Options:
  dw .Cancel
  dw .EdwardsCastle, .EdwardsDungeon, .Itory, .MoonTribe, .Inca
  dw .Freejia, .DiamondMine, .SkyGarden, .SeaPalace
  dw .Menu2
.Menu2:
cop #$BF : dw .TextDebugMapListPageTwo
cop #$BE : db $0a, $00 : dw ..Options
..Options:
  dw .Cancel
  dw .Mu, .AngelVillage, .Watermia, .GreatWall, .Euro
  dw .NativesVillage, .AngkorWat, .Dao, .Babel, .Comet
.Cancel:
cop #$BF : dw .TextDebugMapOkay
cop #$E0 
.EdwardsCastle:
cop #$26 : db $0A : dw $01E3,$00A0 : db $83,$00,$45
rtl 
.EdwardsDungeon:
cop #$26 : db $0b : dw $00f0,$0140 : db $80,$00,$32
rtl 
.Itory:
cop #$26 : db $15 : dw $0339,$01B0 : db $80,$00,$35
rtl 
.MoonTribe:
cop #$26 : db $1A : dw $0110,$00C3 : db $80,$00,$22
rtl 
.Inca:
cop #$26 : db $1C : dw $006C,$0174 : db $87,$00,$22
rtl 
.Freejia:
cop #$26 : db $32 : dw $0138,$0360 : db $87,$00,$45
rtl 
.DiamondMine:
cop #$26 : db $3E : dw $00B0,$03D0 : db $87,$00,$42
rtl 
.SkyGarden:
cop #$26 : db $4C : dw $0100,$0136 : db $87,$00,$22
rtl 
.SeaPalace:
cop #$26 : db $5A : dw $0088,$00A0 : db $87,$00,$64
rtl 
.Mu:
cop #$26 : db $5F : dw $0088,$0050 : db $87,$00,$44
rtl 
.AngelVillage:
cop #$26 : db $69 : dw $02A8,$00A0 : db $87,$00,$13
rtl
.Watermia:
cop #$26 : db $78 : dw $027E,$03A0 : db $87,$00,$45
rtl 
.GreatWall:
cop #$26 : db $82 : dw $0020,$0090 : db $87,$00,$18
rtl 
.Euro:
cop #$26 : db $91 : dw $0370,$0430 : db $83,$00,$54
rtl 
.NativesVillage:
cop #$26 : db $AC : dw $01C0,$01D0 : db $87,$00,$22
rtl 
.AngkorWat:
cop #$26 : db $B0 : dw $0200,$04D0 : db $87,$00,$54
rtl 
.Dao:
cop #$26 : db $C3 : dw $0010,$00E8 : db $87,$00,$23
rtl 
.Pyramid:
cop #$26 : db $CC : dw $002C,$00E0 : db $87,$00,$44
rtl 
.Babel:
cop #$26 : db $DE : dw $0088,$00A0 : db $80,$00,$11
rtl 
.Comet:
cop #$26 : db $E7 : dw $0088,$00A0 : db $80,$00,$11
rtl 

.TextDebugMapListPageOne:
db $c1 : db $02,$06
db $c7 : db $0e,$0a
db $ce
db $d2,$00
db "_Edward's Castle",$cb    ; Edward's Castle
db "_Edward's Tunnel",$cb
db "_Itory",$cb    ; Itory
db "_",$d6,$31,"Tribe",$cb
db "_",$d6,$1e,$cb    ; Inca 
db "_Freejia",$cb 
db "_",$d6,$0e,"Mine",$cb
db "_Sky Garden",$cb
db "_",$d7,$32,"Palace",$cb    ; Seaside Palace
db "_Other..."    ; other ...
db $ca

.TextDebugMapListPageTwo:
db $c1 : db $02,$06
db $c7 : db $0e,$0a
db $ce
db $d2,$00
db "_Mu",$cb
db "_",$d6,$01,"Village",$cb    ; Angel Village
db "_Watermia",$cb    ; Watermia
db "_",$d6,$16,"Wall",$cb
db "_Euro",$cb
db "_Natives' Village",$cb    ; Native's Village
db "_",$d6,$04,"Wat",$cb
db "_Dao",$cb
db "_Babel",$cb
db "_Comet"
db $ca

.TextDebugMapOkay:
db $ce
db "Okay."
db $c0
}
warnpc $8bf178


table "table_dialogue.txt",rtl
org $8bf3f4
; Main menu: no Copy option because there's only one save file
db $C1 : db $06,$0A
db $C7 : db $0A,$03
db "Start Journey",$cb
db "Erase Journey",$cb
db "Change Options"
db $CA
warnpc $8bf437
org $8bf437
; Start-game menu: only one save file
db $c1 : db 2,8
db $c7 : db $0e,$03
org $8bf457
; Stop drawing text after the first save file
db $ca
org $8bf476
; Option menu: only one save file
db $c1 : db 2,8
db $c7 : db $0e,$03
org $8bf48c
; Copy menu: only one save file
db $c1 : db 2,8
db $c7 : db $0e,$03
org $8bf4a7
; Erase menu: only one save file
db $c1 : db 2,8
db $c7 : db $0e,$03
org $8bf4ea
; No text for second save file (unnecessary?)
db $ca
org $8bf511
; No text for third save file (unnecessary?)
db $ca

org $8bf538
Bg3_MenuChangeDiarySettings:
db $C1 : db $06,$08
db $C7 : db $0A,$08
db $CC : db $02
db "_____*Settings*",$cb
db ">Done",$cb
db "Level:",$cb
db "Control Style:",$cb
db $CC,$0d
db "Attack/Talk",$cb
db $CC,$0d
db "Item/Cancel",$cb
db $CC,$0d
db "Item Screen",$cb
db $CC,$0d
db "Run"
db $CA
warnpc $8bf5ad
org $8bf5ad
Bg3_MenuNewDiarySettings:
db $C1 : db $06,$08
db $C7 : db $0A,$08
db "____*Game Setup*",$cb
db ">Start Game",$cb
db "Level:",$cb
db "Control Style:",$cb
db $CC,$0d
db "Attack/Talk",$cb
db $CC,$0d
db "Item/Cancel",$cb
db $CC,$0d
db "Item Screen",$cb
db $CC,$0d
db "Run"
db $CA
warnpc $8bf625

org $8bf630
Bg3_MenuBranchControlOptions:
db $c1 : db $14,$0e
db $d2 : db $00
db $c5 : dw $f63b, $0d8e
db $ca
warnpc $8bf63b

org $8bf667    ; Pointers to level name texts
dw TextDifficultyLevel0
dw TextDifficultyLevel1
dw TextDifficultyLevel2
dw TextDifficultyLevel3

org $8bf8c4
dw $fa47    ; Overworld name pointer for map $DF Dark Space, moved from map $E0.



org $8bfa74
; Bank $8B free space.
SR_FixWatFlyHomeAndLayer:
cop #$B6 : db $30
lda $7f100c,x : cmp #$0050 : bcs +
  lda #$0050 : sta $7f100c,x
+:
lda $7f100e,x : cmp #$0050 : bcs +
  lda #$0050 : sta $7f100e,x
+:
rts

TextDifficultyLevel0:
db "Beginner____",$ca
TextDifficultyLevel1:
db "Intermediate",$ca
TextDifficultyLevel2:
db "Advanced____",$ca
TextDifficultyLevel3:
db "Expert______",$ca

; Game flag initialization.
EIogrGameInitFlagSetter:
{
jsr SR_SetGameStartCliAndEngineFlags
; Copy game settings into RAM for the autotracker.
sep #$20
lda.l Config_HieroOrder1 : sta $0a58
lda.l Config_HieroOrder2 : sta $0a59
lda.l Config_HieroOrder3 : sta $0a5a
lda.l Config_HieroOrder4 : sta $0a5b
lda.l Config_HieroOrder5 : sta $0a5c
lda.l Config_HieroOrder6 : sta $0a5d
rep #$20
lda.l Config_AutotrackerLogicAndKaraVal : sta $0a5e
lda.l Config_Statue1Required : beq +
  cop #$CD : dw $02f8
+:
lda.l Config_Statue2Required : beq +
  cop #$CD : dw $02f9
+:
lda.l Config_Statue3Required : beq +
  cop #$CD : dw $02fa
+:
lda.l Config_Statue4Required : beq +
  cop #$CD : dw $02fb
+:
lda.l Config_Statue5Required : beq +
  cop #$CD : dw $02fc
+:
lda.l Config_Statue6Required : beq +
  cop #$CD : dw $02fd
+:
lda.l Config_SettingStatuesPlayerChoice : beq +
  cop #$CD : dw $02fe
+:
sed
phx
ldx #$0000
-:
lda.l Config_JewelerCostsAnchor,x : tay
sep #$20
lda #$00
--:
clc : adc #$01
dey : bne --
pha
txa : lsr : tay
pla : sta $0a49,y    ; Jeweler costs as BCD are in $0a49-$0a4f
inx : inx
cpx.w #14 : bcc -
cld
plx
rep #$20
cop #$CD : dw (!SettingOpenMode*$02ff)
if !SettingOpenMode == 1
lda.w #%1011111011010011 : tsb $0a02   ; Flags $10/6/7/9/a/b/c/d + OpenMode $11/4/f
else
lda.w #%0011111011000001 : tsb $0a02   ; Flags $10/6/7/9/a/b/c/d
endif
cop #$CC : db $26
cop #$CC : db $27
if !SettingOpenMode == 1
cop #$CC : db $2a
endif
lda.w #%1010100000000000 : tsb $0a06   ; Flags $3b/d/f
if !SettingOpenMode == 1
lda.w #%0000011010000010 : tsb $0a08   ; Flags $47/9/a + OpenMode $41
else
lda.w #%0000011010000000 : tsb $0a08   ; Flags $47/9/a
endif
lda.w #%0000000111000000 : tsb $0a0a   ; Flags $56/7/8
lda.w #%0101110111110000 : tsb $0a0c   ; Flags $64/5/6/7/8/a/b/c/e
lda.w #%0011010011111110 : tsb $0a0e   ; Flags $71/2/3/4/5/6/7/a/c/d
lda.w #%1011100011011100 : tsb $0a10   ; Flags $82/3/4/6/7/b/c/d/f
lda.w #%0010000010011111 : tsb $0a12   ; Flags $90/1/2/3/4/7/d
lda.w #%1111001010110000 : tsb $0a14   ; Flags $a4/5/7/9/c/d/e/f
if !SettingEnemizer >= 2
cop #$CC : db $a0
cop #$CC : db $a1
endif
lda.w #%0000000001001111 : tsb $0a16   ; Flags $b0/1/2/3/6
lda.w #%1110000001001101 : tsb $0a1a   ; Flags $d0/2/3/6/d/e/f
if !StartLocationId == 19    ; [Lilly's door? and] DS are open if starting at back of Edward's
;cop #$CD : dw $0113
cop #$CD : dw $0116
elseif !StartLocationId == 46   ; Mine hidden DS is open if starting there
cop #$CD : dw $0132
elseif !StartLocationId == 47   ; Mine fences open if starting at back of Mine
cop #$CD : dw $0134
cop #$CD : dw $0135
cop #$CD : dw $0136
;elseif !StartLocationId == 122 || !StartLocationId == 124
;; Consider opening Wat entrance stairs if starting in Wat
;cop #$CD : dw $016c
endif
; $F4 is used on the attract maps, so needs to be cleared; then indicates whether
; Kara is in Mine; then later is cleared and indicates whether ApoGaia P2 is defeated.
cop #$CE : db $F4
lda.l Config_KaraLocation : cmp #$0002 : bne +
  cop #$CC : db $F4
+:
stz $0bfc   ; Default to fast item-get text speed.
jsl LR_MarkRoomRewardsObtainedByDifficulty
lda.l Config_SettingFluteOpt : bne +
  cop #$CC : db $18   ; Set "has Flute" flag if starting with flute
+:
if !SettingInfiniteInventory == 1
cop #$CD : dw $09d0   ; tracker flag
endif
ldx #$0002
lda #$0000
-:
sta $306000,x
inx : inx : cpx #$0800 : bcc -
tdc : tax
; DMA clears this RAM elsewhere, but in one reported instance, a platform didn't emulate the DMA correctly
ldy #$0000
lda #$0000
-:
sta $0dc0,y
iny : iny : cpy #$0040 : bcc -
if !SettingDebug == 1
lda #$0015 : sta $0ac6
  jsl LR_GiveNormalItemA8OrSec
endif
cop #$E0
}

SR_OverrideEndgameWithZeroHp:    ; For "winning" the game in RJM+RJH by giving enough RJs to drop your HP to 0.
lda $0aca : beq +
  cop #$BF : dw $d558
  rts
+:
pla
cop #$BF : dw .TextForWinning
cop #$C1
rtl
.TextForWinning:
{
db $C1 : db 3,7
db $C7 : db 13,3
db $C2 : db $13
db $D2 : db $00
db $D5 : db $06
db $D6,$63,$A9,$8E,$A5,$AC,$D6,$B3,$88,$A4,$AC,$87,$84,$A2,$84,$2A
db $C9 : db $B4
db $CB
db $CB
db $48,$AC,$A3,$A5,$A0,$A0,$8E,$A3,$84,$AC,$48,$AC,$D6,$CA
db $CB
db $82,$8E,$8D,$86,$A2,$80,$A4,$A5,$8B,$80,$A4,$84,$AC,$D7,$C7,$69,$8E,$A5,$AC
db $CB
db $D6,$80,$A3,$8E,$AC,$82,$8B,$8E,$A3,$84,$AC,$A4,$8E,$AC,$A7,$88,$8D,$8D,$88,$8D,$86,$2A
db $C9 : db $B4
db $CB
db $CB
db $D6,$62,$87,$80,$A0,$A0,$84,$8D,$A3,$AC,$8D,$8E,$A7,$AB,$AC,$A9,$8E,$A5,$AC
db $CB
db $80,$A3,$8A,$0D,$AC,$D6,$63,$80,$85,$A4,$84,$A2,$AC,$D6,$D6
db $CB
db $A4,$84,$A8,$A4,$AC,$88,$A3,$AC,$85,$88,$8D,$88,$A3,$87,$84,$83,$AB,$AC,$A9,$8E,$A5,$AC
db $CB
db $D6,$EF,$83,$88,$84,$2A
db $C9 : db $B4
db $CB
db $CB
db $4E,$A6,$84,$A2,$2A,$AC,$40,$8D,$83,$AC,$8E,$A6,$84,$A2,$2A,$AC,$40,$8D,$83,$AC,$8E,$A6,$84,$A2,$2A
db $C9 : db $B4
db $CB
db $CB
db $48,$AC,$D6,$D8,$D6,$6B,$85,$88,$A8,$88,$8D,$86,$AC
db $CB
db $A4,$87,$88,$A3,$2A,$AC,$D6,$50,$D7,$8F
db $CB
db $D6,$C8,$48,$AC,$D6,$7A,$83,$8E,$AC,$A4,$8E,$AC
db $CB
db $A3,$A4,$8E,$A0,$AC,$D6,$D6,$A0,$A5,$A2,$86,$80,$A4,$8E,$A2,$A9,$AC,$8E,$85,$AC
db $CB
db $88,$8D,$85,$88,$8D,$88,$A4,$84,$AC,$83,$84,$80,$A4,$87,$2A
db $C9 : db $B4
db $CB
db $CB
db $D6,$30,$A3,$8E,$8C,$84,$83,$80,$A9,$AC,$48,$AC,$D6,$EF,$85,$88,$A8,$AC
db $CB
db $88,$A4,$2A
db $C9 : db $B4
db $CB
db $CB
db $41,$A5,$A4,$AC,$A9,$8E,$A5,$AC,$A3,$84,$84,$AB,$AC,$48,$0E,$8C,$AC,$D7,$95
db $CB
db $A1,$A5,$88,$A4,$84,$AC,$8B,$80,$AA,$A9,$2A
db $C9 : db $B4
db $CB
db $CB
db $2D,$41,$A5,$A4,$AC,$41,$80,$86,$A5,$AB,$2E,$AC,$A9,$8E,$A5,$AC,$A3,$80,$A9,$AB,$AC,$2D,$A9,$8E,$A5,$AC
db $CB
db $A4,$8E,$8E,$8A,$AC,$A4,$87,$84,$AC,$D6,$DF,$A4,$8E,$AC,$82,$8E,$83,$84,$AC
db $CB
db $D6,$D6,$A4,$84,$A8,$A4,$2A,$2E
db $C9 : db $B4
db $CB
db $CB
db $69,$84,$A3,$2A,$AC,$69,$84,$A3,$AC,$48,$AC,$83,$88,$83,$2A
db $C9 : db $B4
db $C8
db $CA
}

SR_SetGameStartCliAndEngineFlags:
{
php
sep #$20
lda $01fc : and #%11111011 : sta $01fc   ; i.e. cli in the top-level stored P flags
rep #$20
lda #$2800 : trb $09ae   ; run when starting or resuming a game
plp
rts
}

}



; Bank $8C
{

org $8c8000
incsrc "iogr_8C_actor_table.asr"
warnpc $8CE5E5

org $8ce869
if !SettingEnemizer >= 2
;db $13 : dl $80B520   ; In enemizer, don't spawn Inca mud golem palette bundle
db $00 : dl $80BF89
db $FF 
endif

org $8ceaba
; The AG code changes the addresses of some of these thinkers.
if !ApocalypseGaia == 1
db $00 : dl ECometBG-2
db $71 : dl TIndexedPaletteBundle-2
db $00 : dl ECometBG2ShimmerEndpoint-2
db $00 : dl ECometBG2ShimmerA-2
db $00 : dl ECometBG2ShimmerB-2
db $00 : dl ECometBG2ShimmerC-2
db $FF
endif
warnpc $8CEAD3


; For Apocalypse Gaia, we make various changes to the Comet and DG code.
org $8ceb74
if !ApocalypseGaia == 1
; The Comet's face and Dark Gaia live on BG1, the Comet's surface and the sky on BG2.
; This thinker hides BG1 at the start of the map, then after Will lands
; its pointer is changed to a new spot that reveals BG1 and thus the Comet's face.
; After the Comet dies, it restores this thinker to $8ceb76 to hide its face again;
; then when spawning Dark Gaia it sends the thinker back to $eba1 once again
; to create a visual effect over its body; then to $ebf7 once Dark Gaia is on-screen,
; then to $ec35 when the latter dies.
; So this is "BG1 Invisible":
db $00,$08
ECometBG:
{
jsl LR_ClearCache
lda #$0016 : sta $212C
lda #$0282 : sta $2130
lda #$1810 : sta $2107
cop #$C2
bit $0A1E : bpl ECometBG
rtl			;  these options refresh every frame.
}

; The Comet sets the above's pointer to here after Will lands.
; This is "BG1 Translucent and Tinted like the Comet".
.AfterLanding:
{
jsl LR_ClearCache
lda #$1810 : sta $2107
lda #$0217 : sta $212C
lda #$1182 : sta $2130
cop #$C2
bit $0A1E : bpl .AfterLanding
rtl
}

; Vanilla doesn't use this, so I'm modding it for AG.
.AGP1:
{
jsl LR_PushAndUpdateAGBody
stz $2126 ; and $2127 too: window 1 position
lda #$0017 : sta $212C ; enable o,BG1-3 on main; nothing on sub
sep #$20
  inc : sta $2108 ; BG2 tilemap addr
  asl : sta $2125 ; enable+invert color window 1
lda #$10 : sta $2107 ; BG1 tilemap addr
stz $2130 ; cmath=dir,all; zeroed nowhere
lda #$23 : sta $2131 ; cmath=add, on BG1+2+B
rep #$20
cop #$C2
bit $0A1E : bpl .AGP1
rtl
}

.AGP3:
{
jsl LR_PushAndUpdateCometBG
stz $2126 ; and $2127 too: window 1 position
sep #$20
lda #$15 : sta $212C ; enable o,BG1,3 on main
lda #$18 : sta $2108 ; BG1+2 are the same
  asl : sta $2125 ; enable+invert color window 1
lda #$10 : sta $2107 ; BG1 tilemap addr
lda #$02 : sta $2130 ; cmath=sub,all; zeroed nowhere
  sta $212D ; enable BG2 on sub
lda #$33 : sta $2131 ; cmath=add, on O+BG1+2+B
rep #$20
cop #$C2
bit $0A1E : bpl .AGP3
rtl
}

; This one occurs once Dark Gaia is on-screen.
.DGOnScreen:
{
jsl LR_ClearCache
stz $2126 ; and $2127 too: window 1 position
sep #$20
lda #$17 : sta $212C ; enable o+BG1-3 on main
  inc : sta $2108 ; BG2 tilemap addr
  asl : sta $2125 ; enable+invert color window 1
stz $212D ; nothing on subscreen
lda #$22 : sta $2130 ; cmath=addsub, inside-window-only
lda #$03 : sta $2131 ; cmath=add, on BG1&2
lda #$10 : sta $2107 ; BG1 tilemap addr
lda #$57 : sta $7F0C02 ; color adder
rep #$20
cop #$C2
bit $0A1E : bpl .DGOnScreen
rtl
}

; In final death.
; This places a colorful tinge over BG1+BG2.
.DGDead:
{
jsl LR_ClearCache
lda #$0017 : sta $212C ; enable obj,BG1-3 on main; nothing on sub
lda #$3b80 : sta $2130 ; cmath=fixed,all-but-BG3,zeroed first in window; cmath=add, all layers
sep #$20
stz $2125 ; disable windows all layers
lda #$18 : sta $2108 ; BG2 tilemap addr
lda #$10 : sta $2107 ; BG1 tilemap addr
rep #$20
cop #$C2
bit $0A1E : bpl .DGDead
rtl
}

TDGMouthLaser:
{
lda #$0004 : sta $7F000E,x
lda #$0000
  sta $7F0000,x
  sta $7F0002,x
  sta $7F0006,x
cop #$C1
phd
  lda #$0000 : tcd
tay
lda $7F0000,x : lsr : bcc +
  ldy #$0200
+:
sep #$20
phb
  lda #$7E : pha : plb
rep #$20
lda $7F0002,x : inc : inc : sta $7F0002,x : sta $0E
lda #$857A : sta $18
lda #$00FF : sta $7C01,y
sep #$20
lda #$45 : sta $7C00,y
iny : iny : iny
.LoopBody:
lda #$04 : sta $7C00,y
lda $18 : dec : sta $18
  sta $7C01,y
lda $19 : inc : sta $19
  sta $7C02,y
iny : iny : iny
dec $0E : bpl .LoopBody
rep #$20
lda #$FF01 : sta $7C00,y
lda #$0000 : sta $7C02,y
plb
pld
lda $7F0000,x : lsr : bcs +
  cop #$02 : db $00,$7C,$7E,$26 ; HDMA to window pos
  bra ++
+:
  cop #$02 : db $00,$7E,$7E,$26 ; HDMA to window pos
++:
lda $7F0000,x : inc : sta $7F0000,x
lda $7F0002,x : cmp #$0024 : bcs +
  rtl
+:
lda #$0023 : sta $7F0002,x
lda $7F0006,x : inc : sta $7F0006,x
cop #$CE : db $02
cop #$DA : db $01
lda #$00FF : sta $2126 ; window covers screen
cop #$3D
rtl
}

ECometSpawnPalette:
cop #$37 : db $7D
bra EDGMouthLaserPalette_DoAndDie

ECometDeathPalette:
cop #$37 : db $7F
bra EDGMouthLaserPalette_DoAndDie

EDGMouthLaserPalette:
cop #$37 : db $69
.DoAndDie:
cop #$39
cop #$E0


endif
warnpc $8CED4B

org $8ceeaa
if !ApocalypseGaia == 1
db $00,$00,$21
EComet:
lda #$0010 : tsb $12
lda #$0081 : sta $14
lda #$00EA : sta $16
jsl LR_SetupPlayerForComet    ; replenish herbs if applicable; set ptr to "falling"; restore camera
lda #$0800 : tsb $09AE
cop #$C1
lda $09AE
bit #$0800 : beq +
  rtl
+:
cop #$D0 : db $F4,$01 : dw ECometDeath
cop #$9B : dl ECometSpawnPalette
cop #$C2
lda.w #ECometBG_AfterLanding : sta $0F00
cop #$57 : dl ECometDeath
cop #$04 : db $10
cop #$DA : db $FE
cop #$80 : db $1F
cop #$89
-:
cop #$58 : dw .OnHit
lda #$2300 : trb $10
cop #$A5 : dl ECometAttack : db $00,$00,$01,$03
sty $24
lda #$0064 : sta $26
cop #$C1
dec $26 : bmi +
  rtl
+:
lda #$2300 : tsb $10
--:
cop #$DB : dw $01DF
bra -
.OnHit:
lda #$2000 : tsb $10
cop #$A2 : dl .HitFlicker : dw $2300
cop #$CA : db $10
{
ldy $24 : beq +
  lda $0010,y : ora #$2000 : sta $0010,y
+:
cop #$C2
ldy $24 : beq +
  lda $0010,y : and #$DFFF : sta $0010,y
}
+:
cop #$CB
bra --

.HitFlicker:
cop #$CA : db $10
{
lda #$0216 : sta $212C
cop #$C2
lda #$0217 : sta $212C
}
cop #$CB
cop #$E0

ECometDeath:
cop #$9C : dl EGameStatsDisplay : dw $2000
cop #$CC : db $03
lda #$2300 : tsb $10
phx
  lda $069E : tax : lda #$0100 : clc : jsl LR_MassSTZ
plx
ldy $24
beq +
  lda $0010,y : ora #$2000 : sta $0010,y
+
cop #$9B : dl ECometDeathPalette
cop #$DA : db $3B
lda.w #ECometBG : sta $0F00
cop #$3C : dl TFade012NormalToWhite
cop #$DA : db $77
lda #$AD44 : sta $7F0020,x
lda $AD44 : and #$00FF : sta $7F0026,x
lda #$2301 : sta $10
lda #$1000 : tsb $12
lda #$0080 : tsb $09EC
cop #$C2
lda #$0800 : tsb $09AE
  xba : trb $1010
cop #$CA : db $80
{
lda $068E : inc : inc : sta $06C2
ldy $0056
-:
lda $0010,y : bit #$0400 : beq +
  lda $0016,y : inc : inc : sta $0016,y
+:
lda $0006,y
tay
bne -
}
cop #$CB
lda #$0008 : tsb $1010
cop #$CC : db $01
cop #$D0 : db $F4,$01 : dw EDarkGaia_OnDeath_PlayerRespawn
cop #$C2
cop #$3C : dl TFade012WhiteToNormal
lda.w #ECometBG_AfterLanding : sta $0F00
cop #$DA : db $63
lda.w #ECometBG_DGOnScreen : sta $0F00
cop #$DA : db $63
lda #$0080 : trb $09EC
cop #$32 : db $9D
cop #$33
cop #$A2 : dl EDGFlame_Init : db $01,$03
  tya : sta $7F0010,x
cop #$A2 : dl EDGBubbleSpawner_Left : db $00,$22
cop #$A2 : dl EDGBubbleSpawner_Right : db $00,$22
cop #$58 : dw $0000
lda #$0080 : sta $14
lda #$0150 : sta $16
lda #$2000 : trb $10
lda #$0001 : tsb $12
cop #$80 : db $03
cop #$89
EDarkGaia:
.Main:
cop #$57 : dl EDarkGaia_OnDeath
.MainNoDeathPointer:
cop #$C1
lda $7F0012,x : bmi EDarkGaia_TryAttack
  dec : sta $7F0012,x
lda #$0000
jmp EDarkGaia_SpawnLightning

.TryAttack:
cop #$73 : and #$0007 : sta $0000
cop #$D9
  dw $0000,EDarkGaia_AttackD9
.AttackD9:
  dw EDarkGaia_SpawnLightning,EDarkGaia_SpawnLightning
  dw EDarkGaia_DoMouthLaser,EDarkGaia_DoMouthLaser
  dw EDarkGaia_DoMouthLaser,EDarkGaia_DoMouthLaser
  dw EDarkGaia_DoMouthLaser,EDarkGaia_DoMouthLaser


.DoMouthLaser:
lda #$0003 : sta $7F0012,x
lda $7F0010,x : tay
lda.w #EDGFlame_WithMouthLaser : sta $0000,y
lda #$0000 : sta $0008,y
lda #$0200 : trb $10
cop #$80 : db $17
cop #$89
..NoSpriteOrFlame:
lda #$0200 : tsb $10
lda #$0057 : sta $7F0C02
cop #$3C : dl TDGMouthLaser
cop #$CC : db $02
cop #$A5 : dl EDGMouthLaserPalette : db $00,$00,$00,$20
cop #$07 : db $20
cop #$A5 : dl EDGMouthLaserHitbox : db $00,$00,$00,$22
jsr .SR_IfAGThenRtl

.WhileMouthLaser:
cop #$80 : db $1A
cop #$89
cop #$D0 : db $02,$01 : dw EDarkGaia_WhileMouthLaser

.AfterMouthLaser:
lda #$00FF : sta $2126
cop #$84 : db $06,$3C
cop #$8A
cop #$80 : db $18
cop #$89
lda $7F0010,x : tay
lda.w #EDGFlame_AfterMouthLaser : sta $0000,y
lda #$0000 : sta $0008,y
jmp EDarkGaia_Main

.SpawnLightning:
cop #$A5 : dl EDGLightning_Left : db $00,$00,$01,$03
cop #$A5 : dl EDGLightning_Right : db $00,$00,$01,$03
jsr .SR_IfAGThenRtl
cop #$DB : dw $012B
jmp EDarkGaia_Main

.OnDeath:
jsr SR_LogDarkGaiaCompletionTimeAndTempFlags
jsl LR_SetPlayerImmuneAndFrozen
jsl LR_StorePlayerHerbCount
cop #$A0 : dl EDarkGaiaDeathExplosionSpawner : dw $0080,$0170,$2300
cop #$A0 : dl EDarkGaiaDeathLightning1 : dw $0060,$01b8,$0B12
cop #$A0 : dl EDarkGaiaDeathLightning1 : dw $00b1,$01b8,$0B12
cop #$A0 : dl EDarkGaiaDeathLightning3 : dw $00b4,$01a0,$0B12
cop #$A5 : dl EDarkGaiaDeathPebbles : dw $0000,$2B00
cop #$80 : db $19
cop #$89
cop #$3C : dl TFade012NormalToWhite
lda.w #ECometBG_DGDead : sta $0F00
cop #$DB : dw $0120
..PlayerRespawn:
lda #$0030 : tsb $0A00
lda #$0080 : trb $09EC
lda #$0150 : sta $16
lda.w #ECometBG_AGP1 : sta $0F00
lda #$2000 : tsb $10
cop #$3C : dl TFade012WhiteToNormal
cop #$DA : db $FF
lda #$0018 : trb $0A00
cop #$07 : db $0C
cop #$80 : db $1F
cop #$9C : dl EAGBackgroundColors : dw $2300
cop #$9C : dl EAGSpriteColors : dw $2300
cop #$A1 : dl EAGScrollOn : dw $2300
cop #$A4 : dl EAGBitP1_InitL : db $c8,$23 : dw $0111
cop #$A4 : dl EAGBitP1_InitR : db $38,$23 : dw $2111
cop #$A4 : dl EAGLauncher_InitL : db $BF,$0B : dw $0301
cop #$A4 : dl EAGLauncher_InitR : db $41,$0B : dw $0301
cop #$07 : db $21
lda #$0003 : sta $24
cop #$C4 : dl EAGCoreP1

.SR_IfAGThenRtl
lda $0A00 : bit #$00E0 : bne +$01 : rts
pla : rtl

EDarkGaiaDeathLightning1:
.WithDarkGaiaDeath:
cop #$80 : db $08
cop #$89
lda $0A00 : bit #$0010 : bne .WithDarkGaiaDeath
.Die:
cop #$E0

EDarkGaiaDeathLightning3:
.WithDarkGaiaDeath:
cop #$80 : db $09
cop #$89
lda $0A00 : bit #$0010 : bne .WithDarkGaiaDeath
lda.w #.WithAGMain : sta $00
.WithAGMain:
lda #$2000 : trb $10
txy : lda.w #2*$73 : brk : pha
  and #$000F : adc #$01B0 : sta $16
pla : lsr : lsr : adc #$0068 : sta $14
lda $0036 : lsr : bcs ..Sprite09
..Sprite08:
cop #$80 : db $08
cop #$89
bra ..SleepRandom
..Sprite09:
cop #$80 : db $09
cop #$89
..SleepRandom:
bit $09FF : bvs EDarkGaiaDeathLightning1_Die ; checks flag $06
lda #$2300 : tsb $10
lda.w #.WithAGMain : sta $00
lda.w #2*$73 : brk : lsr : sta $08
rtl

EDarkGaiaDeathExplosionSpawner:
stz $24
cop #$88 : dl $8ee000
-
lda $24 : adc #$0003 : sta $24
cop #$CA : db $04
{
cop #$A5 : dl EDarkGaiaDeathExplosion1 : db $00,$00,$02,$03
lda $24 : sta $08
cop #$C2
cop #$A5 : dl EDarkGaiaDeathExplosion2 : db $00,$00,$02,$03
lda $24 : sta $08
cop #$C2
}
cop #$CB
lda $24 : cmp #$0012 : bcc -
cop #$DA : db $12
cop #$A5 : dl EDarkGaiaDeathExplosion2 : db $00,$00,$02,$03
cop #$E0

EDarkGaiaDeathExplosion1:
cop #$07 : db $06
lda #$0020 : jsl LR_SetRandomPosition
cop #$80 : db $07
cop #$89
cop #$E0

EDarkGaiaDeathExplosion2:
cop #$07 : db $06
lda #$0020 : jsl LR_SetRandomPosition
cop #$80 : db $01
cop #$89
cop #$E0

EDGMouthLaserHitbox:
lda #$AD50 : sta $7F0020,x
lda #$0080 : sta $14
lda #$01E0 : sta $16
cop #$DA : db $09
lda #$2000 : trb $10
cop #$84 : db $1F,$0A
cop #$8A
cop #$E0

EDarkGaiaDeathPebbles:
lda #$0220 : sta $16
cop #$CA : db $03
{
cop #$9C : dl .NormalRocks : dw $0B12
cop #$DA : db $19
cop #$9C : dl .SmallRocks : dw $0B12
cop #$DA : db $19
cop #$9C : dl .TinyRocks : dw $0B12
cop #$DA : db $19
}
cop #$CB
.Die:
cop #$E0

.NormalRocks:
cop #$CA : db $02
cop #$73 : sta $14
cop #$83 : db $1B,$00,$06
bra .Animate
.SmallRocks:
cop #$CA : db $02
cop #$73 : sta $14
cop #$83 : db $1C,$00,$06
bra .Animate
.TinyRocks:
cop #$CA : db $02
cop #$73 : sta $14
cop #$83 : db $1D,$00,$08
.Animate:
cop #$89
.AnimateRestart:
cop #$B1
cop #$80 : db $FF
cop #$89
lda $16 : cmp #$00E0 : bcs .AnimateRestart
lda #$0220 : sta $16
cop #$CB
cop #$E0

EDGLightning:
.Left:
lda #$0031 : sta $14
jsr .CommonInitSR
cop #$80 : db $09
cop #$89
lda #$0010 : sta $14
lda #$0150 : sta $16
cop #$80 : db $0A
cop #$89
lda #$0004 : sta $26
bra .Chase
.Right:
cop #$BB
lda #$0082 : tsb $12
lda #$00CF : sta $14
jsr .CommonInitSR
cop #$80 : db $09
cop #$89
lda #$00F0 : sta $14
lda #$0150 : sta $16
cop #$80 : db $0A
cop #$89
lda #$000C : sta $26

.Chase:
cop #$07 : db $20
cop #$5B : db $10,$00
lda #$00A0 : tsb $12
lda #$AD48 : sta $7F0020,x
cop #$80 : db $0B
cop #$89
lda #$0100 : trb $10 : tsb $12
..Immediate:
cop #$A2 : dl EChaser : db $00,$20
lda #$800B : sta $7F000A,x
lda #$0003 : sta $7F0014,x
lda #$1000 : sta $0024,y
phx : tyx
  lda $26 : sta $7F000E,x
plx
lda #$0002 : tsb $10
cop #$84 : db $0B,$05
cop #$8A
phx
  ldx $06
  lda $7F002C,x : sta $0000
  lda $7F002E,x
plx
  sta $7F100E,x
lda $0000 : sta $7F100C,x
cop #$A9
-:
cop #$C1
cop #$8B
lda $08 : sta $24
stz $08
cop #$C1
lda $7F100C,x : sta $7F002C,x
lda $7F100E,x : sta $7F002E,x
dec $24 : bmi +
  rtl
+:
bit $10 : bvc -
cop #$E0

.CommonInitSR:
lda #$0197 : sta $16
cop #$9C : dl .SmallSprite : db $01,$03
rts

.SmallSprite:
cop #$80 : db $08
cop #$89
cop #$E0

EDGBubbleSpawner:
.Left:
lda #$0018
bra .Both
.Right:
lda #$00E8
.Both:
sta $14
lda #$01D8 : sta $16
.RandomWait:
cop #$73 : lsr : lsr : adc #$0078 : sta $08
cop #$C2
cop #$D0 : db $04,$01 : dw EDGBubble_BubbleDie
cop #$A2 : dl EDGBubble : db $00,$02
bra .RandomWait

EDGBubble:
cop #$5B : dw $0080
lda #$00A0 : tsb $12
cop #$84 : db $11,$02
cop #$8A
cop #$80 : db $12
cop #$89
lda #$AD4C : sta $7F0020,x
cop #$07 : db $1D
cop #$57 : dl .OnDeath
lda #$0200 : trb $10
cop #$82 : db $13,$0A
cop #$89
cop #$82 : db $13,$2A
cop #$89
lda #$0000 : sta $7F0026,x
cop #$CA : db $04
{
cop #$C1
cop #$D0 : db $04,$01 : dw .BubbleDieWithSprite
cop #$73 : lsr : sbc #$003F : adc $1014 : sta $7F0018,x
  bpl +
    rtl
+:
cop #$73 : lsr : sbc #$003F : adc $1016 : cmp #$01D8 : bcc +
  rtl
+:
sta $7F001A,x
cop #$22 : db $13,$02
bit $10 : bvs .BubbleDie
cop #$84 : db $13,$01
cop #$8A
}
cop #$CB

.OnDeath:
cop #$07 : db $1B
.BubbleDieWithSprite:
cop #$80 : db $11
cop #$89
.BubbleDie:
cop #$E0

EDGFlame:
.Init:
lda #$0040 : tsb $12
asl : sta $14
lda #$01AA : sta $16
cop #$A4 : dl EDGFlame_ChildFlameB : db $FC,$FC,$01,$03
cop #$A4 : dl EDGFlame_ChildFlameA : db $04,$00,$01,$03

.AfterMouthLaser:
ldy $06
lda $0010,y : and #$DFFF : sta $0010,y
lda $0006,y
tay
lda $0010,y : and #$DFFF : sta $0010,y

.Idle:
cop #$80 : db $00
cop #$89
bra .Idle

.Die:
cop #$80 : db $02
cop #$89
cop #$E0

.WithMouthLaser:
cop #$80 : db $01
cop #$89
ldy $0006,x
lda $0010,y : ora #$2000 : sta $0010,y
lda $0006,y
tay
lda $0010,y : ora #$2000 : sta $0010,y
cop #$80 : db $02
cop #$C1
lda $0A00 : bit #$0020 : bne .Die
rtl

.ChildFlameA:
cop #$8D : db $0C
cop #$DA : db $09

.ChildFlameB:
cop #$80 : db $0C
cop #$89
lda $0A00 : bit #$0020 : bne .Die
bra .ChildFlameB

ECometAttack:
cop #$80 : db $0D
cop #$89
cop #$80 : db $0E
cop #$89
cop #$9C : dl ECometFireOrb : db $02,$02
cop #$80 : db $0F
cop #$89
ldy $24
lda #$0000 : sta $0024,y
cop #$E0

ECometFireOrb:
cop #$80 : db $14
cop #$89
cop #$07 : db $1D
-
cop #$82 : db $15,$0C
cop #$89
cop #$D0
  db $03,$01 : dw ECometFireDie
lda $16 : bpl -
cmp #$FFD0 : bcs -
lda #$2000 : tsb $10
cop #$CA : db $0E
cop #$D0 : db $03,$01 : dw ECometFireDie
cop #$9C : dl EAGBitP2_FireObject : db $02,$02
cop #$DA : db $0E
cop #$CB
ECometFireDie:
cop #$E0
endif
warnpc $8cf5ef

; Just one change to EDarkGaia_OnDeath if it's a normal DG
if !ApocalypseGaia == 0
org $8cf154
jsr SR_LogDarkGaiaCompletionTimeAndTempFlags
endif

org $8cf61f
SR_LogDarkGaiaCompletionTimeAndTempFlags:
lda.l SramFrameCounter : sta.l SramMainGoalFrame
lda.l 1+SramFrameCounter : sta.l 1+SramMainGoalFrame
cop #$CC : db $04
cop #$CC : db $05
rts


}




org $8d8000
incsrc "iogr_8D_asset_table.asr"
warnpc $8DB001

org $8f8058
; Replace credits-exclusive body $04 sprite $01 with a fluteless-flute-playing sprite
dw $0013, MetaWillFlutelessFlute1
dw $0013, MetaWillFlutelessFlute2
dw $ffff

org $8f8bf5   ; Overwriting an unused 8-tile metasprite
MetaWillFlutelessFlute1:
db $08,$10 : db $24,$08
db $f8,$f0 : db $01,$01
db $f8,$10 : db $f0,$10
db $06
db $01 : db $02,$08, $02,$10 : dw $0006
db $01 : db $00,$08, $0C,$1C : dw $0160 
db $01 : db $08,$00, $0C,$18 : dw $0161 
db $00 : db $04,$0E, $1B,$09 : dw $006E 
db $00 : db $0A,$08, $1B,$09 : dw $006F 
db $01 : db $03,$07, $1C,$00 : dw $000E 


org $8fc000
; AnimList for transformations.
dw $c160   ; Replace W->S #1 (slow) with W->F #1 (fast)
skip 2
skip 2
skip 2
skip 2
skip 2
dw $c5e4   ; Replace F->W #1 (slow) with F->S #1 (fast)


org $8fcf65   ; Overwriting an unused 8-tile metasprite
MetaWillFlutelessFlute2:
db $08,$10 : db $24,$08 
db $F8,$F0 : db $01,$01 
db $F8,$10 : db $F0,$10 
db $06
db $01 : db $02,$08, $03,$10 : dw $0046 ; Head
db $01 : db $00,$08, $0C,$18 : dw $0160 ; Torso 1
db $01 : db $08,$10, $0C,$18 : dw $0161 ; Torso 2
db $00 : db $04,$10, $1B,$10 : dw $006E ; Right foot
db $00 : db $0A,$08, $1B,$1C : dw $006F ; Left foot
db $01 : db $03,$00, $1C,$18 : dw $000E ; Shadow


;org $90803c
;; Inventory sprite pointers for hieroglyphs.
;dw !HieroSpritePointer1
;dw !HieroSpritePointer2
;dw !HieroSpritePointer3
;dw !HieroSpritePointer4
;dw !HieroSpritePointer5
;dw !HieroSpritePointer6

org $90805c    ; Add anim pointers for inventory multijewel sprite.
dw AAnimInvMultijewel
dw AAnimInvMultijewel

org $908376
AAnimInvMultijewel:
dw $0007 : dw AMetaspriteInvMultijewel1
dw $0007 : dw AMetaspriteInvMultijewel2
dw $ffff

org $908ea3
AMetaspriteInvMultijewel1:
db $0A,$08,$11,$00
db $F8,$F0,$01,$01,$F8,$10,$F0,$10
db $03
db $00,$08,$03,$0A,$01,$F2,$0C
db $01,$03,$00,$03,$00,$02,$0C
db $01,$00,$00,$00,$00,$02,$0C
AMetaspriteInvMultijewel2:
db $0A,$08,$11,$00
db $F8,$F0,$01,$01,$F8,$10,$F0,$10
db $03
db $00,$07,$03,$09,$01,$F4,$0C
db $01,$03,$00,$03,$00,$02,$0C
db $01,$00,$00,$00,$00,$02,$0C


; Bank $93 / $D3
org $d35e19
db 4,4
incbin "ATlMpWorldMap_Tilemap1_comp.bin"   ; Add Mansion to world map for in-game collection tracker
warnpc $D36808


; Bank $9A / $DA 
org $da5a37
; Remove a rock, preventing a Spin Dash softlock.
incbin "Tilemap6D.bin"


org $a08000

incsrc "iogr_code_overflow.asr"

incsrc "iogr_dialogue_overflow.asr"

incsrc "apocalypse_gaia_2.asr"

org $a18000
incsrc "ConfigValueArray.asr"

; Construct fluteless-Will sprites
!SprSrcAddr = $9a8000
AVramWillFluteless:
while !SprSrcAddr < $9ac000
db read1(!SprSrcAddr)
!SprSrcAddr #= !SprSrcAddr+1
endif
fillbyte $00
org AVramWillFluteless+$0540
fill $60
org AVramWillFluteless+$0740
fill $60
org AVramWillFluteless+$2120
fill $40
org AVramWillFluteless+$2560
fill $20
org AVramWillFluteless+$2720
fill $60
org AVramWillFluteless+$28e0
fill $80
org AVramWillFluteless+$2b00
fill $20
org AVramWillFluteless+$2c60
fill $40
org AVramWillFluteless+$2e60
fill $40
org AVramWillFluteless+$3400
fill $80
org AVramWillFluteless+$3600
fill $80
org AVramWillFluteless+$3800
fill $40
org AVramWillFluteless+$3a00
fill $40

warnpc $a1ffff



org $de28a5
; Add door to Mu Passage tilemap.
incbin "TilemapMuPassage.bin"

org $df2ce7
; Need to make Comet BG2 tilemap 2 high, so scrolling works in the AG fight.
db $02


org $e00000
ATlMpMuSWWaterHighSub:
db 2,4
incbin "ATlMpMuSWWaterHighSub_Tilemap1_comp.bin"
ATlMpMuSEWaterHighSub:
db 4,4
incbin "ATlMpMuSEWaterHighSub_Tilemap1_comp.bin"

if !SettingInfiniteInventory == 1
ATlMpSpecInvBg:
dw 2,2
incbin "ATlMpSpecInvBg_comp.bin"

APaleInvAnchor:
APaleInvPage1:
dw $2810, $4070, $50f6
APaleInvPage2:
dw $0d4e, $15ae, $1a34
APaleInvPage3:
dw $1580, $2183, $2a07
APaleInvPageFlash:
dw $318c, $39ce, $5294
endif

warnpc $e08000







